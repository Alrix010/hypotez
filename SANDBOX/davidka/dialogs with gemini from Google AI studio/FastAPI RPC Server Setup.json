{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.0-flash-exp",
    "candidateCount": 1,
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false
  },
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "fast_api server\n\n## \\file /src/fast_api/fast_api.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\nFastAPI сервер с XML-RPC интерфейсом для удалённого управления\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n.. module:: src.fast_api.fast_api_rpc\n    :platform: Windows, Unix\n    :synopsis: FastAPI сервер с интерфейсом XML-RPC для удалённого управления\n\n\"\"\"\nimport asyncio\nimport functools\nimport json\nimport os\nimport sys\nimport threading\nfrom types import SimpleNamespace\nfrom typing import List, Callable, Dict\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom dotenv import load_dotenv\n\nimport uvicorn\nfrom fastapi import FastAPI, APIRouter\n\nimport header  # \u003c-- Обязательный импорт\nfrom header import __root__\nfrom src import gs\nfrom src.utils.jjson import j_loads, j_loads_ns\n#from src.endpoints.bots.telegram.webhooks import telegram_webhook\nfrom src.utils.printer import pprint as print\nfrom src.logger import logger\n\nimport re\n\nload_dotenv()\n\n\ntry:\n    config: SimpleNamespace \u003d j_loads_ns(__root__ / \u0027src\u0027 / \u0027fast_api\u0027 / \u0027fast_api.json\u0027)\n    config.ports: list \u003d config.ports if isinstance(config.ports, list) else [config.ports]\nexcept Exception as ex:\n    logger.critical(f\"Config file not found!\")\n    sys.exit()\n\n_api_server_instance \u003d None\n\n\nclass FastApiServer:\n    \"\"\"FastAPI сервер с реализацией Singleton.\"\"\"\n\n    _instance \u003d None\n    app: FastAPI \u003d FastAPI()\n    host: str \u003d config.host\n    port: int \u003d 8000\n    router: APIRouter \u003d APIRouter()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance \u003d super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, host: str \u003d \"127.0.0.1\", title: str \u003d \"FastAPI RPC Server\", **kwargs):\n        if hasattr(self, \u0027_initialized\u0027):\n            return\n        self._initialized \u003d True\n        self.add_route(\"/hello\", test_function)\n        self.add_route(\"/post\", test_post, methods\u003d[\"POST\"])\n        #self.add_route(\"/telegram_webhook\", telegram_webhook, methods\u003d[\"POST\"])\n\n        self.app \u003d FastAPI()\n        self.host \u003d host or config.host\n        self.server_tasks \u003d {}\n        self.servers \u003d {}\n        self.app.include_router(self.router)\n\n    def add_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет маршрут к FastAPI приложению.\"\"\"\n        try:\n            self.router.add_api_route(path, func, methods\u003dmethods, **kwargs)\n            logger.info (f\"Маршрут {path} зарегистрировван\")\n        except Exception as ex:\n            logger.error(f\"Ошибка добавления маршрута {path}\")\n\n    # def add_new_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n    #     \"\"\"Добавляет новый маршрут к уже работающему приложению.\"\"\"\n    #     self.add_route(path, func, methods, **kwargs)\n\n    async def _start_server(self, port: int):\n        \"\"\"Запускает uvicorn сервер асинхронно.\"\"\"\n        config \u003d uvicorn.Config(self.app, host\u003dself.host, port\u003dport, log_level\u003d\"debug\")\n        server \u003d uvicorn.Server(config)\n        try:\n            await server.serve()\n            logger.success(f\"Server started on: {self.host}:{port}\")\n        except Exception as e:\n            logger.error(f\"Error running server on port {port}: {e}\")\n        finally:\n            self.servers.pop(port, None)\n\n    def start(self, port: int, as_thread:bool \u003d True):\n        \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            print(f\"Server already running on port {port}\")\n            return\n\n        task \u003d threading.Thread(target\u003dasyncio.run, args\u003d(self._start_server(port),), daemon\u003dTrue)\n        self.server_tasks[port] \u003d task\n        self.servers[port] \u003d task\n        task.start()\n\n    def stop(self, port: int):\n        \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            try:\n                self.servers[port]._thread.join(1)\n                self.servers.pop(port)\n                print(f\"Server on port {port} stopped.\")\n            except Exception as e:\n                logger.error(f\"Error stopping server on port {port}: {e}\")\n        else:\n            print(f\"Server on port {port} is not running or already stopped.\")\n\n    def stop_all(self):\n        \"\"\"Останавливает все запущенные сервера.\"\"\"\n        for port in list(self.servers):\n            self.stop(port)\n\n    def get_servers_status(self):\n        \"\"\"Возвращает статус всех серверов.\"\"\"\n        return {port: \"Running\" if task.is_alive() else \"Stopped\" for port, task in self.servers.items()}\n\n    def get_routes(self):\n      \"\"\"Возвращает список всех роутов.\"\"\"\n      routes \u003d []\n      for route in self.app.routes:\n          if hasattr(route, \"path\"):\n            methods \u003d getattr(route, \"methods\", [\"GET\"])\n            routes.append({\"path\": route.path, \"methods\": list(methods)})\n      return routes\n\n    def get_app(self):\n        \"\"\"Возвращает FastAPI приложение.\"\"\"\n        return self.app\n\n\ndef telegram_webhook():\n    \"\"\"\"\"\"\n    return \u0027Hello, World!\u0027\n\n\ndef test_function():\n    return \"It is working!!!\"\n\n\ndef test_post(data: Dict[str, str]):\n    return {\"result\": \"post ok\", \"data\": data}\n\n\ndef start_server(port: int, host: str):\n    \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance is None:\n        _api_server_instance \u003d FastApiServer(host\u003dhost)\n    _api_server_instance.start(port\u003dport)\n\n\ndef stop_server(port: int):\n    \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop(port\u003dport)\n\n\ndef stop_all_servers():\n    \"\"\"Останавливает все запущенные FastAPI серверы.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop_all()\n\n\ndef status_servers():\n    \"\"\"Показывает статус серверов.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        servers \u003d _api_server_instance.get_servers_status()\n        if servers:\n            print(f\"Server initialized on host {_api_server_instance.host}\")\n            for port, status in servers.items():\n                print(f\"  - Port {port}: {status}\")\n        else:\n            print(\"No servers running\")\n    else:\n        print(\"Server not initialized.\")\n\ndef get_routes():\n    \"\"\"Показывает все роуты.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n      routes \u003d _api_server_instance.get_routes()\n      if routes:\n        print(\"Available routes:\")\n        for route in routes:\n          print(f\"  - Path: {route[\u0027path\u0027]}, Methods: {route[\u0027methods\u0027]}\")\n      else:\n        print(\"No routes defined\")\n    else:\n        print(\"Server not initialized.\")\n\n\ndef add_new_route(path: str, func: Callable, methods: List[str] \u003d [\"GET\"]):\n    \"\"\"Добавляет новый роут к серверу.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.add_new_route(path\u003dpath, func\u003dfunc, methods\u003dmethods)\n        print(f\"Route added: {path}, {methods\u003d}\")\n    else:\n        print(\"Server not initialized. Start server first\")\n\n\ndef parse_port_range(range_str):\n    \"\"\"Разбирает строку с диапазоном портов.\"\"\"\n    if not re.match(r\u0027^[\\d-]+$\u0027, range_str):\n        print(f\"Invalid port range: {range_str}\")\n        return []\n    if \u0027-\u0027 in range_str:\n        try:\n            start, end \u003d map(int, range_str.split(\u0027-\u0027))\n            if start \u003e end:\n                raise ValueError(\"Invalid port range\")\n            return list(range(start, end + 1))\n        except ValueError:\n            print(f\"Invalid port range: {range_str}\")\n            return []\n    else:\n        try:\n            return [int(range_str)]\n        except ValueError:\n            print(f\"Invalid port: {range_str}\")\n            return []\n\n\nclass CommandHandler:\n    \"\"\"Обработчик команд для FastAPI сервера через XML-RPC.\"\"\"\n\n    def __init__(self, rpc_port\u003d9000):\n        self.rpc_port \u003d rpc_port\n        self.rpc_server \u003d SimpleXMLRPCServer((\"localhost\", self.rpc_port), allow_none\u003dTrue)\n        self.rpc_server.register_instance(self)\n        threading.Thread(target\u003dself.rpc_server.serve_forever, daemon\u003dTrue).start()\n        print(f\"RPC server started on port: {self.rpc_port}\")\n\n    def start_server(self, port: int, host: str):\n        start_server(port\u003dport, host\u003dhost)\n\n    def stop_server(self, port: int):\n        stop_server(port\u003dport)\n\n    def stop_all_servers(self):\n        stop_all_servers()\n\n    def status_servers(self):\n        status_servers()\n\n    def get_routes(self):\n        get_routes()\n\n    def add_new_route(self, path: str, func: str, methods: List[str] \u003d [\"GET\"]):\n        # Передаем ссылку на функцию вместо eval.\n        func_ref \u003d globals().get(func)\n        if func_ref:\n            add_new_route(path\u003dpath, func\u003dfunc_ref, methods\u003dmethods)\n        else:\n            print(f\"Function {func} not found.\")\n\n    def shutdown(self):\n        self.stop_all_servers()\n        self.rpc_server.shutdown()\n        print(\"RPC server shutdown\")\n        sys.exit(0)\n\n\n## \\file /src/fast_api/main.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\n.. module:: src.fast_api.main \n    :platform: Windows, Unix\n    :synopsis: Управаление параметрами Fast Api сервера\n\n\"\"\"\n\nimport sys\nimport header  # \u003c-- Обязательный импорт\nfrom src.fast_api.fast_api import CommandHandler, logger\n\n\ndef display_menu():\n    \"\"\"Выводит меню с доступными командами.\"\"\"\n    print(\"\\nAvailable commands:\")\n    print(\"  start \u003cport\u003e        - Start server on the specified port\")\n    print(\"  status              - Show all served ports status\")\n    print(\"  routes              - Show all registered routes\")\n    print(\"  stop \u003cport\u003e         - Stop server on the specified port\")\n    print(\"  stop_all            - Stop all servers\")\n    print(\"  add_route \u003cpath\u003e    - Add a new route to the server\")\n    print(\"  shutdown            - Stop all servers and exit\")\n    print(\"  help                - Show this help menu\")\n    print(\"  exit                - Exit the program\")\n\n\ndef main():\n    \"\"\"Основная функция управления сервером.\"\"\"\n    command_handler \u003d CommandHandler()\n    while True:\n        display_menu()\n        try:\n            command_line \u003d input(\"Enter command: \").strip().lower()\n            if not command_line:\n                continue\n\n            parts \u003d command_line.split()\n            command \u003d parts[0]\n\n            if command \u003d\u003d \"start\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: start \u003cport\u003e\")\n                    continue\n                try:\n                    port \u003d int(parts[1])\n                    host \u003d input(\"Enter host address (default: 127.0.0.1): \").strip() or \"127.0.0.1\"\n                    command_handler.start_server(port\u003dport, host\u003dhost)\n                except ValueError:\n                    print(\"Invalid port number.\")\n                except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n            elif command \u003d\u003d \"status\":\n                command_handler.status_servers()\n\n            elif command \u003d\u003d \"routes\":\n                command_handler.get_routes()\n            \n            elif command \u003d\u003d \"stop\":\n               if len(parts) !\u003d 2:\n                   print(\"Usage: stop \u003cport\u003e\")\n                   continue\n               try:\n                    port \u003d int(parts[1])\n                    command_handler.stop_server(port\u003dport)\n               except ValueError:\n                   print(\"Invalid port number.\")\n               except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n            \n            elif command \u003d\u003d \"stop_all\":\n               command_handler.stop_all_servers()\n            \n            elif command \u003d\u003d \"add_route\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: add_route \u003cpath\u003e\")\n                    continue\n                path \u003d parts[1]\n                methods \u003d input(\"Enter HTTP methods (comma-separated, default: GET): \").strip().upper() or \"GET\"\n                methods \u003d [method.strip() for method in methods.split(\",\")]\n                command_handler.add_new_route(path\u003dpath, func\u003d\"lambda: {\\\"message\\\": \\\"Hello from the new route\\\"}\", methods\u003dmethods)\n\n\n            elif command \u003d\u003d \"shutdown\":\n                command_handler.stop_all_servers()\n                print(\"Shutting down all servers.\")\n                sys.exit(0)\n\n            elif command \u003d\u003d \"help\":\n                display_menu()\n\n            elif command \u003d\u003d \"exit\":\n                print(\"Exiting the program.\")\n                sys.exit(0)\n            \n            else:\n                print(\"Unknown command. Type \u0027help\u0027 to see the list of available commands\")\n\n        except Exception as ex:\n            logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    main()\n\nбот\n## \\file /src/endpoints/bots/telegram/telegram_webhooks.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\"\"\"\nТелеграм бот через сервер FastAPI через RPC\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n.. module:: src.endpoints.bots.telegram.telegram_webhooks\n    :platform: Windows, Unix\n    :synopsis: Телеграм бот с сервером FAST API Через RPC\n\n\"\"\"\nfrom pathlib import Path\nimport asyncio\nimport json\nimport sys\nfrom types import SimpleNamespace\nfrom typing import Optional\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext\nfrom xmlrpc.client import ServerProxy\nfrom fastapi import FastAPI, Request, Response\nimport socket\nimport os\n\nimport header\nfrom header import __root__\nfrom src import gs\nfrom src.endpoints.bots.telegram.bot_handlers import BotHandler\nfrom src.utils.printer import pprint as print\nfrom src.logger.logger import logger\n\nfrom src.utils.jjson import j_loads_ns\n\n\nclass TelegramBot:\n    \"\"\"Telegram bot interface class, now a Singleton.\"\"\"\n\n    def __init__(self, token: str, route: str \u003d \u0027telegram_webhook\u0027):\n        \"\"\"\n        Initialize the TelegramBot instance.\n\n        Args:\n            token (str): Telegram bot token.\n            route (str): Webhook route for FastAPI. Defaults to \u0027/telegram_webhook\u0027.\n        \"\"\"\n        self.token: str \u003d token\n        self.port: int \u003d 443\n        self.route: str \u003d route\n        self.config: SimpleNamespace \u003d j_loads_ns(__root__ / \u0027src/endpoints/bots/telegram/telegram.json\u0027)\n        self.application: Application \u003d Application.builder().token(self.token).build()\n        self.bot_handler: BotHandler \u003d BotHandler()\n        self._register_default_handlers()\n\n    def run(self):\n        \"\"\"Run the bot and initialize RPC and webhook.\"\"\"\n        try:\n            # Initialize RPC client\n            rpc_client \u003d ServerProxy(f\"http://{gs.host}:9000\", allow_none\u003dTrue)\n\n            # Start the server via RPC\n            rpc_client.start_server(self.port, gs.host)\n\n            # Register the route via RPC\n            # Динамическое добавление маршрутов\n            \n\n            logger.success(f\u0027Server running at http://{gs.host}:{self.port}/hello\u0027)\n        except Exception as ex:\n            logger.error(f\"Ошибка FastApiServer: {ex}\", exc_info\u003dTrue)\n            sys.exit()\n\n\n\n\n        # Initialize the Telegram bot webhook\n        webhook_url \u003d self.initialize_bot_webhook(self.route)\n        # \n        if webhook_url:\n            self.register_route_via_rpc(rpc_client)\n            try:\n                self.application.run_webhook(listen\u003d\u00270.0.0.0\u0027,\n                                                         webhook_url\u003dwebhook_url, \n                                                         port\u003dself.port)\n                \n                logger.info(f\"Application started: {self.application.bot_data}\")\n                ...\n\n            except Exception as ex:\n                logger.error(f\"Ошибка установки вебхука\")\n                ...\n\n            ...\n        else:\n            self.application.run_polling()\n            ...\n\n\n    def _register_default_handlers(self):\n        \"\"\"Register the default handlers using the BotHandler instance.\"\"\"\n        self.application.add_handler(CommandHandler(\u0027start\u0027, self.bot_handler.start))\n        self.application.add_handler(CommandHandler(\u0027help\u0027, self.bot_handler.help_command))\n        self.application.add_handler(CommandHandler(\u0027sendpdf\u0027, self.bot_handler.send_pdf))\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self._handle_message))\n        self.application.add_handler(MessageHandler(filters.VOICE, self.bot_handler.handle_voice))\n        self.application.add_handler(MessageHandler(filters.Document.ALL, self.bot_handler.handle_document))\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.bot_handler.handle_log))\n\n    async def _handle_message(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle any text message.\"\"\"\n        await self.bot_handler.handle_message(update, context)\n\n    def initialize_bot_webhook(self, route: str):\n        \"\"\"Initialize the bot webhook.\"\"\"\n        route \u003d route if route.startswith(\u0027/\u0027) else f\u0027/{route}\u0027\n        host \u003d gs.host\n\n        if host in (\u0027127.0.0.1\u0027, \u0027localhost\u0027):\n            from pyngrok import ngrok\n            ngrok.set_auth_token(os.getenv(\"NGROK_AUTH_TOKEN\", \"\"))\n            http_tunnel \u003d ngrok.connect(self.port)\n            host \u003d http_tunnel.public_url\n\n        host \u003d host if host.startswith(\u0027http\u0027) else f\u0027https://{host}\u0027\n        webhook_url \u003d f\u0027{host}{route}\u0027\n\n        _dev \u003d True\n        if _dev:\n            import requests\n            response \u003d requests.post(f\u0027{webhook_url}\u0027)\n            print(response.json, text_color\u003d\u0027green\u0027, bg_color\u003d\u0027gray\u0027)\n\n        try:\n            self.application.bot.set_webhook(url\u003dwebhook_url)\n            logger.success(f\u0027https://api.telegram.org/bot{self.token}/getWebhookInfo\u0027) \n            return webhook_url\n        except Exception as ex:\n            logger.error(f\u0027Error setting webhook: \u0027,ex, exc_info\u003dTrue)\n            return False\n\n    def register_route_via_rpc(self, rpc_client: ServerProxy):\n        \"\"\"Register the Telegram webhook route via RPC.\"\"\"\n        try:\n            # Регистрация маршрута через RPC\n            route \u003d self.route if self.route.startswith(\u0027/\u0027) else f\u0027/{self.route}\u0027\n            rpc_client.add_new_route(\n                route,\n                self.bot_handler.handle_message,\n                [\u0027POST\u0027]\n            )\n\n            logger.info(f\"Route {self.route} registered via RPC.\")\n        except Exception as ex:\n            logger.error(f\"Failed to register route via RPC:\",ex, exc_info\u003dTrue)\n            ...\n\n    def stop(self):\n        \"\"\"Stop the bot and delete the webhook.\"\"\"\n        try:\n            self.application.stop()\n            self.application.bot.delete_webhook()\n            logger.info(\"Bot stopped.\")\n        except Exception as ex:\n            logger.error(f\u0027Error deleting webhook:\u0027,ex, exc_info\u003dTrue)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    from dotenv import load_dotenv\n    load_dotenv()\n    bot \u003d TelegramBot(os.getenv(\u0027TELEGRAM_TOKEN\u0027))\n    bot.run()\n\n\nошибка при регистрации маршруте\n\n ERROR - Failed to register route via RPC: \u003cFault 1: \"\u003cclass \u0027TypeError\u0027\u003e:unhashable type: \u0027dict\u0027\"\u003e\nFile: C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\bots\\telegram\\bot.py,\n |\n  -Function: register_route_via_rpc,\n   |\n    --Line: 154\n\u003cFault 1: \"\u003cclass \u0027TypeError\u0027\u003e:unhashable type: \u0027dict\u0027\"\u003e\nTraceback (most recent call last):\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\bots\\telegram\\bot.py\", line 146, in register_route_via_rpc\n    rpc_client.add_new_route(\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 1122, in __call__\n    return self.__send(self.__name, args)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 1461, in __request\n    response \u003d self.__transport.request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 1166, in request\n    return self.single_request(host, handler, request_body, verbose)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 1182, in single_request\n    return self.parse_response(resp)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 1351, in parse_response\n    return u.close()\n           ^^^^^^^^^\n  File \"c:\\python312\\Lib\\xmlrpc\\client.py\", line 668, in close\n    raise Fault(**self._stack[0])\nxmlrpc.client.Fault: \u003cFault 1: \"\u003cclass \u0027TypeError\u0027\u003e:unhashable type: \u0027dict\u0027\"\u003e\n",
      "role": "user",
      "tokenCount": 5615
    }, {
      "text": "Проблема заключается в том, что при вызове `rpc_client.add_new_route` вы пытаетесь передать саму функцию `self.bot_handler.handle_message` как аргумент RPC вызова, а это не сериализуемый тип данных. XML-RPC может передавать только сериализуемые данные, такие как строки, числа, списки, словари и т.д.\n\nВ вашем коде, функция `add_new_route` в `CommandHandler` ожидает строку с названием функции, а не саму функцию.\n\nДля решения этой проблемы, вам нужно изменить способ регистрации маршрута. Вы не можете просто передать функцию через RPC. Вместо этого, вы будете регистрировать маршрут, который будет обрабатываться вашим FastAPI-приложением, и в этот маршрут вы будете передавать запрос от Telegram. А обработка запроса будет внутри  `self.bot_handler.handle_message`.\n\nВот как можно исправить ваш код:\n\n**1. Изменения в `src/fast_api/fast_api.py`:**\n\n    - Удалите `func` из `add_new_route` и  `CommandHandler`.\n    - Добавьте метод `add_route` в класс `FastApiServer`.\n    -  Удалите попытку получить функцию по имени.\n\n```python\nclass FastApiServer:\n    \"\"\"FastAPI сервер с реализацией Singleton.\"\"\"\n\n    _instance \u003d None\n    app: FastAPI \u003d FastAPI()\n    host: str \u003d config.host\n    port: int \u003d 8000\n    router: APIRouter \u003d APIRouter()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance \u003d super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, host: str \u003d \"127.0.0.1\", title: str \u003d \"FastAPI RPC Server\", **kwargs):\n        if hasattr(self, \u0027_initialized\u0027):\n            return\n        self._initialized \u003d True\n        self.add_route(\"/hello\", test_function)\n        self.add_route(\"/post\", test_post, methods\u003d[\"POST\"])\n        #self.add_route(\"/telegram_webhook\", telegram_webhook, methods\u003d[\"POST\"])\n\n        self.app \u003d FastAPI()\n        self.host \u003d host or config.host\n        self.server_tasks \u003d {}\n        self.servers \u003d {}\n        self.app.include_router(self.router)\n\n    def add_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет маршрут к FastAPI приложению.\"\"\"\n        try:\n            self.router.add_api_route(path, func, methods\u003dmethods, **kwargs)\n            logger.info (f\"Маршрут {path} зарегистрировван\")\n        except Exception as ex:\n            logger.error(f\"Ошибка добавления маршрута {path}\")\n\n    # def add_new_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n    #     \"\"\"Добавляет новый маршрут к уже работающему приложению.\"\"\"\n    #     self.add_route(path, func, methods, **kwargs)\n\n    async def _start_server(self, port: int):\n        \"\"\"Запускает uvicorn сервер асинхронно.\"\"\"\n        config \u003d uvicorn.Config(self.app, host\u003dself.host, port\u003dport, log_level\u003d\"debug\")\n        server \u003d uvicorn.Server(config)\n        try:\n            await server.serve()\n            logger.success(f\"Server started on: {self.host}:{port}\")\n        except Exception as e:\n            logger.error(f\"Error running server on port {port}: {e}\")\n        finally:\n            self.servers.pop(port, None)\n\n    def start(self, port: int, as_thread:bool \u003d True):\n        \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            print(f\"Server already running on port {port}\")\n            return\n\n        task \u003d threading.Thread(target\u003dasyncio.run, args\u003d(self._start_server(port),), daemon\u003dTrue)\n        self.server_tasks[port] \u003d task\n        self.servers[port] \u003d task\n        task.start()\n\n    def stop(self, port: int):\n        \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            try:\n                self.servers[port]._thread.join(1)\n                self.servers.pop(port)\n                print(f\"Server on port {port} stopped.\")\n            except Exception as e:\n                logger.error(f\"Error stopping server on port {port}: {e}\")\n        else:\n            print(f\"Server on port {port} is not running or already stopped.\")\n\n    def stop_all(self):\n        \"\"\"Останавливает все запущенные сервера.\"\"\"\n        for port in list(self.servers):\n            self.stop(port)\n\n    def get_servers_status(self):\n        \"\"\"Возвращает статус всех серверов.\"\"\"\n        return {port: \"Running\" if task.is_alive() else \"Stopped\" for port, task in self.servers.items()}\n\n    def get_routes(self):\n      \"\"\"Возвращает список всех роутов.\"\"\"\n      routes \u003d []\n      for route in self.app.routes:\n          if hasattr(route, \"path\"):\n            methods \u003d getattr(route, \"methods\", [\"GET\"])\n            routes.append({\"path\": route.path, \"methods\": list(methods)})\n      return routes\n\n    def get_app(self):\n        \"\"\"Возвращает FastAPI приложение.\"\"\"\n        return self.app\n```\n\n```python\nclass CommandHandler:\n    \"\"\"Обработчик команд для FastAPI сервера через XML-RPC.\"\"\"\n\n    def __init__(self, rpc_port\u003d9000):\n        self.rpc_port \u003d rpc_port\n        self.rpc_server \u003d SimpleXMLRPCServer((\"localhost\", self.rpc_port), allow_none\u003dTrue)\n        self.rpc_server.register_instance(self)\n        threading.Thread(target\u003dself.rpc_server.serve_forever, daemon\u003dTrue).start()\n        print(f\"RPC server started on port: {self.rpc_port}\")\n\n    def start_server(self, port: int, host: str):\n        start_server(port\u003dport, host\u003dhost)\n\n    def stop_server(self, port: int):\n        stop_server(port\u003dport)\n\n    def stop_all_servers(self):\n        stop_all_servers()\n\n    def status_servers(self):\n        status_servers()\n\n    def get_routes(self):\n        get_routes()\n    \n    def add_new_route(self, path: str, methods: List[str] \u003d [\"GET\"]):\n        \"\"\"Добавляет новый роут\"\"\"\n        global _api_server_instance\n        if _api_server_instance:\n            # Получаем ссылку на приложение\n            app \u003d _api_server_instance.get_app()\n            \n            #Добовляем новый роут в FastAPI\n            _api_server_instance.add_route(path\u003dpath, func\u003dtelegram_webhook, methods\u003dmethods)\n            print(f\"Route added: {path}, {methods\u003d}\")\n        else:\n            print(\"Server not initialized. Start server first\")\n            \n    def shutdown(self):\n        self.stop_all_servers()\n        self.rpc_server.shutdown()\n        print(\"RPC server shutdown\")\n        sys.exit(0)\n```\n\n**2. Изменения в `src/endpoints/bots/telegram/telegram_webhooks.py`:**\n\n    - Измените вызов `rpc_client.add_new_route` для передачи `path` и `methods` .\n    - Уберите передачу `self.bot_handler.handle_message`\n\n```python\n   def register_route_via_rpc(self, rpc_client: ServerProxy):\n        \"\"\"Register the Telegram webhook route via RPC.\"\"\"\n        try:\n            # Регистрация маршрута через RPC\n            route \u003d self.route if self.route.startswith(\u0027/\u0027) else f\u0027/{self.route}\u0027\n            rpc_client.add_new_route(\n                route,\n                [\u0027POST\u0027]\n            )\n\n            logger.info(f\"Route {self.route} registered via RPC.\")\n        except Exception as ex:\n            logger.error(f\"Failed to register route via RPC:\",ex, exc_info\u003dTrue)\n            ...\n```\n\n**3. Изменения в `src/fast_api/main.py`:**\n    - Измените вызов  `command_handler.add_new_route` для передачи `path` и `methods`.\n\n```python\n            elif command \u003d\u003d \"add_route\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: add_route \u003cpath\u003e\")\n                    continue\n                path \u003d parts[1]\n                methods \u003d input(\"Enter HTTP methods (comma-separated, default: GET): \").strip().upper() or \"GET\"\n                methods \u003d [method.strip() for method in methods.split(\",\")]\n                command_handler.add_new_route(path\u003dpath, methods\u003dmethods)\n```\n\n**Объяснение изменений:**\n\n1.  **`FastApiServer.add_route`**: Метод для добавления маршрутов с методами, теперь он работает через `self.router.add_api_route`.\n2.  **`CommandHandler.add_new_route`**: Изменена для  добавления роутов через  `_api_server_instance.add_route`,  и передает `path` и `methods` вместо функции.\n3.  **`TelegramBot.register_route_via_rpc`**: Изменен для передачи только пути и методов, и не пытается передать функцию `self.bot_handler.handle_message` через RPC.\n4.  **`main.py`**: Изменено для передачи только пути и методов  при вызове `add_new_route`\n\n**Как это работает:**\n\n1.  **Запуск сервера:** FastAPI-сервер запускается как обычно.\n2.  **Регистрация маршрута через RPC:** Когда бот запускается, он вызывает `rpc_client.add_new_route` с путем `/telegram_webhook` и методом `POST` .\n3.  **Обработка запроса:** Когда Telegram отправляет запрос на webhook (т.е., на `/telegram_webhook`), FastAPI-приложение получит этот запрос и вызовет функцию `telegram_webhook` которую мы зарегитрировали при создании маршрута.\n\nТеперь ошибка `TypeError: unhashable type: \u0027dict\u0027` должна быть исправлена, так как вы больше не пытаетесь передать функцию через XML-RPC.\n\n**Дополнительные замечания:**\n\n*   Убедитесь, что у вас установлены все необходимые библиотеки (FastAPI, uvicorn, python-telegram-bot, python-dotenv, etc.).\n*   Проверьте, что переменные окружения (`TELEGRAM_TOKEN`, `NGROK_AUTH_TOKEN` и др.) настроены правильно.\n\nПосле внесения этих изменений ваш код должен работать корректно. Если у вас возникнут дополнительные вопросы, не стесняйтесь спрашивать!\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 2616
    }, {
      "text": "А я могу задать имя функции, которой не было при старте, но котоарая есть в вызывающем модуле?\n",
      "role": "user",
      "tokenCount": 29
    }, {
      "text": "Да, вы можете задать имя функции, которая не была определена при старте FastAPI сервера, но которая существует в вызывающем модуле (там, где выполняется `main.py`), и использовать это имя для динамического добавления маршрута. Но есть нюансы, связанные с тем, что XML-RPC передаёт только сериализуемые данные.\n\n**Основная проблема и решение:**\n\nПроблема заключается в том, что вы не можете передать *ссылку* на функцию через XML-RPC. XML-RPC передаёт данные в виде XML, и функции не являются сериализуемыми данными.\n\n**Как это можно сделать:**\n\n1.  **Передача имени функции (строкой):** Вместо того, чтобы передавать ссылку на функцию, вы передаете ее имя в виде строки.\n2.  **Поиск функции по имени:** Внутри `CommandHandler` вы ищите функцию в глобальной области видимости (или в другом месте, где она определена), используя `globals().get(func_name)`.\n3.  **Использование функции:** После получения ссылки на функцию, вы передаете ее в `FastApiServer.add_route`.\n\n**Обновлённый код с учётом динамического имени функции:**\n\n**src/fast_api/fast_api.py:**\n\n```python\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\nFastAPI сервер с XML-RPC интерфейсом для удалённого управления\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n.. module:: src.fast_api.fast_api_rpc\n    :platform: Windows, Unix\n    :synopsis: FastAPI сервер с интерфейсом XML-RPC для удалённого управления\n\n\"\"\"\nimport asyncio\nimport functools\nimport json\nimport os\nimport sys\nimport threading\nfrom types import SimpleNamespace\nfrom typing import List, Callable, Dict\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom dotenv import load_dotenv\n\nimport uvicorn\nfrom fastapi import FastAPI, APIRouter\n\nimport header  # \u003c-- Обязательный импорт\nfrom header import __root__\nfrom src import gs\nfrom src.utils.jjson import j_loads, j_loads_ns\n#from src.endpoints.bots.telegram.webhooks import telegram_webhook\nfrom src.utils.printer import pprint as print\nfrom src.logger import logger\n\nimport re\n\nload_dotenv()\n\n\ntry:\n    config: SimpleNamespace \u003d j_loads_ns(__root__ / \u0027src\u0027 / \u0027fast_api\u0027 / \u0027fast_api.json\u0027)\n    config.ports: list \u003d config.ports if isinstance(config.ports, list) else [config.ports]\nexcept Exception as ex:\n    logger.critical(f\"Config file not found!\")\n    sys.exit()\n\n_api_server_instance \u003d None\n\n\nclass FastApiServer:\n    \"\"\"FastAPI сервер с реализацией Singleton.\"\"\"\n\n    _instance \u003d None\n    app: FastAPI \u003d FastAPI()\n    host: str \u003d config.host\n    port: int \u003d 8000\n    router: APIRouter \u003d APIRouter()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance \u003d super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, host: str \u003d \"127.0.0.1\", title: str \u003d \"FastAPI RPC Server\", **kwargs):\n        if hasattr(self, \u0027_initialized\u0027):\n            return\n        self._initialized \u003d True\n        self.add_route(\"/hello\", test_function)\n        self.add_route(\"/post\", test_post, methods\u003d[\"POST\"])\n        #self.add_route(\"/telegram_webhook\", telegram_webhook, methods\u003d[\"POST\"])\n\n        self.app \u003d FastAPI()\n        self.host \u003d host or config.host\n        self.server_tasks \u003d {}\n        self.servers \u003d {}\n        self.app.include_router(self.router)\n\n    def add_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет маршрут к FastAPI приложению.\"\"\"\n        try:\n            self.router.add_api_route(path, func, methods\u003dmethods, **kwargs)\n            logger.info (f\"Маршрут {path} зарегистрировван\")\n        except Exception as ex:\n            logger.error(f\"Ошибка добавления маршрута {path}\")\n\n    # def add_new_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n    #     \"\"\"Добавляет новый маршрут к уже работающему приложению.\"\"\"\n    #     self.add_route(path, func, methods, **kwargs)\n\n    async def _start_server(self, port: int):\n        \"\"\"Запускает uvicorn сервер асинхронно.\"\"\"\n        config \u003d uvicorn.Config(self.app, host\u003dself.host, port\u003dport, log_level\u003d\"debug\")\n        server \u003d uvicorn.Server(config)\n        try:\n            await server.serve()\n            logger.success(f\"Server started on: {self.host}:{port}\")\n        except Exception as e:\n            logger.error(f\"Error running server on port {port}: {e}\")\n        finally:\n            self.servers.pop(port, None)\n\n    def start(self, port: int, as_thread:bool \u003d True):\n        \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            print(f\"Server already running on port {port}\")\n            return\n\n        task \u003d threading.Thread(target\u003dasyncio.run, args\u003d(self._start_server(port),), daemon\u003dTrue)\n        self.server_tasks[port] \u003d task\n        self.servers[port] \u003d task\n        task.start()\n\n    def stop(self, port: int):\n        \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            try:\n                self.servers[port]._thread.join(1)\n                self.servers.pop(port)\n                print(f\"Server on port {port} stopped.\")\n            except Exception as e:\n                logger.error(f\"Error stopping server on port {port}: {e}\")\n        else:\n            print(f\"Server on port {port} is not running or already stopped.\")\n\n    def stop_all(self):\n        \"\"\"Останавливает все запущенные сервера.\"\"\"\n        for port in list(self.servers):\n            self.stop(port)\n\n    def get_servers_status(self):\n        \"\"\"Возвращает статус всех серверов.\"\"\"\n        return {port: \"Running\" if task.is_alive() else \"Stopped\" for port, task in self.servers.items()}\n\n    def get_routes(self):\n      \"\"\"Возвращает список всех роутов.\"\"\"\n      routes \u003d []\n      for route in self.app.routes:\n          if hasattr(route, \"path\"):\n            methods \u003d getattr(route, \"methods\", [\"GET\"])\n            routes.append({\"path\": route.path, \"methods\": list(methods)})\n      return routes\n\n    def get_app(self):\n        \"\"\"Возвращает FastAPI приложение.\"\"\"\n        return self.app\n\n\ndef telegram_webhook():\n    \"\"\"\"\"\"\n    return \u0027Hello, World!\u0027\n\n\ndef test_function():\n    return \"It is working!!!\"\n\n\ndef test_post(data: Dict[str, str]):\n    return {\"result\": \"post ok\", \"data\": data}\n\n\ndef start_server(port: int, host: str):\n    \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance is None:\n        _api_server_instance \u003d FastApiServer(host\u003dhost)\n    _api_server_instance.start(port\u003dport)\n\n\ndef stop_server(port: int):\n    \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop(port\u003dport)\n\n\ndef stop_all_servers():\n    \"\"\"Останавливает все запущенные FastAPI серверы.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop_all()\n\n\ndef status_servers():\n    \"\"\"Показывает статус серверов.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        servers \u003d _api_server_instance.get_servers_status()\n        if servers:\n            print(f\"Server initialized on host {_api_server_instance.host}\")\n            for port, status in servers.items():\n                print(f\"  - Port {port}: {status}\")\n        else:\n            print(\"No servers running\")\n    else:\n        print(\"Server not initialized.\")\n\ndef get_routes():\n    \"\"\"Показывает все роуты.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n      routes \u003d _api_server_instance.get_routes()\n      if routes:\n        print(\"Available routes:\")\n        for route in routes:\n          print(f\"  - Path: {route[\u0027path\u0027]}, Methods: {route[\u0027methods\u0027]}\")\n      else:\n        print(\"No routes defined\")\n    else:\n        print(\"Server not initialized.\")\n\n\ndef add_new_route(path: str, func_name: str, methods: List[str] \u003d [\"GET\"]):\n    \"\"\"Добавляет новый роут к серверу.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        # Получаем ссылку на функцию по имени\n        func \u003d globals().get(func_name)\n        if func:\n            _api_server_instance.add_route(path\u003dpath, func\u003dfunc, methods\u003dmethods)\n            print(f\"Route added: {path}, {methods\u003d}, with function: {func_name}\")\n        else:\n            print(f\"Function {func_name} not found in global scope.\")\n    else:\n        print(\"Server not initialized. Start server first\")\n\n\ndef parse_port_range(range_str):\n    \"\"\"Разбирает строку с диапазоном портов.\"\"\"\n    if not re.match(r\u0027^[\\d-]+$\u0027, range_str):\n        print(f\"Invalid port range: {range_str}\")\n        return []\n    if \u0027-\u0027 in range_str:\n        try:\n            start, end \u003d map(int, range_str.split(\u0027-\u0027))\n            if start \u003e end:\n                raise ValueError(\"Invalid port range\")\n            return list(range(start, end + 1))\n        except ValueError:\n            print(f\"Invalid port range: {range_str}\")\n            return []\n    else:\n        try:\n            return [int(range_str)]\n        except ValueError:\n            print(f\"Invalid port: {range_str}\")\n            return []\n\n\nclass CommandHandler:\n    \"\"\"Обработчик команд для FastAPI сервера через XML-RPC.\"\"\"\n\n    def __init__(self, rpc_port\u003d9000):\n        self.rpc_port \u003d rpc_port\n        self.rpc_server \u003d SimpleXMLRPCServer((\"localhost\", self.rpc_port), allow_none\u003dTrue)\n        self.rpc_server.register_instance(self)\n        threading.Thread(target\u003dself.rpc_server.serve_forever, daemon\u003dTrue).start()\n        print(f\"RPC server started on port: {self.rpc_port}\")\n\n    def start_server(self, port: int, host: str):\n        start_server(port\u003dport, host\u003dhost)\n\n    def stop_server(self, port: int):\n        stop_server(port\u003dport)\n\n    def stop_all_servers(self):\n        stop_all_servers()\n\n    def status_servers(self):\n        status_servers()\n\n    def get_routes(self):\n        get_routes()\n\n    def add_new_route(self, path: str, func: str, methods: List[str] \u003d [\"GET\"]):\n        # Передаем ссылку на функцию вместо eval.\n        add_new_route(path\u003dpath, func_name\u003dfunc, methods\u003dmethods)\n\n    def shutdown(self):\n        self.stop_all_servers()\n        self.rpc_server.shutdown()\n        print(\"RPC server shutdown\")\n        sys.exit(0)\n```\n\n**src/fast_api/main.py:**\n\n```python\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\n.. module:: src.fast_api.main \n    :platform: Windows, Unix\n    :synopsis: Управаление параметрами Fast Api сервера\n\n\"\"\"\n\nimport sys\nimport header  # \u003c-- Обязательный импорт\nfrom src.fast_api.fast_api import CommandHandler, logger\nfrom fastapi import Request, Response\n\n\ndef display_menu():\n    \"\"\"Выводит меню с доступными командами.\"\"\"\n    print(\"\\nAvailable commands:\")\n    print(\"  start \u003cport\u003e        - Start server on the specified port\")\n    print(\"  status              - Show all served ports status\")\n    print(\"  routes              - Show all registered routes\")\n    print(\"  stop \u003cport\u003e         - Stop server on the specified port\")\n    print(\"  stop_all            - Stop all servers\")\n    print(\"  add_route \u003cpath\u003e    - Add a new route to the server\")\n    print(\"  shutdown            - Stop all servers and exit\")\n    print(\"  help                - Show this help menu\")\n    print(\"  exit                - Exit the program\")\n\ndef new_route_handler(request: Request):\n    return {\"message\": \"Hello from dynamically added route\"}\n\n\ndef main():\n    \"\"\"Основная функция управления сервером.\"\"\"\n    command_handler \u003d CommandHandler()\n    while True:\n        display_menu()\n        try:\n            command_line \u003d input(\"Enter command: \").strip().lower()\n            if not command_line:\n                continue\n\n            parts \u003d command_line.split()\n            command \u003d parts[0]\n\n            if command \u003d\u003d \"start\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: start \u003cport\u003e\")\n                    continue\n                try:\n                    port \u003d int(parts[1])\n                    host \u003d input(\"Enter host address (default: 127.0.0.1): \").strip() or \"127.0.0.1\"\n                    command_handler.start_server(port\u003dport, host\u003dhost)\n                except ValueError:\n                    print(\"Invalid port number.\")\n                except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n            elif command \u003d\u003d \"status\":\n                command_handler.status_servers()\n\n            elif command \u003d\u003d \"routes\":\n                command_handler.get_routes()\n            \n            elif command \u003d\u003d \"stop\":\n               if len(parts) !\u003d 2:\n                   print(\"Usage: stop \u003cport\u003e\")\n                   continue\n               try:\n                    port \u003d int(parts[1])\n                    command_handler.stop_server(port\u003dport)\n               except ValueError:\n                   print(\"Invalid port number.\")\n               except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n            \n            elif command \u003d\u003d \"stop_all\":\n               command_handler.stop_all_servers()\n            \n            elif command \u003d\u003d \"add_route\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: add_route \u003cpath\u003e\")\n                    continue\n                path \u003d parts[1]\n                methods \u003d input(\"Enter HTTP methods (comma-separated, default: GET): \").strip().upper() or \"GET\"\n                methods \u003d [method.strip() for method in methods.split(\",\")]\n                \n                # Вызов для добавления нового роута\n                command_handler.add_new_route(path\u003dpath, func\u003d\"new_route_handler\", methods\u003dmethods)\n\n\n            elif command \u003d\u003d \"shutdown\":\n                command_handler.stop_all_servers()\n                print(\"Shutting down all servers.\")\n                sys.exit(0)\n\n            elif command \u003d\u003d \"help\":\n                display_menu()\n\n            elif command \u003d\u003d \"exit\":\n                print(\"Exiting the program.\")\n                sys.exit(0)\n            \n            else:\n                print(\"Unknown command. Type \u0027help\u0027 to see the list of available commands\")\n\n        except Exception as ex:\n            logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    main()\n```\n\n**Изменения:**\n\n1.  **`CommandHandler.add_new_route`:**\n    *   Принимает имя функции (`func: str`) вместо самой функции.\n    *   Использует `globals().get(func)` для поиска функции.\n    *   Если функция найдена, передает ее в `FastApiServer.add_route`.\n\n2.  **`main.py`:**\n    *   Добавлена функция `new_route_handler` для теста.\n    *   При добавлении нового маршрута мы передаем имя `new_route_handler` как аргумент.\n**Пояснения**\n\n*  Мы добавили функцию  `new_route_handler`  в  `main.py`. Эта функция и будет вызываться при запросе на созданный роут.\n*  В `CommandHandler.add_new_route` мы передаем имя функции как строку `func`.\n*  Далее в  `add_new_route`  класса  `fastapi_server` мы ищем функцию по имени в глобальном пространстве и передаем ссылку на нее в `add_route`.\n\n**Как это работает:**\n\n1.  **`main.py`:** Вы определяете функцию `new_route_handler`.\n2.  **`CommandHandler.add_new_route`:** Вызывается с именем `\"new_route_handler\"`.\n3.  **Поиск функции:** В `add_new_route`  класса  `fastapi_server`  вы  ищете функцию  `new_route_handler`  в глобальном пространстве (`globals()`).\n4.  **Добавление маршрута:** Если функция найдена, `FastApiServer.add_route` добавляет маршрут с этой функцией.\n\n**Важные замечания:**\n\n*   **Ограничения:** Функция должна быть определена в глобальном пространстве вызывающего модуля или в другом месте, доступном через `globals().get()`.\n*   **Безопасность:** Использование `globals().get()` может быть опасным, так как позволяет удаленно вызывать любую функцию.\n*   **Альтернативы:** Для более сложной логики можно использовать паттерн \"фабрика функций\" или другие способы динамического создания обработчиков.\n\nТеперь вы можете задать имя функции (которая определена в `main.py`), и она будет использоваться как обработчик для вновь добавленного маршрута.\n",
      "role": "model",
      "finishReason": "STOP"
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}