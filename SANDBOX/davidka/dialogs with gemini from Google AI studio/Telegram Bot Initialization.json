{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.0-flash-exp",
    "candidateCount": 1,
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false
  },
  "citations": [{
    "uri": "https://github.com/alexmnotfound/telelgram-groundx"
  }],
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "from pathlib import Path\nimport tempfile\nimport asyncio\nimport logging\nimport json\nimport requests  # For downloading files\nfrom typing import Dict, Optional\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext\nfrom aiohttp import web\n# from aiogram.webhook.aiohttp_server import setup_application # Удалил эту строку\n\nimport header\nfrom src import gs\nfrom src.endpoints.bots.telegram.bot_handlers import BotHandler\nfrom src.utils.jjson import j_loads, j_loads_ns, j_dumps\nfrom src.logger.logger import logger\nfrom src.utils.convertors.tts import speech_recognizer, text2speech\nfrom src.utils.file import read_text_file\nfrom src.utils.get_free_port import get_free_port\nimport os\nfrom dotenv import load_dotenv\nload_dotenv()\n\nclass TelegramBot:\n    \"\"\"Telegram bot interface class.\"\"\"\n\n    application: Application\n    host: str\n    port: int\n    webhook_url: str\n    \n\n    def __init__(self, token: str, bot_handler:Optional[BotHandler] \u003d None):\n        \"\"\"Initialize the Telegram bot.\n\n        :param token: Telegram bot token, e.g., `gs.credentials.telegram.bot.kazarinov`.\n        :type token: str\n        :param config_path: Path to the JSON configuration file.\n        :type config_path: Path\n        \"\"\"\n        config_path \u003d Path(__file__).parent.parent / \u0027config.json\u0027\n\n        self._load_config(config_path)\n        self.application \u003d Application.builder().token(token).build()\n        self.bot_handler \u003d bot_handler if bot_handler else  BotHandler()\n        self.register_handlers()\n        self.webhook_url \u003d os.getenv(\u0027WEBHOOK_URL\u0027)\n\n\n    def _load_config(self, config_path:str | Path) -\u003e None:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        try:\n            with open(config_path, \u0027r\u0027) as f:\n                config \u003d json.load(f)\n                bot_config \u003d config.get(\u0027telegram_bot\u0027, {})\n                if bot_config:\n                    self.host \u003d bot_config.get(\u0027host\u0027, \u0027127.0.0.1\u0027)\n                    port_range \u003d bot_config.get(\u0027port_range\u0027, [\u00279000\u0027,\u00279100\u0027])\n                    self.port \u003d get_free_port(self.host, port_range)\n                else:\n                    logger.error(f\u0027No config found for {self.__class__.__name__}\u0027)\n                    self.host \u003d \u0027127.0.0.1\u0027\n                    self.port \u003d  get_free_port(self.host,[\u00279000\u0027,\u00279100\u0027])\n\n        except FileNotFoundError as ex:\n            logger.error(\u0027Error: Configuration file not found: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n            ...\n        except json.JSONDecodeError as ex:\n             logger.error(\u0027Error: Invalid JSON format in configuration file: \u0027, ex)\n             self.host \u003d \u0027127.0.0.1\u0027\n             self.port \u003d 8080\n             ...\n\n    def register_handlers(self):\n        \"\"\"Register bot commands and message handlers.\"\"\"\n        self.application.add_handler(CommandHandler(\u0027start\u0027, self.start))\n        self.application.add_handler(CommandHandler(\u0027help\u0027, self.help_command))\n        self.application.add_handler(CommandHandler(\u0027sendpdf\u0027, self.send_pdf))  # обработчик для отправки PDF\n        # Use bot_handler.handle_message for text messages\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_message))\n        self.application.add_handler(MessageHandler(filters.VOICE, self.handle_voice))\n        self.application.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_log))\n\n    async def start(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /start command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\u0027Hello! I am your simple bot. Type /help to see available commands.\u0027)\n\n    async def help_command(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /help command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Available commands:\\n\u0027\n            \u0027/start - Start the bot\\n\u0027\n            \u0027/help - Show this help message\\n\u0027\n            \u0027/sendpdf - Send a PDF file\u0027\n        )\n\n    async def send_pdf(self, update: Update, context: CallbackContext, pdf_file: str | Path) -\u003e None:\n        \"\"\"Handle the /sendpdf command to generate and send a PDF file.\"\"\"\n        try:\n            # Отправка PDF-файла пользователю\n            self.update \u003d update\n            self.context \u003d context\n            with open(pdf_file, \u0027rb\u0027) as pdf_file_obj:\n                await self.update.message.reply_document(document\u003dpdf_file_obj)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при отправке PDF-файла: \u0027, ex)\n            await self.update.message.reply_text(\u0027Произошла ошибка при отправке PDF-файла. Попробуй ещё раз.\u0027)\n\n    async def handle_voice(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle voice messages and transcribe the audio.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        try:\n            # Получаем файл голосового сообщения\n            voice \u003d self.update.message.voice\n            file \u003d await self.context.bot.get_file(voice.file_id)\n            file_path \u003d gs.path.temp / f\u0027{voice.file_id}.ogg\u0027\n            \n            # Сохраняем файл на локальной системе\n            await file.download_to_drive(file_path)\n\n            # Здесь можно добавить обработку файла (распознавание речи), например, с помощью Google Speech-to-Text\n            transcribed_text \u003d await self.transcribe_voice(file_path)\n            \n            # Отправляем распознанный текст пользователю\n            await self.update.message.reply_text(f\u0027Распознанный текст: {transcribed_text}\u0027)\n        \n        except Exception as ex:\n            logger.error(\u0027Ошибка при обработке голосового сообщения: \u0027, ex)\n            await self.update.message.reply_text(\u0027Произошла ошибка при обработке голосового сообщения. Попробуй ещё раз.\u0027)\n\n    async def transcribe_voice(self, file_path: Path) -\u003e str:\n        \"\"\"Transcribe voice message using a speech recognition service.\"\"\"\n        # Пример заглушки, замените это на реальную логику распознавания речи\n        return \u0027Распознавание голоса ещё не реализовано.\u0027\n\n    async def handle_document(self, update: Update, context: CallbackContext) -\u003e str:\n        \"\"\"Handle received documents.\n\n        :param update: Update object containing the message data.\n        :type update: Update\n        :param context: Context of the current conversation.\n        :type context: CallbackContext\n        :return: Content of the text document.\n        :rtype: str\n        \"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        file \u003d await self.update.message.document.get_file()\n        tmp_file_path \u003d await file.download_to_drive()  # Save file locally\n        return read_text_file(tmp_file_path)\n\n    async def handle_message(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle any text message.\"\"\"\n        await self.bot_handler.handle_message(update, context)\n\n    async def handle_log(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle log messages.\"\"\"\n        log_message \u003d update.message.text\n        logger.info(f\"Received log message: {log_message}\")\n        await update.message.reply_text(\"Log received and processed.\")\n    \n    \nasync def update_webhook_handler(request: web.Request) -\u003e web.Response:\n        \"\"\"Handles incoming webhook updates.\"\"\"\n        app \u003d request.app\n        bot \u003d app[\u0027bot\u0027]\n        \n        try:\n            data \u003d await request.json()\n            # logger.debug(\u0027Webhook data: %s\u0027, data) # Можно залогировать для отладки\n            async with bot.application:\n                await bot.application.process_update(Update.de_json(data, bot.application.bot))\n            return web.Response()\n        except Exception as e:\n            logger.error(\u0027Error processing webhook: %s\u0027, e)\n            return web.Response(status\u003d500, text\u003df\u0027Error processing webhook {e}\u0027)\n\nasync def on_startup(app: web.Application):\n    \"\"\"Perform actions on application startup.\"\"\"\n    bot \u003d app[\u0027bot\u0027]\n    await bot.application.bot.set_webhook(url\u003dbot.webhook_url)\n    logger.info(f\"Bot started with webhook: {bot.webhook_url}\")\n\nasync def on_shutdown(app: web.Application):\n    \"\"\"Perform actions on application shutdown.\"\"\"\n    bot \u003d app[\u0027bot\u0027]\n    await bot.application.bot.delete_webhook()\n    logger.info(\"Bot stopped.\")\n\n\ndef setup_application(app: web.Application, application: Application):\n     \"\"\"Setup telegram application to respond via webhook.\"\"\"\n\n     async def update_webhook_handler(request):\n        \"\"\"Handles incoming webhook updates.\"\"\"\n        \n        data \u003d await request.json()\n        # logger.debug(\u0027Webhook data: %s\u0027, data)\n\n        async with application:\n            await application.process_update(Update.de_json(data, application.bot))\n        return web.Response()\n\n     app[\u0027webhook_handler\u0027] \u003d update_webhook_handler\n\ndef create_app(bot: TelegramBot) -\u003e web.Application:\n    \"\"\"Create and configure the aiohttp application.\"\"\"\n    app \u003d web.Application()\n    app[\u0027bot\u0027] \u003d bot\n\n    # Register webhook handler\n    app.router.add_post(f\u0027/webhook\u0027, update_webhook_handler)\n\n    # Register startup and shutdown handlers\n    app.on_startup.append(on_startup)\n    app.on_shutdown.append(on_shutdown)\n\n    # Setup application with the bot\n    setup_application(app, bot.application)\n\n\n    return app\n?\n\nМожно запускать код через fast_api",
      "role": "user",
      "tokenCount": 2497
    }, {
      "text": "Да, вы абсолютно правы. Код можно интегрировать с FastAPI для более удобного управления и запуска API. Вот как можно это сделать, переработав ваш код для работы с FastAPI:\n\n**Основные изменения:**\n\n1.  **FastAPI:** Используем FastAPI для создания веб-приложения.\n2.  **Удаление aiohttp Server:** Мы удаляем ручное создание aiohttp сервера, так как FastAPI его уже включает.\n3.  **Webhook Handling:** Webhook обрабатывается через эндпоинт FastAPI.\n4.  **Startup/Shutdown:** Перемещаем логику `on_startup` и `on_shutdown` в FastAPI hooks.\n5.  **Запуск:**  Используем `uvicorn` для запуска FastAPI.\n\n**Обновленный код:**\n\n```python\nfrom pathlib import Path\nimport tempfile\nimport asyncio\nimport logging\nimport json\nimport requests  # For downloading files\nfrom typing import Dict, Optional\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import Response\n# from aiogram.webhook.aiohttp_server import setup_application # Удалил эту строку\nfrom uvicorn import run\nimport header\nfrom src import gs\nfrom src.endpoints.bots.telegram.bot_handlers import BotHandler\nfrom src.utils.jjson import j_loads, j_loads_ns, j_dumps\nfrom src.logger.logger import logger\nfrom src.utils.convertors.tts import speech_recognizer, text2speech\nfrom src.utils.file import read_text_file\nfrom src.utils.get_free_port import get_free_port\nimport os\nfrom dotenv import load_dotenv\nload_dotenv()\n\nclass TelegramBot:\n    \"\"\"Telegram bot interface class.\"\"\"\n\n    application: Application\n    host: str\n    port: int\n    webhook_url: str\n    \n\n    def __init__(self, token: str, bot_handler:Optional[BotHandler] \u003d None):\n        \"\"\"Initialize the Telegram bot.\n\n        :param token: Telegram bot token, e.g., `gs.credentials.telegram.bot.kazarinov`.\n        :type token: str\n        :param config_path: Path to the JSON configuration file.\n        :type config_path: Path\n        \"\"\"\n        config_path \u003d Path(__file__).parent.parent / \u0027config.json\u0027\n\n        self._load_config(config_path)\n        self.application \u003d Application.builder().token(token).build()\n        self.bot_handler \u003d bot_handler if bot_handler else  BotHandler()\n        self.register_handlers()\n        self.webhook_url \u003d os.getenv(\u0027WEBHOOK_URL\u0027)\n\n\n    def _load_config(self, config_path:str | Path) -\u003e None:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        try:\n            with open(config_path, \u0027r\u0027) as f:\n                config \u003d json.load(f)\n                bot_config \u003d config.get(\u0027telegram_bot\u0027, {})\n                if bot_config:\n                    self.host \u003d bot_config.get(\u0027host\u0027, \u0027127.0.0.1\u0027)\n                    port_range \u003d bot_config.get(\u0027port_range\u0027, [\u00279000\u0027,\u00279100\u0027])\n                    self.port \u003d get_free_port(self.host, port_range)\n                else:\n                    logger.error(f\u0027No config found for {self.__class__.__name__}\u0027)\n                    self.host \u003d \u0027127.0.0.1\u0027\n                    self.port \u003d  get_free_port(self.host,[\u00279000\u0027,\u00279100\u0027])\n\n        except FileNotFoundError as ex:\n            logger.error(\u0027Error: Configuration file not found: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n            ...\n        except json.JSONDecodeError as ex:\n             logger.error(\u0027Error: Invalid JSON format in configuration file: \u0027, ex)\n             self.host \u003d \u0027127.0.0.1\u0027\n             self.port \u003d 8080\n             ...\n\n    def register_handlers(self):\n        \"\"\"Register bot commands and message handlers.\"\"\"\n        self.application.add_handler(CommandHandler(\u0027start\u0027, self.start))\n        self.application.add_handler(CommandHandler(\u0027help\u0027, self.help_command))\n        self.application.add_handler(CommandHandler(\u0027sendpdf\u0027, self.send_pdf))  # обработчик для отправки PDF\n        # Use bot_handler.handle_message for text messages\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_message))\n        self.application.add_handler(MessageHandler(filters.VOICE, self.handle_voice))\n        self.application.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))\n        self.application.add_handler(MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_log))\n\n    async def start(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /start command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\u0027Hello! I am your simple bot. Type /help to see available commands.\u0027)\n\n    async def help_command(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /help command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Available commands:\\n\u0027\n            \u0027/start - Start the bot\\n\u0027\n            \u0027/help - Show this help message\\n\u0027\n            \u0027/sendpdf - Send a PDF file\u0027\n        )\n\n    async def send_pdf(self, update: Update, context: CallbackContext, pdf_file: str | Path) -\u003e None:\n        \"\"\"Handle the /sendpdf command to generate and send a PDF file.\"\"\"\n        try:\n            # Отправка PDF-файла пользователю\n            self.update \u003d update\n            self.context \u003d context\n            with open(pdf_file, \u0027rb\u0027) as pdf_file_obj:\n                await self.update.message.reply_document(document\u003dpdf_file_obj)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при отправке PDF-файла: \u0027, ex)\n            await self.update.message.reply_text(\u0027Произошла ошибка при отправке PDF-файла. Попробуй ещё раз.\u0027)\n\n    async def handle_voice(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle voice messages and transcribe the audio.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        try:\n            # Получаем файл голосового сообщения\n            voice \u003d self.update.message.voice\n            file \u003d await self.context.bot.get_file(voice.file_id)\n            file_path \u003d gs.path.temp / f\u0027{voice.file_id}.ogg\u0027\n            \n            # Сохраняем файл на локальной системе\n            await file.download_to_drive(file_path)\n\n            # Здесь можно добавить обработку файла (распознавание речи), например, с помощью Google Speech-to-Text\n            transcribed_text \u003d await self.transcribe_voice(file_path)\n            \n            # Отправляем распознанный текст пользователю\n            await self.update.message.reply_text(f\u0027Распознанный текст: {transcribed_text}\u0027)\n        \n        except Exception as ex:\n            logger.error(\u0027Ошибка при обработке голосового сообщения: \u0027, ex)\n            await self.update.message.reply_text(\u0027Произошла ошибка при обработке голосового сообщения. Попробуй ещё раз.\u0027)\n\n    async def transcribe_voice(self, file_path: Path) -\u003e str:\n        \"\"\"Transcribe voice message using a speech recognition service.\"\"\"\n        # Пример заглушки, замените это на реальную логику распознавания речи\n        return \u0027Распознавание голоса ещё не реализовано.\u0027\n\n    async def handle_document(self, update: Update, context: CallbackContext) -\u003e str:\n        \"\"\"Handle received documents.\n\n        :param update: Update object containing the message data.\n        :type update: Update\n        :param context: Context of the current conversation.\n        :type context: CallbackContext\n        :return: Content of the text document.\n        :rtype: str\n        \"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        file \u003d await self.update.message.document.get_file()\n        tmp_file_path \u003d await file.download_to_drive()  # Save file locally\n        return read_text_file(tmp_file_path)\n\n    async def handle_message(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle any text message.\"\"\"\n        await self.bot_handler.handle_message(update, context)\n\n    async def handle_log(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle log messages.\"\"\"\n        log_message \u003d update.message.text\n        logger.info(f\"Received log message: {log_message}\")\n        await update.message.reply_text(\"Log received and processed.\")\n\n# FastAPI App Creation\napp \u003d FastAPI()\nbot_instance: TelegramBot \u003d None\n\n# Define Bot instance and start webhook\n@app.on_event(\"startup\")\nasync def startup_event():\n    global bot_instance\n    token \u003d os.getenv(\u0027TELEGRAM_BOT_TOKEN\u0027)\n    bot_instance \u003d TelegramBot(token)\n    await bot_instance.application.bot.set_webhook(url\u003dbot_instance.webhook_url)\n    logger.info(f\"Bot started with webhook: {bot_instance.webhook_url}\")\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    if bot_instance:\n       await bot_instance.application.bot.delete_webhook()\n       logger.info(\"Bot stopped.\")\n\n# Handle Webhook\n@app.post(\"/webhook\")\nasync def telegram_webhook(request: Request):\n    if not bot_instance:\n        return Response(status_code\u003d500, content\u003d\"Bot not initialized.\")\n\n    try:\n        data \u003d await request.json()\n        async with bot_instance.application:\n            await bot_instance.application.process_update(Update.de_json(data, bot_instance.application.bot))\n        return Response(status_code\u003d200)\n    except Exception as e:\n        logger.error(f\u0027Error processing webhook: {e}\u0027)\n        return Response(status_code\u003d500, content\u003df\u0027Error processing webhook {e}\u0027)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    \n    run(app, host\u003dos.getenv(\u0027HOST_URL\u0027, \u0027127.0.0.1\u0027), port\u003dint(os.getenv(\u0027PORT\u0027, 8000)))\n\n```\n\n**Как запустить:**\n\n1.  **Сохраните код:** Сохраните код в файл, например `bot_app.py`.\n2.  **Установите зависимости:**\n    ```bash\n    pip install fastapi uvicorn python-telegram-bot python-dotenv requests\n    ```\n3.  **Установите переменные окружения:**\n    Создайте файл `.env` и добавьте туда:\n    ```env\n     TELEGRAM_BOT_TOKEN\u003d\u003cyour_telegram_bot_token\u003e\n     WEBHOOK_URL\u003d\u003cyour_webhook_url\u003e\n     HOST_URL\u003d127.0.0.1 # или 0.0.0.0\n     PORT\u003d8000\n    ```\n    Замените `\u003cyour_telegram_bot_token\u003e` и `\u003cyour_webhook_url\u003e` на ваши значения.\n4.  **Запустите:**\n    ```bash\n    python bot_app.py\n    ```\n\n**Основные изменения объяснены:**\n\n*   **`from fastapi import FastAPI, Request, Response`**: Импортируем необходимые классы из FastAPI.\n*   **`app \u003d FastAPI()`**: Создаем экземпляр FastAPI.\n*   **`startup_event()`**: Запускается при старте FastAPI. Инициализирует бота и устанавливает webhook.\n*   **`shutdown_event()`**: Выполняется при выключении FastAPI. Удаляет webhook.\n*   **`telegram_webhook(request: Request)`**: Эндпоинт для обработки входящих webhook запросов.\n\n**Преимущества использования FastAPI:**\n\n1.  **Удобство:** FastAPI упрощает создание веб-приложений и автоматически генерирует документацию.\n2.  **Производительность:** FastAPI построен на основе Starlette и pydantic, что делает его очень производительным.\n3.  **Асинхронность:** FastAPI поддерживает асинхронные функции, что подходит для Telegram Bot, который использует асинхронность.\n4.  **Безопасность:** Интегрированная валидация и другие функции безопасности.\n\nЭтот код должен работать с FastAPI и обрабатывать webhook-и Telegram. Убедитесь, что ваш бот токен и webhook url установлены правильно и соответствуют вашим настройкам.\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 3041
    }, {
      "text": "А если сервер уже запущен?\n",
      "role": "user",
      "tokenCount": 10
    }, {
      "text": "Понял. Если у вас уже есть работающий сервер (например, веб-сервер, на котором хостится ваше приложение), и вы хотите интегрировать Telegram бота, то вам нужно:\n\n1.  **Использовать существующий ASGI сервер:**\n    Вместо запуска `uvicorn` отдельно, вам нужно будет интегрировать ваше FastAPI приложение в существующий ASGI сервер вашего приложения (например, если это веб-приложение Django, то там уже есть ASGI сервер, или если это `gunicorn + uvicorn worker`, то вы используете существующую инфраструктуру).\n2.  **Перенаправить вебхуки:** Ваш Telegram webhook должен быть направлен на эндпоинт вашего сервера.\n3.  **Инициализация бота:**\n    Убедитесь, что бот инициализируется один раз при старте вашего приложения, а не каждый раз при запросе webhook.\n\nВот пример, как можно это сделать с FastAPI, подразумевая, что у вас уже есть какой-то ASGI сервер, в котором вы хотите запустить FastAPI:\n\n```python\nfrom pathlib import Path\nimport tempfile\nimport asyncio\nimport logging\nimport json\nimport requests  # For downloading files\nfrom typing import Dict, Optional\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import Response\n\nimport header\nfrom src import gs\nfrom src.endpoints.bots.telegram.bot_handlers import BotHandler\nfrom src.utils.jjson import j_loads, j_loads_ns, j_dumps\nfrom src.logger.logger import logger\nfrom src.utils.convertors.tts import speech_recognizer, text2speech\nfrom src.utils.file import read_text_file\nfrom src.utils.get_free_port import get_free_port\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass TelegramBot:\n    \"\"\"Telegram bot interface class.\"\"\"\n\n    application: Application\n    host: str\n    port: int\n    webhook_url: str\n\n    def __init__(self, token: str, bot_handler: Optional[BotHandler] \u003d None):\n        \"\"\"Initialize the Telegram bot.\"\"\"\n        config_path \u003d Path(__file__).parent.parent / \u0027config.json\u0027\n\n        self._load_config(config_path)\n        self.application \u003d Application.builder().token(token).build()\n        self.bot_handler \u003d bot_handler if bot_handler else BotHandler()\n        self.register_handlers()\n        self.webhook_url \u003d os.getenv(\u0027WEBHOOK_URL\u0027)\n\n    def _load_config(self, config_path: str | Path) -\u003e None:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        try:\n            with open(config_path, \u0027r\u0027) as f:\n                config \u003d json.load(f)\n                bot_config \u003d config.get(\u0027telegram_bot\u0027, {})\n                if bot_config:\n                    self.host \u003d bot_config.get(\u0027host\u0027, \u0027127.0.0.1\u0027)\n                    port_range \u003d bot_config.get(\u0027port_range\u0027, [\u00279000\u0027, \u00279100\u0027])\n                    self.port \u003d get_free_port(self.host, port_range)\n                else:\n                    logger.error(f\u0027No config found for {self.__class__.__name__}\u0027)\n                    self.host \u003d \u0027127.0.0.1\u0027\n                    self.port \u003d get_free_port(self.host, [\u00279000\u0027, \u00279100\u0027])\n\n        except FileNotFoundError as ex:\n            logger.error(\u0027Error: Configuration file not found: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n        except json.JSONDecodeError as ex:\n            logger.error(\u0027Error: Invalid JSON format in configuration file: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n\n    def register_handlers(self):\n        \"\"\"Register bot commands and message handlers.\"\"\"\n        self.application.add_handler(CommandHandler(\u0027start\u0027, self.start))\n        self.application.add_handler(CommandHandler(\u0027help\u0027, self.help_command))\n        self.application.add_handler(CommandHandler(\u0027sendpdf\u0027, self.send_pdf))\n        self.application.add_handler(\n            MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_message)\n        )\n        self.application.add_handler(MessageHandler(filters.VOICE, self.handle_voice))\n        self.application.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))\n        self.application.add_handler(\n            MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_log)\n        )\n\n    async def start(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /start command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Hello! I am your simple bot. Type /help to see available commands.\u0027\n        )\n\n    async def help_command(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /help command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Available commands:\\n\u0027\n            \u0027/start - Start the bot\\n\u0027\n            \u0027/help - Show this help message\\n\u0027\n            \u0027/sendpdf - Send a PDF file\u0027\n        )\n\n    async def send_pdf(\n        self, update: Update, context: CallbackContext, pdf_file: str | Path\n    ) -\u003e None:\n        \"\"\"Handle the /sendpdf command to generate and send a PDF file.\"\"\"\n        try:\n            self.update \u003d update\n            self.context \u003d context\n            with open(pdf_file, \u0027rb\u0027) as pdf_file_obj:\n                await self.update.message.reply_document(document\u003dpdf_file_obj)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при отправке PDF-файла: \u0027, ex)\n            await self.update.message.reply_text(\n                \u0027Произошла ошибка при отправке PDF-файла. Попробуй ещё раз.\u0027\n            )\n\n    async def handle_voice(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle voice messages and transcribe the audio.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        try:\n            voice \u003d self.update.message.voice\n            file \u003d await self.context.bot.get_file(voice.file_id)\n            file_path \u003d gs.path.temp / f\u0027{voice.file_id}.ogg\u0027\n\n            await file.download_to_drive(file_path)\n\n            transcribed_text \u003d await self.transcribe_voice(file_path)\n\n            await self.update.message.reply_text(f\u0027Распознанный текст: {transcribed_text}\u0027)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при обработке голосового сообщения: \u0027, ex)\n            await self.update.message.reply_text(\n                \u0027Произошла ошибка при обработке голосового сообщения. Попробуй ещё раз.\u0027\n            )\n\n    async def transcribe_voice(self, file_path: Path) -\u003e str:\n        \"\"\"Transcribe voice message using a speech recognition service.\"\"\"\n        return \u0027Распознавание голоса ещё не реализовано.\u0027\n\n    async def handle_document(self, update: Update, context: CallbackContext) -\u003e str:\n        \"\"\"Handle received documents.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        file \u003d await self.update.message.document.get_file()\n        tmp_file_path \u003d await file.download_to_drive()\n        return read_text_file(tmp_file_path)\n\n    async def handle_message(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle any text message.\"\"\"\n        await self.bot_handler.handle_message(update, context)\n\n    async def handle_log(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle log messages.\"\"\"\n        log_message \u003d update.message.text\n        logger.info(f\"Received log message: {log_message}\")\n        await update.message.reply_text(\"Log received and processed.\")\n\n\n# FastAPI App Creation\napp \u003d FastAPI()\nbot_instance: Optional[TelegramBot] \u003d None\n\n# Function to initialize the bot (should be called once at application start)\nasync def initialize_bot():\n    global bot_instance\n    if not bot_instance:\n        token \u003d os.getenv(\u0027TELEGRAM_BOT_TOKEN\u0027)\n        bot_instance \u003d TelegramBot(token)\n        try:\n            await bot_instance.application.bot.set_webhook(\n                url\u003dbot_instance.webhook_url\n            )\n            logger.info(f\"Bot started with webhook: {bot_instance.webhook_url}\")\n        except Exception as ex:\n            logger.error(f\u0027Error setting webhook: {ex}\u0027)\n\n\n@app.on_event(\"startup\")\nasync def startup_event():\n     await initialize_bot()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    if bot_instance:\n       try:\n          await bot_instance.application.bot.delete_webhook()\n          logger.info(\"Bot stopped.\")\n       except Exception as ex:\n           logger.error(f\u0027Error deleting webhook: {ex}\u0027)\n\n\n# Handle Webhook\n@app.post(\"/webhook\")\nasync def telegram_webhook(request: Request):\n    if not bot_instance:\n        logger.error(\"Bot not initialized.\")\n        return Response(status_code\u003d500, content\u003d\"Bot not initialized.\")\n\n    try:\n        data \u003d await request.json()\n        async with bot_instance.application:\n            await bot_instance.application.process_update(\n                Update.de_json(data, bot_instance.application.bot)\n            )\n        return Response(status_code\u003d200)\n    except Exception as e:\n        logger.error(f\u0027Error processing webhook: {e}\u0027)\n        return Response(status_code\u003d500, content\u003df\u0027Error processing webhook: {e}\u0027)\n\n# This is an example function to simulate the existing server\n# In your real application, you would integrate the FastAPI app into your existing application\u0027s ASGI setup\ndef run_my_app():\n    # In real life, you will not need this function\n    # You will need to integrate the app into your existing ASGI server\n    # This function is a simulation for the purpose of showing where your FastAPI app will be plugged in\n    import uvicorn\n    uvicorn.run(app, host\u003d\"0.0.0.0\", port\u003d8000)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    run_my_app()\n```\n\n**Ключевые изменения:**\n\n*   **`initialize_bot()` Function:** Созданна асинхронная функция для инициализации бота и установки webhook. Эта функция будет вызвана один раз при запуске вашего приложения.\n*   **`startup_event()`:**  Вызывает  `initialize_bot()` при старте приложения.\n*   **`shutdown_event()`:** Обрабатывает shutdown и очищает webhook.\n*   **Один экземпляр `bot_instance`:**  Бот инициализируется один раз при запуске приложения и используется во всех запросах webhook.\n*  **`run_my_app`:** Замените эту функцию на вашу реальную точку входа ASGI.\n\n**Инструкции по использованию с вашим сервером:**\n\n1.  **Интеграция FastAPI:**  Вам нужно будет интегрировать FastAPI в ваш существующий ASGI сервер. Как это сделать, будет зависеть от вашего сервера (например, для Django channels нужно будет добавить `FastAPI` как ASGI приложение в вашем `asgi.py` файле).\n2.  **Запуск ASGI:**  Вы не будете запускать `uvicorn` отдельно, вы будете использовать ваш существующий ASGI сервер.\n3.  **Webhook:** Ваш Telegram webhook URL должен быть направлен на `/webhook` эндпоинт вашего сервера.\n\n**Например, для Django Channels (примерно):**\n\nВ `asgi.py`:\n\n```python\nimport os\nfrom django.core.asgi import get_asgi_application\nfrom fastapi import FastAPI\nfrom bot_app import app as telegram_app # import your fastapi bot application as telegram_app\n\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"your_project.settings\")\ndjango_asgi_app \u003d get_asgi_application()\n\n# Create a root FastAPI application\napp \u003d FastAPI()\n\n@app.get(\"/test\")\nasync def test_endpoint():\n    return {\"message\": \"This is a test\"}\n\n# Integrate other ASGI app into FastAPI app\napp.mount(\"/\", django_asgi_app)\napp.mount(\"/telegram\", telegram_app) # mount telegram app\n\n```\n\n**Важно:**\n\n*   **Правильная настройка ASGI:** Убедитесь, что ваш ASGI сервер правильно настроен для работы с FastAPI и для обработки webhook запросов.\n*   **Уникальный эндпоинт:** Убедитесь, что ваш эндпоинт `/webhook` (или иной) не конфликтует с другими эндпоинтами вашего приложения.\n*   **Ошибки:**  Изучите логи, чтобы понять, есть ли проблемы с подключением webhook.\n\nВ вашем конкретном случае вам нужно будет адаптировать этот код к вашему серверу.  Если у вас возникнут проблемы с интеграцией в ваш существующий сервер, предоставьте больше информации о вашем сервере (например, Django, Flask, ...), и я смогу дать более точные инструкции.\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 3190
    }, {
      "text": "нет. у меня есть другая аппликация, которая запускет fas_api. Мне надо определить, зупщен он или нет. Если нет, то запустить, если да, слушать на определенном порту",
      "role": "user",
      "tokenCount": 48
    }, {
      "text": "Хорошо, я понял вашу задачу. Вам нужно определить, запущен ли уже экземпляр FastAPI приложения, и если нет, то запустить его. Если же он уже запущен, то просто нужно, чтобы ваш Telegram бот слушал на определенном порту (то есть обрабатывал webhook).\n\nЭто можно реализовать, используя механизм проверки наличия запущенного процесса, слушающего на определенном порту, и запуская приложение через `uvicorn`, если процесс не найден. Вот как это можно реализовать:\n\n```python\nfrom pathlib import Path\nimport tempfile\nimport asyncio\nimport logging\nimport json\nimport requests\nfrom typing import Dict, Optional\nfrom telegram import Update\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import Response\nfrom uvicorn import Config, Server  # Import Config and Server from uvicorn\nimport socket\nimport subprocess\nimport signal\nimport header\nfrom src import gs\nfrom src.endpoints.bots.telegram.bot_handlers import BotHandler\nfrom src.utils.jjson import j_loads, j_loads_ns, j_dumps\nfrom src.logger.logger import logger\nfrom src.utils.convertors.tts import speech_recognizer, text2speech\nfrom src.utils.file import read_text_file\nfrom src.utils.get_free_port import get_free_port\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\nclass TelegramBot:\n    \"\"\"Telegram bot interface class.\"\"\"\n\n    application: Application\n    host: str\n    port: int\n    webhook_url: str\n\n    def __init__(self, token: str, bot_handler: Optional[BotHandler] \u003d None):\n        \"\"\"Initialize the Telegram bot.\"\"\"\n        config_path \u003d Path(__file__).parent.parent / \u0027config.json\u0027\n\n        self._load_config(config_path)\n        self.application \u003d Application.builder().token(token).build()\n        self.bot_handler \u003d bot_handler if bot_handler else BotHandler()\n        self.register_handlers()\n        self.webhook_url \u003d os.getenv(\u0027WEBHOOK_URL\u0027)\n\n    def _load_config(self, config_path: str | Path) -\u003e None:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        try:\n            with open(config_path, \u0027r\u0027) as f:\n                config \u003d json.load(f)\n                bot_config \u003d config.get(\u0027telegram_bot\u0027, {})\n                if bot_config:\n                    self.host \u003d bot_config.get(\u0027host\u0027, \u0027127.0.0.1\u0027)\n                    port_range \u003d bot_config.get(\u0027port_range\u0027, [\u00279000\u0027, \u00279100\u0027])\n                    self.port \u003d get_free_port(self.host, port_range)\n                else:\n                    logger.error(f\u0027No config found for {self.__class__.__name__}\u0027)\n                    self.host \u003d \u0027127.0.0.1\u0027\n                    self.port \u003d get_free_port(self.host, [\u00279000\u0027, \u00279100\u0027])\n\n        except FileNotFoundError as ex:\n            logger.error(\u0027Error: Configuration file not found: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n        except json.JSONDecodeError as ex:\n            logger.error(\u0027Error: Invalid JSON format in configuration file: \u0027, ex)\n            self.host \u003d \u0027127.0.0.1\u0027\n            self.port \u003d 8080\n\n    def register_handlers(self):\n        \"\"\"Register bot commands and message handlers.\"\"\"\n        self.application.add_handler(CommandHandler(\u0027start\u0027, self.start))\n        self.application.add_handler(CommandHandler(\u0027help\u0027, self.help_command))\n        self.application.add_handler(CommandHandler(\u0027sendpdf\u0027, self.send_pdf))\n        self.application.add_handler(\n            MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_message)\n        )\n        self.application.add_handler(MessageHandler(filters.VOICE, self.handle_voice))\n        self.application.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))\n        self.application.add_handler(\n            MessageHandler(filters.TEXT \u0026 ~filters.COMMAND, self.handle_log)\n        )\n\n    async def start(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /start command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Hello! I am your simple bot. Type /help to see available commands.\u0027\n        )\n\n    async def help_command(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle the /help command.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        await self.update.message.reply_text(\n            \u0027Available commands:\\n\u0027\n            \u0027/start - Start the bot\\n\u0027\n            \u0027/help - Show this help message\\n\u0027\n            \u0027/sendpdf - Send a PDF file\u0027\n        )\n\n    async def send_pdf(\n        self, update: Update, context: CallbackContext, pdf_file: str | Path\n    ) -\u003e None:\n        \"\"\"Handle the /sendpdf command to generate and send a PDF file.\"\"\"\n        try:\n            self.update \u003d update\n            self.context \u003d context\n            with open(pdf_file, \u0027rb\u0027) as pdf_file_obj:\n                await self.update.message.reply_document(document\u003dpdf_file_obj)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при отправке PDF-файла: \u0027, ex)\n            await self.update.message.reply_text(\n                \u0027Произошла ошибка при отправке PDF-файла. Попробуй ещё раз.\u0027\n            )\n\n    async def handle_voice(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle voice messages and transcribe the audio.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        try:\n            voice \u003d self.update.message.voice\n            file \u003d await self.context.bot.get_file(voice.file_id)\n            file_path \u003d gs.path.temp / f\u0027{voice.file_id}.ogg\u0027\n\n            await file.download_to_drive(file_path)\n\n            transcribed_text \u003d await self.transcribe_voice(file_path)\n\n            await self.update.message.reply_text(f\u0027Распознанный текст: {transcribed_text}\u0027)\n\n        except Exception as ex:\n            logger.error(\u0027Ошибка при обработке голосового сообщения: \u0027, ex)\n            await self.update.message.reply_text(\n                \u0027Произошла ошибка при обработке голосового сообщения. Попробуй ещё раз.\u0027\n            )\n\n    async def transcribe_voice(self, file_path: Path) -\u003e str:\n        \"\"\"Transcribe voice message using a speech recognition service.\"\"\"\n        return \u0027Распознавание голоса ещё не реализовано.\u0027\n\n    async def handle_document(self, update: Update, context: CallbackContext) -\u003e str:\n        \"\"\"Handle received documents.\"\"\"\n        self.update \u003d update\n        self.context \u003d context\n        file \u003d await self.update.message.document.get_file()\n        tmp_file_path \u003d await file.download_to_drive()\n        return read_text_file(tmp_file_path)\n\n    async def handle_message(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle any text message.\"\"\"\n        await self.bot_handler.handle_message(update, context)\n\n    async def handle_log(self, update: Update, context: CallbackContext) -\u003e None:\n        \"\"\"Handle log messages.\"\"\"\n        log_message \u003d update.message.text\n        logger.info(f\"Received log message: {log_message}\")\n        await update.message.reply_text(\"Log received and processed.\")\n\n\n# FastAPI App Creation\napp \u003d FastAPI()\nbot_instance: Optional[TelegramBot] \u003d None\nserver: Optional[Server] \u003d None\n\n\ndef is_port_in_use(host: str, port: int) -\u003e bool:\n    \"\"\"Check if the given port is in use.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        try:\n            s.settimeout(1)\n            s.connect((host, port))\n            return True\n        except (socket.timeout, ConnectionRefusedError):\n            return False\n\nasync def initialize_bot():\n    global bot_instance\n    if not bot_instance:\n        token \u003d os.getenv(\u0027TELEGRAM_BOT_TOKEN\u0027)\n        bot_instance \u003d TelegramBot(token)\n        try:\n            await bot_instance.application.bot.set_webhook(\n                url\u003dbot_instance.webhook_url\n            )\n            logger.info(f\"Bot started with webhook: {bot_instance.webhook_url}\")\n        except Exception as ex:\n            logger.error(f\u0027Error setting webhook: {ex}\u0027)\n\nasync def start_uvicorn(host: str, port: int):\n     global server\n     config \u003d Config(app, host\u003dhost, port\u003dport, log_level\u003d\"info\")\n     server \u003d Server(config)\n     await server.serve()\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    await initialize_bot()\n\n    host \u003d os.getenv(\u0027HOST_URL\u0027, \u0027127.0.0.1\u0027)\n    port \u003d int(os.getenv(\u0027PORT\u0027, 8000))\n    if not is_port_in_use(host, port):\n        logger.info(f\"Starting uvicorn server on {host}:{port}\")\n        asyncio.create_task(start_uvicorn(host,port))\n    else:\n        logger.info(f\"Application already running on {host}:{port}, will just listen on it.\")\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    if bot_instance:\n        try:\n            await bot_instance.application.bot.delete_webhook()\n            logger.info(\"Bot stopped.\")\n        except Exception as ex:\n            logger.error(f\u0027Error deleting webhook: {ex}\u0027)\n    if server:\n        server.should_exit \u003d True # Signal uvicorn server to exit\n        await server.shutdown()\n\n\n# Handle Webhook\n@app.post(\"/webhook\")\nasync def telegram_webhook(request: Request):\n    if not bot_instance:\n        logger.error(\"Bot not initialized.\")\n        return Response(status_code\u003d500, content\u003d\"Bot not initialized.\")\n\n    try:\n        data \u003d await request.json()\n        async with bot_instance.application:\n            await bot_instance.application.process_update(\n                Update.de_json(data, bot_instance.application.bot)\n            )\n        return Response(status_code\u003d200)\n    except Exception as e:\n        logger.error(f\u0027Error processing webhook: {e}\u0027)\n        return Response(status_code\u003d500, content\u003df\u0027Error processing webhook: {e}\u0027)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host\u003d\"0.0.0.0\", port\u003d8000)\n\n```\n\n**Ключевые изменения:**\n\n1.  **`is_port_in_use(host, port)`:** Функция для проверки, используется ли порт. Она создает TCP socket и пробует установить соединение с хостом и портом.\n2. **`initialize_bot()`:** Инициализирует бота и ставит вебхук один раз\n3.  **`start_uvicorn(host,port)`:** Запускает uvicorn, передавая host и port, и сохраняет экземпляр сервера, что бы потом его корректно остановить\n4.  **`startup_event()`**: Вызывается при запуске FastAPI. Проверяет, используется ли порт, и запускает uvicorn сервер, если нет.\n5.  **`shutdown_event()`:** Вызывается при остановке FastAPI. Останавливает uvicorn сервер, если он был запущен.\n6.  **Глобальный `server`:** Сохраняется экземпляр uvicorn `Server`, чтобы его можно было корректно остановить в `shutdown_event`.\n\n**Как использовать:**\n\n1.  **Сохраните код:** Сохраните этот код в файл, например, `bot_app.py`.\n2.  **Установите зависимости:** Убедитесь, что установлены все необходимые библиотеки (FastAPI, uvicorn, python-telegram-bot, requests, dotenv).\n3.  **Установите переменные окружения:**\n    Создайте файл `.env` и добавьте туда:\n    ```env\n     TELEGRAM_BOT_TOKEN\u003d\u003cyour_telegram_bot_token\u003e\n     WEBHOOK_URL\u003d\u003cyour_webhook_url\u003e\n     HOST_URL\u003d0.0.0.0 # или 127.0.0.1\n     PORT\u003d8000\n    ```\n    Замените `\u003cyour_telegram_bot_token\u003e` и `\u003cyour_webhook_url\u003e` на ваши значения.\n4.  **Запустите:**\n    ```bash\n    python bot_app.py\n    ```\n5. **Запустите:**\n    Если FastAPI запущено, то ничего не произойдёт, бот просто будет слушать на этом порту.\n    Если нет, то FastApi стартанёт и бот заработает.\n\n**Объяснение:**\n\n*   Когда вы запускаете скрипт, он проверяет, используется ли порт. Если порт занят (т.е., FastAPI уже запущен), то бот просто начинает слушать на этом порту (webhook) и не запускает новый экземпляр `uvicorn`.\n*   Если порт не занят, скрипт запускает `uvicorn` на заданном порту и хосте, то есть поднимает FastAPI сервер.\n\n**Важно:**\n\n*   **Конфликты портов:** Убедитесь, что порт, который вы используете, не используется другими приложениями.\n*   **Адреса:** Используйте `0.0.0.0` для `HOST_URL`, чтобы приложение было доступно извне, либо `127.0.0.1`, если нужно, чтобы оно было доступно только локально.\n*   **Установка webhook:** Убедитесь, что ваш webhook url направлен на ваш сервер.\n*   **Ошибки:** Если возникают проблемы, посмотрите в логи (настройки логирования в коде).\n\nЭтот код должен обеспечить запуск FastAPI, только если он не был запущен ранее на определенном порту, и в любом случае бот будет работать, подключенный к вашему серверу через webhook.\n",
      "role": "model",
      "safetyRatings": [{
        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
        "probability": "LOW"
      }],
      "finishReason": "STOP"
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}