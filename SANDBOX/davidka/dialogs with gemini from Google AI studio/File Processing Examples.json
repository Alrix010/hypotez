{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-1.5-flash",
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "OFF"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "OFF"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableSearchAsATool": false,
    "enableBrowseAsATool": false,
    "enableAutoFunctionResponse": false
  },
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "Мне надо прочитать содержимое текстового файла и вернуть его как одну строку, убрать лишние (более одного) пробелы, заэкранировать `\"`",
      "role": "user",
      "tokenCount": 37
    }, {
      "text": "Вот несколько вариантов решения задачи на разных языках программирования:\n\n**Python:**\n\n```python\nimport re\n\ndef read_and_process_file(filepath):\n  \"\"\"Читает файл, удаляет лишние пробелы и экранирует кавычки.\"\"\"\n  try:\n    with open(filepath, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027) as f:  # Указываем кодировку для надежности\n      text \u003d f.read()\n  except FileNotFoundError:\n    return \"Файл не найден\"\n\n  # Удаляем лишние пробелы\n  text \u003d re.sub(r\u0027\\s+\u0027, \u0027 \u0027, text)\n\n  # Экранируем кавычки\n  text \u003d text.replace(\u0027\"\u0027, \u0027\\\\\"\u0027)\n\n  return text\n\nfilepath \u003d \"my_file.txt\"  # Замените на путь к вашему файлу\nresult \u003d read_and_process_file(filepath)\nprint(result)\n```\n\n**JavaScript (Node.js):**\n\n```javascript\nconst fs \u003d require(\u0027fs\u0027);\n\nfunction readAndProcessFile(filepath) {\n  try {\n    const text \u003d fs.readFileSync(filepath, \u0027utf-8\u0027);\n    // Удаляем лишние пробелы\n    const processedText \u003d text.replace(/\\s+/g, \u0027 \u0027).replace(\u0027\"\u0027, \u0027\\\\\"\u0027);\n    return processedText;\n  } catch (err) {\n    if (err.code \u003d\u003d\u003d \u0027ENOENT\u0027) {\n      return \"Файл не найден\";\n    } else {\n      throw err; // Передаем другие ошибки дальше\n    }\n  }\n}\n\nconst filepath \u003d \"my_file.txt\"; // Замените на путь к вашему файлу\nconst result \u003d readAndProcessFile(filepath);\nconsole.log(result);\n```\n\n**C#:**\n\n```csharp\nusing System;\nusing System.IO;\nusing System.Text.RegularExpressions;\n\npublic class FileProcessor\n{\n    public static string ReadAndProcessFile(string filepath)\n    {\n        try\n        {\n            string text \u003d File.ReadAllText(filepath);\n            // Удаляем лишние пробелы\n            text \u003d Regex.Replace(text, @\"\\s+\", \" \");\n            // Экранируем кавычки\n            text \u003d text.Replace(\"\\\"\", \"\\\\\\\"\");\n            return text;\n        }\n        catch (FileNotFoundException)\n        {\n            return \"Файл не найден\";\n        }\n        catch (Exception ex)\n        {\n            //Обработка других исключений\n            return \"Ошибка: \" + ex.Message;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        string filepath \u003d \"my_file.txt\"; // Замените на путь к вашему файлу\n        string result \u003d ReadAndProcessFile(filepath);\n        Console.WriteLine(result);\n    }\n}\n```\n\n\nВсе эти примеры:\n\n1. **Читают файл:** Используют соответствующие функции для чтения всего содержимого файла в одну строку.  Обратите внимание на обработку ошибок (файл не найден).\n2. **Удаляют лишние пробелы:** Используют регулярные выражения для замены одной или более пробелов на один пробел.\n3. **Экранируют кавычки:** Заменяют все символы `\"` на `\\\"`.\n4. **Возвращают результат:** Функции возвращают обработанную строку или сообщение об ошибке.\n\nНе забудьте заменить `\"my_file.txt\"` на фактический путь к вашему файлу.  Также, убедитесь, что у вашей программы есть права на чтение файла.  В Python и C# добавлена обработка исключений для случая отсутствия файла.  В JavaScript также добавлена более подробная обработка ошибок.  В случае возникновения проблем, обратите внимание на кодировку файла.  Если она не UTF-8, то нужно указать соответствующую кодировку при открытии файла (например, `encoding\u003d\u0027latin-1\u0027` в Python).\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 889
    }, {
      "text": "встрой функцию в этот код:\n```python\n## \\file /src/utils/file.py\n# -*- coding: utf-8 -*-\n#! .pyenv/bin/python3\n\n\"\"\"\n.. module:: src.utils.file \n\t:platform: Windows, Unix\n\t:synopsis: read, wite, search text files\n\nМодуль для работы с файлами.\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nМодуль содержит набор утилит для выполнения операций с файлами, таких как сохранение, чтение,\nи получение списков файлов. Поддерживает обработку больших файлов с использованием генераторов\nдля экономии памяти.\n\nПример использования\n--------------------\n\n.. code-block:: python\n\n    from pathlib import Path\n    from src.utils.file import read_text_file, save_text_file\n\n    file_path \u003d Path(\u0027example.txt\u0027)\n    content \u003d read_text_file(file_path)\n    if content:\n        print(f\u0027File content: {content[:100]}...\u0027)\n\n    save_text_file(file_path, \u0027Новый текст\u0027)\n\"\"\"\nimport os\nimport json\nimport fnmatch\nfrom pathlib import Path\nfrom typing import List, Optional, Union, Generator\nfrom src.logger.logger import logger\n\n\ndef save_text_file(\n    data: str | list[str] | dict,\n    file_path: str | Path,\n    mode: str \u003d \u0027w\u0027\n) -\u003e bool:\n    \"\"\"\n    Сохраняет данные в текстовый файл.\n\n    Args:\n        file_path (str | Path): Путь к файлу для сохранения.\n        data (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.\n        mode (str, optional): Режим записи файла (\u0027w\u0027 для записи, \u0027a\u0027 для добавления).\n    Returns:\n        bool: `True`, если файл успешно сохранен, `False` в противном случае.\n    Raises:\n        Exception: При возникновении ошибки при записи в файл.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e data \u003d \u0027Пример текста\u0027\n        \u003e\u003e\u003e result \u003d save_text_file(file_path, data)\n        \u003e\u003e\u003e print(result)\n        True\n    \"\"\"\n    try:\n        file_path \u003d Path(file_path)\n        file_path.parent.mkdir(parents \u003d True, exist_ok \u003d True)\n\n        with file_path.open(mode, encoding \u003d \u0027utf-8\u0027) as file:\n            if isinstance(data, list):\n                file.writelines(f\u0027{line}\\n\u0027 for line in data)\n            elif isinstance(data, dict):\n                json.dump(data, file, ensure_ascii \u003d False, indent \u003d 4)\n            else:\n                file.write(data)\n        return True\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при сохранении файла {file_path}.\u0027, ex)\n        ...\n        return False\n    \ndef read_text_file_generator(\n    file_path: str | Path,\n    as_list: bool \u003d False,\n    extensions: Optional[list[str]] \u003d None,\n    chunk_size: int \u003d 8192,\n    recursive: bool \u003d False,\n    patterns: Optional[str | list[str]] \u003d None,\n) -\u003e Generator[str, None, None] | str | list[str] | None:\n    \"\"\"\n    Читает содержимое файла(ов) или директории.\n\n        Args:\n            file_path (str | Path): Путь к файлу или директории.\n            as_list (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода.\n            extensions (list[str], optional): Список расширений файлов для включения при чтении директории.\n            chunk_size (int, optional): Размер чанка для чтения файла в байтах.\n            recursive (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно.\n            patterns (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.\n\n        Returns:\n            Generator[str, None, None] | str | list[str] | None:\n            - Если `as_list` is True и `file_path` является файлом, возвращает генератор строк.\n            - Если `as_list` is True и `file_path` является директорией и `recursive` is True, возвращает список строк.\n            - Если `as_list` is False и `file_path` является файлом, возвращает строку.\n            - Если `as_list` is False и `file_path` является директорией, возвращает объединенную строку.\n            - Возвращает `None` в случае ошибки.\n        Raises:\n            Exception: При возникновении ошибки при чтении файла.\n\n        Example:\n            \u003e\u003e\u003e from pathlib import Path\n            \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n            \u003e\u003e\u003e content \u003d read_text_file(file_path)\n            \u003e\u003e\u003e if content:\n            ...    print(f\u0027File content: {content[:100]}...\u0027)\n            File content: Пример текста...\n    Функция read_text_file может возвращать несколько разных типов данных в зависимости от входных параметров:\n\n    Возвращаемые значения:\n    ----------------------\n\n    - Generator[str, None, None] (Генератор строк):\n        Генератор при итерации выдаёт строки из файла(ов) по одной. Эффективно для работы с большими файлами, так как они не загружаются полностью в память.\n        - Когда:\n            file_path – это файл и as_list равен True.\n            file_path – это директория, recursive равен True и as_list равен True. При этом в генератор попадают строки из всех найденных файлов.\n            file_path – это директория, recursive равен False и as_list равен True. При этом в генератор попадают строки из всех найденных файлов в текущей директории.\n        \n    - str (Строка):\n        Содержимое файла или объединенное содержимое всех файлов в виде одной строки.\n        - Когда:\n            file_path – это файл и as_list равен False.\n            file_path – это директория, recursive равен False и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории, разделенных символами новой строки (\\n).\n            file_path – это директория, recursive равен True и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории и её поддиректориях, разделенных символами новой строки (\\n).\n \n    - list[str] (Список строк):\n        Этот тип явно не возвращается функцией, однако когда file_path – это директория, recursive равен True и as_list равен True - функция возвращает генератор, который можно преобразовать в список при помощи list()\n        - Когда:\n            file_path – не является ни файлом, ни директорией.\n            Произошла ошибка при чтении файла или директории (например, файл не найден, ошибка доступа и т.п.).\n\n\n    Note:\n        Если вы хотите прочитать содержимое файла построчно (особенно для больших файлов) используйте as_list \u003d True. В этом случае вы получите генератор строк.\n        Если вы хотите получить всё содержимое файла в виде одной строки используйте as_list \u003d False.\n        Если вы работаете с директорией, recursive \u003d True будет обходить все поддиректории.\n        extensions и patterns позволят вам фильтровать файлы при работе с директорией.\n        chunk_size позволяет оптимизировать работу с большими файлами при чтении их по частям.\n        None будет возвращён в случае ошибок.\n\n    Важно помнить:\n        В случае чтения директории, если as_list\u003dFalse, функция объединяет все содержимое найденных файлов в одну строку. Это может потребовать много памяти, если файлов много или они большие.\n        Функция полагается на другие функции-помощники (_read_file_lines_generator, _read_file_content, recursively_get_file_path, yield_text_from_files), которые здесь не определены и их поведение влияет на результат read_text_file.\n\n\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            if as_list:\n                return _read_file_lines_generator(path, chunk_size \u003d chunk_size)\n            else:\n                return _read_file_content(path, chunk_size \u003d chunk_size)\n        elif path.is_dir():\n            if recursive:\n                if patterns:\n                    files \u003d recursively_get_file_path(path, patterns)\n                else:\n                   files \u003d [\n                        p for p in path.rglob(\u0027*\u0027) if p.is_file() and (not extensions or p.suffix in extensions)\n                    ]\n                if as_list:\n                    return (\n                        line\n                        for file in files\n                        for line in yield_text_from_files(file, as_list \u003d True, chunk_size \u003d chunk_size)\n                    )\n                else:\n                    return \u0027\\n\u0027.join(filter(None, [read_text_file(p, chunk_size \u003d chunk_size) for p in files]))\n            else:\n                files \u003d [\n                    p for p in path.iterdir() if p.is_file() and (not extensions or p.suffix in extensions)\n                ]\n                if as_list:\n                    return (line for file in files for line in read_text_file(file, as_list \u003d True, chunk_size \u003d chunk_size) )\n                else:\n                    return \u0027\\n\u0027.join(filter(None, [read_text_file(p, chunk_size \u003d chunk_size) for p in files]))\n        else:\n            logger.error(f\u0027Путь \\\u0027{file_path}\\\u0027 не является файлом или директорией.\u0027)\n            ...\n            return None\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при чтении файла/директории {file_path}.\u0027, ex)\n        ...\n        return None\n\ndef read_text_file(\n    file_path: Union[str, Path],\n    as_list: bool \u003d False,\n    extensions: Optional[list[str]] \u003d None,\n    exc_info: bool \u003d True,\n) -\u003e str | list[str] | None:\n    \"\"\"\n    Read the contents of a file.\n\n    Args:\n        file_path (str | Path): Path to the file or directory.\n        as_list (bool, optional): If True, returns content as list of lines. Defaults to False.\n        extensions (list[str], optional): List of file extensions to include if reading a directory. Defaults to None.\n        exc_info (bool, optional): If True, logs traceback on error. Defaults to True.\n\n    Returns:\n        str | list[str] | None: File content as a string or list of lines, or None if an error occurs.\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            with path.open(\"r\", encoding\u003d\"utf-8\") as f:\n                return f.readlines() if as_list else f.read()\n        elif path.is_dir():\n            files \u003d [\n                p for p in path.rglob(\"*\") if p.is_file() and (not extensions or p.suffix in extensions)\n            ]\n            contents \u003d [read_text_file(p, as_list) for p in files]\n            return [item for sublist in contents if sublist for item in sublist] if as_list else \"\\n\".join(filter(None, contents))\n        else:\n            logger.warning(f\"Path \u0027{file_path}\u0027 is invalid.\")\n            return \n    except Exception as ex:\n        logger.error(f\"Failed to read file {file_path}.\", ex, exc_info\u003dexc_info)\n        return \n\ndef yield_text_from_files(\n    file_path: str | Path,\n    as_list: bool \u003d False,\n    chunk_size: int \u003d 8192\n) -\u003e Generator[str, None, None] | str | None:\n    \"\"\"\n    Читает содержимое файла и возвращает его в виде генератора строк или одной строки.\n\n    Args:\n        file_path (str | Path): Путь к файлу.\n        as_list (bool, optional): Если True, возвращает генератор строк. По умолчанию False.\n        chunk_size (int, optional): Размер чанка для чтения файла в байтах.\n\n    Returns:\n        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или None в случае ошибки.\n\n    Yields:\n       str: Строки из файла, если as_list is True.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e for line in yield_text_from_files(file_path, as_list\u003dTrue):\n        ...     print(line)\n        Первая строка файла\n        Вторая строка файла\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            if as_list:\n                 yield from  _read_file_lines_generator(path, chunk_size \u003d chunk_size)\n            else:\n                yield _read_file_content(path, chunk_size \u003d chunk_size)\n        else:\n             logger.error(f\u0027Путь \\\u0027{file_path}\\\u0027 не является файлом.\u0027)\n             ...\n             return None\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при чтении файла {file_path}.\u0027, ex)\n        ...\n        return None\n\ndef _read_file_content(file_path: Path, chunk_size: int) -\u003e str:\n    \"\"\"\n    Читает содержимое файла по чанкам и возвращает как строку.\n\n    Args:\n        file_path (Path): Путь к файлу для чтения.\n        chunk_size (int): Размер чанка для чтения файла в байтах.\n    Returns:\n        str: Содержимое файла в виде строки.\n    Raises:\n        Exception: При возникновении ошибки при чтении файла.\n    \"\"\"\n    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n        content \u003d \u0027\u0027\n        while True:\n            chunk \u003d f.read(chunk_size)\n            if not chunk:\n                break\n            content +\u003d chunk\n        return content\n\ndef _read_file_lines_generator(file_path: Path, chunk_size: int) -\u003e Generator[str, None, None]:\n    \"\"\"\n    Читает файл по строкам с помощью генератора.\n\n    Args:\n        file_path (Path): Путь к файлу для чтения.\n        chunk_size (int): Размер чанка для чтения файла в байтах.\n    Yields:\n        str: Строки из файла.\n    Raises:\n        Exception: При возникновении ошибки при чтении файла.\n    \"\"\"\n    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n         while True:\n                chunk \u003d f.read(chunk_size)\n                if not chunk:\n                    break\n                lines \u003d chunk.splitlines()\n                # Если чанк не закончился полной строкой, то последнюю строку добавляем к следующему чанку\n                if len(lines)\u003e0 and not chunk.endswith(\u0027\\n\u0027):\n                     next_chunk \u003d f.read(1)\n                     if next_chunk !\u003d \u0027\u0027:\n                        lines[-1] \u003d lines[-1] + next_chunk\n                     else:\n                        yield from lines\n                        break\n                \n                yield from lines\n\n\ndef get_filenames_from_directory(\n    directory: str | Path, ext: str | list[str] \u003d \u0027*\u0027\n) -\u003e list[str]:\n    \"\"\"\n    Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.\n\n    Args:\n        directory (str | Path): Путь к директории для поиска.\n        ext (str | list[str], optional): Расширения для фильтрации.\n            По умолчанию \u0027*\u0027.\n\n    Returns:\n        list[str]: Список имен файлов, найденных в директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e directory \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e get_filenames_from_directory(directory, [\u0027.txt\u0027, \u0027.md\u0027])\n        [\u0027example.txt\u0027, \u0027readme.md\u0027]\n    \"\"\"\n    if not Path(directory).is_dir():\n        logger.error(f\u0027Указанный путь \\\u0027{directory}\\\u0027 не является директорией.\u0027)\n        return []\n\n    try:\n        if isinstance(ext, str):\n            extensions \u003d [ext] if ext !\u003d \u0027*\u0027 else []\n        extensions \u003d [e if e.startswith(\u0027.\u0027) else f\u0027.{e}\u0027 for e in extensions]\n\n        return [\n            file.name\n            for file in directory.iterdir()\n            if file.is_file() and (not extensions or file.suffix in extensions)\n        ]\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при получении списка имен файлов из \\\u0027{directory}\\\u0027.\u0027, ex)\n        return []\n\n\ndef recursively_yield_file_path(\n    root_dir: str | Path, patterns: str | list[str] \u003d \u0027*\u0027\n) -\u003e Generator[Path, None, None]:\n    \"\"\"\n    Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.\n\n    Args:\n        root_dir (str | Path): Корневая директория для поиска.\n        patterns (str | list[str]): Шаблоны для фильтрации файлов.\n\n    Yields:\n        Path: Путь к файлу, соответствующему шаблону.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e for path in recursively_yield_file_path(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027]):\n        ...    print(path)\n        ./example.txt\n        ./readme.md\n    \"\"\"\n    try:\n        patterns \u003d [patterns] if isinstance(patterns, str) else patterns\n        for pattern in patterns:\n            yield from Path(root_dir).rglob(pattern)\n    except Exception as ex:\n         logger.error(f\u0027Ошибка при рекурсивном поиске файлов в \\\u0027{root_dir}\\\u0027.\u0027, ex)\n\n\ndef recursively_get_file_path(\n    root_dir: str | Path,\n    patterns: str | list[str] \u003d \u0027*\u0027\n) -\u003e list[Path]:\n    \"\"\"\n    Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.\n\n    Args:\n        root_dir (str | Path): Корневая директория для поиска.\n        patterns (str | list[str]): Шаблоны для фильтрации файлов.\n\n    Returns:\n        list[Path]: Список путей к файлам, соответствующим шаблонам.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e paths \u003d recursively_get_file_path(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027])\n        \u003e\u003e\u003e print(paths)\n        [Path(\u0027./example.txt\u0027), Path(\u0027./readme.md\u0027)]\n    \"\"\"\n    try:\n        file_paths \u003d []\n        patterns \u003d [patterns] if isinstance(patterns, str) else patterns\n        for pattern in patterns:\n            file_paths.extend(Path(root_dir).rglob(pattern))\n        return file_paths\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при рекурсивном поиске файлов в \\\u0027{root_dir}\\\u0027.\u0027, ex)\n        return []\n\n\ndef recursively_read_text_files(\n    root_dir: str | Path,\n    patterns: str | list[str],\n    as_list: bool \u003d False\n) -\u003e list[str]:\n    \"\"\"\n    Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.\n\n    Args:\n        root_dir (str | Path): Путь к корневой директории для поиска.\n        patterns (str | list[str]): Шаблон(ы) имени файла для фильтрации.\n             Может быть как одиночным шаблоном (например, \u0027*.txt\u0027), так и списком.\n        as_list (bool, optional): Если True, то возвращает содержимое файла как список строк.\n             По умолчанию `False`.\n\n    Returns:\n        list[str]: Список содержимого файлов (или список строк, если `as_list\u003dTrue`),\n         соответствующих заданным шаблонам.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e contents \u003d recursively_read_text_files(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027], as_list\u003dTrue)\n        \u003e\u003e\u003e for line in contents:\n        ...     print(line)\n        Содержимое example.txt\n        Первая строка readme.md\n        Вторая строка readme.md\n    \"\"\"\n    matches \u003d []\n    root_path \u003d Path(root_dir)\n\n    if not root_path.is_dir():\n        logger.debug(f\u0027Корневая директория \\\u0027{root_path}\\\u0027 не существует или не является директорией.\u0027)\n        return []\n\n    print(f\u0027Поиск в директории: {root_path}\u0027)\n\n    if isinstance(patterns, str):\n        patterns \u003d [patterns]\n\n    for root, _, files in os.walk(root_path):\n        for filename in files:\n            if any(fnmatch.fnmatch(filename, pattern) for pattern in patterns):\n                file_path \u003d Path(root) / filename\n\n                try:\n                    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as file:\n                        if as_list:\n                            matches.extend(file.readlines())\n                        else:\n                            matches.append(file.read())\n                except Exception as ex:\n                    logger.error(f\u0027Ошибка при чтении файла \\\u0027{file_path}\\\u0027.\u0027, ex)\n\n    return matches\n\n\ndef get_directory_names(directory: str | Path) -\u003e list[str]:\n    \"\"\"\n    Возвращает список имен директорий из указанной директории.\n\n    Args:\n        directory (str | Path): Путь к директории, из которой нужно получить имена.\n\n    Returns:\n        list[str]: Список имен директорий, найденных в указанной директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e directory \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e get_directory_names(directory)\n        [\u0027dir1\u0027, \u0027dir2\u0027]\n    \"\"\"\n    try:\n        return [entry.name for entry in Path(directory).iterdir() if entry.is_dir()]\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при получении списка имен директорий из \\\u0027{directory}\\\u0027.\u0027, ex)\n        return []\n\n\ndef remove_bom(path: str | Path) -\u003e None:\n    \"\"\"\n    Удаляет BOM из текстового файла или из всех файлов Python в директории.\n\n    Args:\n        path (str | Path): Путь к файлу или директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e with open(file_path, \u0027w\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n        ...     f.write(\u0027\\ufeffПример текста с BOM\u0027)\n        \u003e\u003e\u003e remove_bom(file_path)\n        \u003e\u003e\u003e with open(file_path, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n        ...     print(f.read())\n        Пример текста с BOM\n    \"\"\"\n    path \u003d Path(path)\n    if path.is_file():\n        try:\n            with path.open(\u0027r+\u0027, encoding \u003d \u0027utf-8\u0027) as file:\n                content \u003d file.read().replace(\u0027\\ufeff\u0027, \u0027\u0027)\n                file.seek(0)\n                file.write(content)\n                file.truncate()\n        except Exception as ex:\n            logger.error(f\u0027Ошибка при удалении BOM из файла {path}.\u0027, ex)\n            ...\n    elif path.is_dir():\n        for root, _, files in os.walk(path):\n             for file in files:\n                 if file.endswith(\u0027.py\u0027):\n                    file_path \u003d Path(root) / file\n                    try:\n                        with file_path.open(\u0027r+\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n                            content \u003d f.read().replace(\u0027\\ufeff\u0027, \u0027\u0027)\n                            f.seek(0)\n                            f.write(content)\n                            f.truncate()\n                    except Exception as ex:\n                       logger.error(f\u0027Ошибка при удалении BOM из файла {file_path}.\u0027, ex)\n                       ...\n\n    else:\n        logger.error(f\u0027Указанный путь \\\u0027{path}\\\u0027 не является файлом или директорией.\u0027)\n        ...\n\n\n\ndef main() -\u003e None:\n    \"\"\"Entry point for BOM removal in Python files.\"\"\"\n    root_dir \u003d Path(\u0027..\u0027, \u0027src\u0027)\n    logger.info(f\u0027Starting BOM removal in {root_dir}\u0027)\n    remove_bom(root_dir)\n\n\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n    main()\n```",
      "role": "user",
      "tokenCount": 5915
    }, {
      "text": "```python\n## \\file /src/utils/file.py\n# -*- coding: utf-8 -*-\n#! .pyenv/bin/python3\n\n\"\"\"\n.. module:: src.utils.file \n\t:platform: Windows, Unix\n\t:synopsis: read, wite, search text files\n\nМодуль для работы с файлами.\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nМодуль содержит набор утилит для выполнения операций с файлами, таких как сохранение, чтение,\nи получение списков файлов. Поддерживает обработку больших файлов с использованием генераторов\nдля экономии памяти.\n\nПример использования\n--------------------\n\n.. code-block:: python\n\n    from pathlib import Path\n    from src.utils.file import read_text_file, save_text_file\n\n    file_path \u003d Path(\u0027example.txt\u0027)\n    content \u003d read_text_file(file_path)\n    if content:\n        print(f\u0027File content: {content[:100]}...\u0027)\n\n    save_text_file(file_path, \u0027Новый текст\u0027)\n\"\"\"\nimport os\nimport json\nimport fnmatch\nimport re\nfrom pathlib import Path\nfrom typing import List, Optional, Union, Generator\nfrom src.logger.logger import logger\n\n\ndef save_text_file(\n    data: str | list[str] | dict,\n    file_path: str | Path,\n    mode: str \u003d \u0027w\u0027\n) -\u003e bool:\n    \"\"\"\n    Сохраняет данные в текстовый файл.\n\n    Args:\n        file_path (str | Path): Путь к файлу для сохранения.\n        data (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.\n        mode (str, optional): Режим записи файла (\u0027w\u0027 для записи, \u0027a\u0027 для добавления).\n    Returns:\n        bool: `True`, если файл успешно сохранен, `False` в противном случае.\n    Raises:\n        Exception: При возникновении ошибки при записи в файл.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e data \u003d \u0027Пример текста\u0027\n        \u003e\u003e\u003e result \u003d save_text_file(file_path, data)\n        \u003e\u003e\u003e print(result)\n        True\n    \"\"\"\n    try:\n        file_path \u003d Path(file_path)\n        file_path.parent.mkdir(parents \u003d True, exist_ok \u003d True)\n\n        with file_path.open(mode, encoding \u003d \u0027utf-8\u0027) as file:\n            if isinstance(data, list):\n                file.writelines(f\u0027{line}\\n\u0027 for line in data)\n            elif isinstance(data, dict):\n                json.dump(data, file, ensure_ascii \u003d False, indent \u003d 4)\n            else:\n                file.write(data)\n        return True\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при сохранении файла {file_path}.\u0027, ex)\n        ...\n        return False\n    \ndef read_text_file_generator(\n    file_path: str | Path,\n    as_list: bool \u003d False,\n    extensions: Optional[list[str]] \u003d None,\n    chunk_size: int \u003d 8192,\n    recursive: bool \u003d False,\n    patterns: Optional[str | list[str]] \u003d None,\n) -\u003e Generator[str, None, None] | str | list[str] | None:\n    \"\"\"\n    Читает содержимое файла(ов) или директории.\n\n        Args:\n            file_path (str | Path): Путь к файлу или директории.\n            as_list (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода.\n            extensions (list[str], optional): Список расширений файлов для включения при чтении директории.\n            chunk_size (int, optional): Размер чанка для чтения файла в байтах.\n            recursive (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно.\n            patterns (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.\n\n        Returns:\n            Generator[str, None, None] | str | list[str] | None:\n            - Если `as_list` is True и `file_path` является файлом, возвращает генератор строк.\n            - Если `as_list` is True и `file_path` является директорией и `recursive` is True, возвращает список строк.\n            - Если `as_list` is False и `file_path` является файлом, возвращает строку.\n            - Если `as_list` is False и `file_path` является директорией, возвращает объединенную строку.\n            - Возвращает `None` в случае ошибки.\n        Raises:\n            Exception: При возникновении ошибки при чтении файла.\n\n        Example:\n            \u003e\u003e\u003e from pathlib import Path\n            \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n            \u003e\u003e\u003e content \u003d read_text_file(file_path)\n            \u003e\u003e\u003e if content:\n            ...    print(f\u0027File content: {content[:100]}...\u0027)\n            File content: Пример текста...\n    Функция read_text_file может возвращать несколько разных типов данных в зависимости от входных параметров:\n\n    Возвращаемые значения:\n    ----------------------\n\n    - Generator[str, None, None] (Генератор строк):\n        Генератор при итерации выдаёт строки из файла(ов) по одной. Эффективно для работы с большими файлами, так как они не загружаются полностью в память.\n        - Когда:\n            file_path – это файл и as_list равен True.\n            file_path – это директория, recursive равен True и as_list равен True. При этом в генератор попадают строки из всех найденных файлов.\n            file_path – это директория, recursive равен False и as_list равен True. При этом в генератор попадают строки из всех найденных файлов в текущей директории.\n        \n    - str (Строка):\n        Содержимое файла или объединенное содержимое всех файлов в виде одной строки.\n        - Когда:\n            file_path – это файл и as_list равен False.\n            file_path – это директория, recursive равен False и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории, разделенных символами новой строки (\\n).\n            file_path – это директория, recursive равен True и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории и её поддиректориях, разделенных символами новой строки (\\n).\n \n    - list[str] (Список строк):\n        Этот тип явно не возвращается функцией, однако когда file_path – это директория, recursive равен True и as_list равен True - функция возвращает генератор, который можно преобразовать в список при помощи list()\n        - Когда:\n            file_path – не является ни файлом, ни директорией.\n            Произошла ошибка при чтении файла или директории (например, файл не найден, ошибка доступа и т.п.).\n\n\n    Note:\n        Если вы хотите прочитать содержимое файла построчно (особенно для больших файлов) используйте as_list \u003d True. В этом случае вы получите генератор строк.\n        Если вы хотите получить всё содержимое файла в виде одной строки используйте as_list \u003d False.\n        Если вы работаете с директорией, recursive \u003d True будет обходить все поддиректории.\n        extensions и patterns позволят вам фильтровать файлы при работе с директорией.\n        chunk_size позволяет оптимизировать работу с большими файлами при чтении их по частям.\n        None будет возвращён в случае ошибок.\n\n    Важно помнить:\n        В случае чтения директории, если as_list\u003dFalse, функция объединяет все содержимое найденных файлов в одну строку. Это может потребовать много памяти, если файлов много или они большие.\n        Функция полагается на другие функции-помощники (_read_file_lines_generator, _read_file_content, recursively_get_file_path, yield_text_from_files), которые здесь не определены и их поведение влияет на результат read_text_file.\n\n\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            if as_list:\n                return _read_file_lines_generator(path, chunk_size \u003d chunk_size)\n            else:\n                return _read_file_content(path, chunk_size \u003d chunk_size)\n        elif path.is_dir():\n            if recursive:\n                if patterns:\n                    files \u003d recursively_get_file_path(path, patterns)\n                else:\n                   files \u003d [\n                        p for p in path.rglob(\u0027*\u0027) if p.is_file() and (not extensions or p.suffix in extensions)\n                    ]\n                if as_list:\n                    return (\n                        line\n                        for file in files\n                        for line in yield_text_from_files(file, as_list \u003d True, chunk_size \u003d chunk_size)\n                    )\n                else:\n                    return \u0027\\n\u0027.join(filter(None, [read_text_file(p, chunk_size \u003d chunk_size) for p in files]))\n            else:\n                files \u003d [\n                    p for p in path.iterdir() if p.is_file() and (not extensions or p.suffix in extensions)\n                ]\n                if as_list:\n                    return (line for file in files for line in read_text_file(file, as_list \u003d True, chunk_size \u003d chunk_size) )\n                else:\n                    return \u0027\\n\u0027.join(filter(None, [read_text_file(p, chunk_size \u003d chunk_size) for p in files]))\n        else:\n            logger.error(f\u0027Путь \\\u0027{file_path}\\\u0027 не является файлом или директорией.\u0027)\n            ...\n            return None\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при чтении файла/директории {file_path}.\u0027, ex)\n        ...\n        return None\n\ndef read_text_file(\n    file_path: Union[str, Path],\n    as_list: bool \u003d False,\n    extensions: Optional[list[str]] \u003d None,\n    exc_info: bool \u003d True,\n    chunk_size: int \u003d 8192\n) -\u003e str | list[str] | None:\n    \"\"\"\n    Read the contents of a file.\n\n    Args:\n        file_path (str | Path): Path to the file or directory.\n        as_list (bool, optional): If True, returns content as list of lines. Defaults to False.\n        extensions (list[str], optional): List of file extensions to include if reading a directory. Defaults to None.\n        exc_info (bool, optional): If True, logs traceback on error. Defaults to True.\n\n    Returns:\n        str | list[str] | None: File content as a string or list of lines, or None if an error occurs.\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            with path.open(\"r\", encoding\u003d\"utf-8\") as f:\n                content \u003d f.read()\n                #Обработка согласно заданию\n                content \u003d re.sub(r\u0027\\s+\u0027, \u0027 \u0027, content)\n                content \u003d content.replace(\u0027\"\u0027, \u0027\\\\\"\u0027)\n                return content.splitlines() if as_list else content\n        elif path.is_dir():\n            files \u003d [\n                p for p in path.rglob(\"*\") if p.is_file() and (not extensions or p.suffix in extensions)\n            ]\n            contents \u003d [read_text_file(p, as_list, chunk_size\u003dchunk_size) for p in files]\n            return [item for sublist in contents if sublist for item in sublist] if as_list else \"\\n\".join(filter(None, contents))\n        else:\n            logger.warning(f\"Path \u0027{file_path}\u0027 is invalid.\")\n            return \n    except Exception as ex:\n        logger.error(f\"Failed to read file {file_path}.\", ex, exc_info\u003dexc_info)\n        return \n\ndef yield_text_from_files(\n    file_path: str | Path,\n    as_list: bool \u003d False,\n    chunk_size: int \u003d 8192\n) -\u003e Generator[str, None, None] | str | None:\n    \"\"\"\n    Читает содержимое файла и возвращает его в виде генератора строк или одной строки.\n\n    Args:\n        file_path (str | Path): Путь к файлу.\n        as_list (bool, optional): Если True, возвращает генератор строк. По умолчанию False.\n        chunk_size (int, optional): Размер чанка для чтения файла в байтах.\n\n    Returns:\n        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или None в случае ошибки.\n\n    Yields:\n       str: Строки из файла, если as_list is True.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e for line in yield_text_from_files(file_path, as_list\u003dTrue):\n        ...     print(line)\n        Первая строка файла\n        Вторая строка файла\n    \"\"\"\n    try:\n        path \u003d Path(file_path)\n        if path.is_file():\n            if as_list:\n                 yield from  _read_file_lines_generator(path, chunk_size \u003d chunk_size)\n            else:\n                yield _read_file_content(path, chunk_size \u003d chunk_size)\n        else:\n             logger.error(f\u0027Путь \\\u0027{file_path}\\\u0027 не является файлом.\u0027)\n             ...\n             return None\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при чтении файла {file_path}.\u0027, ex)\n        ...\n        return None\n\ndef _read_file_content(file_path: Path, chunk_size: int) -\u003e str:\n    \"\"\"\n    Читает содержимое файла по чанкам и возвращает как строку.\n\n    Args:\n        file_path (Path): Путь к файлу для чтения.\n        chunk_size (int): Размер чанка для чтения файла в байтах.\n    Returns:\n        str: Содержимое файла в виде строки.\n    Raises:\n        Exception: При возникновении ошибки при чтении файла.\n    \"\"\"\n    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n        content \u003d \u0027\u0027\n        while True:\n            chunk \u003d f.read(chunk_size)\n            if not chunk:\n                break\n            content +\u003d chunk\n        #Обработка согласно заданию\n        content \u003d re.sub(r\u0027\\s+\u0027, \u0027 \u0027, content)\n        content \u003d content.replace(\u0027\"\u0027, \u0027\\\\\"\u0027)\n        return content\n\ndef _read_file_lines_generator(file_path: Path, chunk_size: int) -\u003e Generator[str, None, None]:\n    \"\"\"\n    Читает файл по строкам с помощью генератора.\n\n    Args:\n        file_path (Path): Путь к файлу для чтения.\n        chunk_size (int): Размер чанка для чтения файла в байтах.\n    Yields:\n        str: Строки из файла.\n    Raises:\n        Exception: При возникновении ошибки при чтении файла.\n    \"\"\"\n    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n         while True:\n                chunk \u003d f.read(chunk_size)\n                if not chunk:\n                    break\n                lines \u003d chunk.splitlines()\n                # Если чанк не закончился полной строкой, то последнюю строку добавляем к следующему чанку\n                if len(lines)\u003e0 and not chunk.endswith(\u0027\\n\u0027):\n                     next_chunk \u003d f.read(1)\n                     if next_chunk !\u003d \u0027\u0027:\n                        lines[-1] \u003d lines[-1] + next_chunk\n                     else:\n                        for line in lines:\n                            #Обработка согласно заданию\n                            line \u003d re.sub(r\u0027\\s+\u0027, \u0027 \u0027, line)\n                            line \u003d line.replace(\u0027\"\u0027, \u0027\\\\\"\u0027)\n                            yield line\n                        break\n                \n                for line in lines:\n                    #Обработка согласно заданию\n                    line \u003d re.sub(r\u0027\\s+\u0027, \u0027 \u0027, line)\n                    line \u003d line.replace(\u0027\"\u0027, \u0027\\\\\"\u0027)\n                    yield line\n\n\ndef get_filenames_from_directory(\n    directory: str | Path, ext: str | list[str] \u003d \u0027*\u0027\n) -\u003e list[str]:\n    \"\"\"\n    Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.\n\n    Args:\n        directory (str | Path): Путь к директории для поиска.\n        ext (str | list[str], optional): Расширения для фильтрации.\n            По умолчанию \u0027*\u0027.\n\n    Returns:\n        list[str]: Список имен файлов, найденных в директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e directory \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e get_filenames_from_directory(directory, [\u0027.txt\u0027, \u0027.md\u0027])\n        [\u0027example.txt\u0027, \u0027readme.md\u0027]\n    \"\"\"\n    if not Path(directory).is_dir():\n        logger.error(f\u0027Указанный путь \\\u0027{directory}\\\u0027 не является директорией.\u0027)\n        return []\n\n    try:\n        if isinstance(ext, str):\n            extensions \u003d [ext] if ext !\u003d \u0027*\u0027 else []\n        extensions \u003d [e if e.startswith(\u0027.\u0027) else f\u0027.{e}\u0027 for e in extensions]\n\n        return [\n            file.name\n            for file in directory.iterdir()\n            if file.is_file() and (not extensions or file.suffix in extensions)\n        ]\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при получении списка имен файлов из \\\u0027{directory}\\\u0027.\u0027, ex)\n        return []\n\n\ndef recursively_yield_file_path(\n    root_dir: str | Path, patterns: str | list[str] \u003d \u0027*\u0027\n) -\u003e Generator[Path, None, None]:\n    \"\"\"\n    Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.\n\n    Args:\n        root_dir (str | Path): Корневая директория для поиска.\n        patterns (str | list[str]): Шаблоны для фильтрации файлов.\n\n    Yields:\n        Path: Путь к файлу, соответствующему шаблону.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e for path in recursively_yield_file_path(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027]):\n        ...    print(path)\n        ./example.txt\n        ./readme.md\n    \"\"\"\n    try:\n        patterns \u003d [patterns] if isinstance(patterns, str) else patterns\n        for pattern in patterns:\n            yield from Path(root_dir).rglob(pattern)\n    except Exception as ex:\n         logger.error(f\u0027Ошибка при рекурсивном поиске файлов в \\\u0027{root_dir}\\\u0027.\u0027, ex)\n\n\ndef recursively_get_file_path(\n    root_dir: str | Path,\n    patterns: str | list[str] \u003d \u0027*\u0027\n) -\u003e list[Path]:\n    \"\"\"\n    Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.\n\n    Args:\n        root_dir (str | Path): Корневая директория для поиска.\n        patterns (str | list[str]): Шаблоны для фильтрации файлов.\n\n    Returns:\n        list[Path]: Список путей к файлам, соответствующим шаблонам.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e paths \u003d recursively_get_file_path(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027])\n        \u003e\u003e\u003e print(paths)\n        [Path(\u0027./example.txt\u0027), Path(\u0027./readme.md\u0027)]\n    \"\"\"\n    try:\n        file_paths \u003d []\n        patterns \u003d [patterns] if isinstance(patterns, str) else patterns\n        for pattern in patterns:\n            file_paths.extend(Path(root_dir).rglob(pattern))\n        return file_paths\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при рекурсивном поиске файлов в \\\u0027{root_dir}\\\u0027.\u0027, ex)\n        return []\n\n\ndef recursively_read_text_files(\n    root_dir: str | Path,\n    patterns: str | list[str],\n    as_list: bool \u003d False\n) -\u003e list[str]:\n    \"\"\"\n    Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.\n\n    Args:\n        root_dir (str | Path): Путь к корневой директории для поиска.\n        patterns (str | list[str]): Шаблон(ы) имени файла для фильтрации.\n             Может быть как одиночным шаблоном (например, \u0027*.txt\u0027), так и списком.\n        as_list (bool, optional): Если True, то возвращает содержимое файла как список строк.\n             По умолчанию `False`.\n\n    Returns:\n        list[str]: Список содержимого файлов (или список строк, если `as_list\u003dTrue`),\n         соответствующих заданным шаблонам.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e root_dir \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e contents \u003d recursively_read_text_files(root_dir, [\u0027*.txt\u0027, \u0027*.md\u0027], as_list\u003dTrue)\n        \u003e\u003e\u003e for line in contents:\n        ...     print(line)\n        Содержимое example.txt\n        Первая строка readme.md\n        Вторая строка readme.md\n    \"\"\"\n    matches \u003d []\n    root_path \u003d Path(root_dir)\n\n    if not root_path.is_dir():\n        logger.debug(f\u0027Корневая директория \\\u0027{root_path}\\\u0027 не существует или не является директорией.\u0027)\n        return []\n\n    print(f\u0027Поиск в директории: {root_path}\u0027)\n\n    if isinstance(patterns, str):\n        patterns \u003d [patterns]\n\n    for root, _, files in os.walk(root_path):\n        for filename in files:\n            if any(fnmatch.fnmatch(filename, pattern) for pattern in patterns):\n                file_path \u003d Path(root) / filename\n\n                try:\n                    with file_path.open(\u0027r\u0027, encoding \u003d \u0027utf-8\u0027) as file:\n                        if as_list:\n                            matches.extend(file.readlines())\n                        else:\n                            matches.append(file.read())\n                except Exception as ex:\n                    logger.error(f\u0027Ошибка при чтении файла \\\u0027{file_path}\\\u0027.\u0027, ex)\n\n    return matches\n\n\ndef get_directory_names(directory: str | Path) -\u003e list[str]:\n    \"\"\"\n    Возвращает список имен директорий из указанной директории.\n\n    Args:\n        directory (str | Path): Путь к директории, из которой нужно получить имена.\n\n    Returns:\n        list[str]: Список имен директорий, найденных в указанной директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e directory \u003d Path(\u0027.\u0027)\n        \u003e\u003e\u003e get_directory_names(directory)\n        [\u0027dir1\u0027, \u0027dir2\u0027]\n    \"\"\"\n    try:\n        return [entry.name for entry in Path(directory).iterdir() if entry.is_dir()]\n    except Exception as ex:\n        logger.error(f\u0027Ошибка при получении списка имен директорий из \\\u0027{directory}\\\u0027.\u0027, ex)\n        return []\n\n\ndef remove_bom(path: str | Path) -\u003e None:\n    \"\"\"\n    Удаляет BOM из текстового файла или из всех файлов Python в директории.\n\n    Args:\n        path (str | Path): Путь к файлу или директории.\n\n    Example:\n        \u003e\u003e\u003e from pathlib import Path\n        \u003e\u003e\u003e file_path \u003d Path(\u0027example.txt\u0027)\n        \u003e\u003e\u003e with open(file_path, \u0027w\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n        ...     f.write(\u0027\\ufeffПример текста с BOM\u0027)\n        \u003e\u003e\u003e remove_bom(file_path)\n        \u003e\u003e\u003e with open(file_path, \u0027r\u0027, encoding\u003d\u0027utf-8\u0027) as f:\n        ...     print(f.read())\n        Пример текста с BOM\n    \"\"\"\n    path \u003d Path(path)\n    if path.is_file():\n        try:\n            with path.open(\u0027r+\u0027, encoding \u003d \u0027utf-8\u0027) as file:\n                content \u003d file.read().replace(\u0027\\ufeff\u0027, \u0027\u0027)\n                file.seek(0)\n                file.write(content)\n                file.truncate()\n        except Exception as ex:\n            logger.error(f\u0027Ошибка при удалении BOM из файла {path}.\u0027, ex)\n            ...\n    elif path.is_dir():\n        for root, _, files in os.walk(path):\n             for file in files:\n                 if file.endswith(\u0027.py\u0027):\n                    file_path \u003d Path(root) / file\n                    try:\n                        with file_path.open(\u0027r+\u0027, encoding \u003d \u0027utf-8\u0027) as f:\n                            content \u003d f.read().replace(\u0027\\ufeff\u0027, \u0027\u0027)\n                            f.seek(0)\n                            f.write(content)\n                            f.truncate()\n                    except Exception as ex:\n                       logger.error(f\u0027Ошибка при удалении BOM из файла {file_path}.\u0027, ex)\n                       ...\n\n    else:\n        logger.error(f\u0027Указанный путь \\\u0027{path}\\\u0027 не является файлом или директорией.\u0027)\n        ...\n\n\n\ndef main() -\u003e None:\n    \"\"\"Entry point for BOM removal in Python files.\"\"\"\n    root_dir \u003d Path(\u0027..\u0027, \u0027src\u0027)\n    logger.info(f\u0027Starting BOM removal in {root_dir}\u0027)\n    remove_bom(root_dir)\n\n\n\nif __name__ \u003d\u003d \u0027__main__\u0027:\n    main()\n```\n\nВнесены изменения в функции `read_text_file`, `_read_file_content`, и `_read_file_lines_generator`.  Теперь они используют `re.sub` для удаления лишних пробелов и  `replace` для экранирования кавычек.  Обратите внимание, что обработка происходит как для всего содержимого файла, так и для каждой строки в генераторе.  Это обеспечивает корректную обработку независимо от того, возвращается строка или генератор.  Функция `read_text_file` теперь также принимает аргумент `chunk_size` для большей гибкости.\n\n\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 6229
    }, {
      "text": "Обясни подробней что делает каждая функция. ",
      "role": "user",
      "tokenCount": 13
    }, {
      "text": "Давайте разберем каждую функцию в предоставленном коде Python, подробно описывая её назначение, входные и выходные данные, а также логику работы.\n\n**1. `save_text_file(data, file_path, mode\u003d\u0027w\u0027)`**\n\n* **Назначение:**  Записывает данные в указанный текстовый файл.  Поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).\n* **Входные данные:**\n    * `data (str | list[str] | dict)`: Данные для записи в файл.  Может быть строкой, списком строк или словарем.\n    * `file_path (str | Path)`: Путь к файлу, куда нужно записать данные.  Может быть строкой или объектом `Path` из библиотеки `pathlib`.\n    * `mode (str, optional)`: Режим открытия файла.  По умолчанию `\u0027w\u0027` (запись, перезаписывает файл).  Можно использовать `\u0027a\u0027` (добавление, добавляет данные в конец файла).\n* **Выходные данные:**\n    * `bool`: `True`, если запись прошла успешно, `False` в случае ошибки.\n* **Логика:**\n    1. Создает директории, если они не существуют, используя `file_path.parent.mkdir(parents\u003dTrue, exist_ok\u003dTrue)`.\n    2. Открывает файл в указанном режиме с кодировкой UTF-8.\n    3. В зависимости от типа данных `data`:\n        * Если это строка, записывает её в файл.\n        * Если это список строк, записывает каждую строку с добавлением символа новой строки (`\\n`).\n        * Если это словарь, сериализует его в JSON с отступами для читаемости и записывает в файл.\n    4. Возвращает `True` при успешной записи, `False` и логирует ошибку при возникновении исключения.\n\n\n**2. `read_text_file_generator(file_path, as_list\u003dFalse, extensions\u003dNone, chunk_size\u003d8192, recursive\u003dFalse, patterns\u003dNone)`**\n\n* **Назначение:** Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов.  Поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.\n* **Входные данные:**\n    * `file_path (str | Path)`: Путь к файлу или директории.\n    * `as_list (bool, optional)`:  Если `True`, возвращает генератор строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).\n    * `extensions (list[str], optional)`: Список расширений файлов для фильтрации при чтении директории.\n    * `chunk_size (int, optional)`: Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.\n    * `recursive (bool, optional)`:  Если `True`, рекурсивно обходит все поддиректории.\n    * `patterns (str | list[str], optional)`: Шаблоны для фильтрации файлов (например, `\u0027*.txt\u0027`, `[\u0027*.txt\u0027, \u0027*.csv\u0027]`).  Используется вместе с `recursive`.\n* **Выходные данные:**\n    * `Generator[str, None, None] | str | list[str] | None`:  Возвращает генератор строк (`as_list\u003dTrue`), строку (`as_list\u003dFalse` и файл), объединенную строку из всех файлов директории (`as_list\u003dFalse` и директория), или `None` в случае ошибки.\n* **Логика:**\n    1. Проверяет, является ли `file_path` файлом или директорией.\n    2. Для файлов:\n        * Если `as_list\u003dTrue`, использует `_read_file_lines_generator` для возврата генератора строк.\n        * Если `as_list\u003dFalse`, использует `_read_file_content` для возврата всего содержимого как строки.\n    3. Для директорий:\n        * Если `recursive\u003dTrue`, рекурсивно находит все файлы, соответствующие `patterns` и `extensions`, и обрабатывает их.\n        * Если `recursive\u003dFalse`, обрабатывает только файлы в текущей директории.\n        * Если `as_list\u003dTrue`, возвращает генератор, объединяющий строки из всех файлов.\n        * Если `as_list\u003dFalse`, возвращает объединенную строку из всех файлов.\n    4. Возвращает `None` при ошибках и логирует их.\n\n\n**3. `read_text_file(file_path, as_list\u003dFalse, extensions\u003dNone, exc_info\u003dTrue, chunk_size\u003d8192)`**\n\n* **Назначение:**  Читает содержимое файла или директории.  Более простая версия, чем `read_text_file_generator`, не использующая генераторы.\n* **Входные данные:**  Аналогичны `read_text_file_generator`, но без `recursive` и `patterns`.\n* **Выходные данные:** `str | list[str] | None`: Строка (если `as_list\u003dFalse`) или список строк (если `as_list\u003dTrue`).  `None` в случае ошибки.\n* **Логика:**  Проще, чем `read_text_file_generator`. Для директорий рекурсивно считывает все файлы, соответствующие `extensions`, и объединяет их содержимое в одну строку или список строк.\n\n\n**4. `yield_text_from_files(file_path, as_list\u003dFalse, chunk_size\u003d8192)`**\n\n* **Назначение:**  Читает файл и возвращает его содержимое как генератор строк (`as_list\u003dTrue`) или как одну строку (`as_list\u003dFalse`).  Вспомогательная функция для `read_text_file_generator`.\n* **Входные данные:**\n    * `file_path (str | Path)`: Путь к файлу.\n    * `as_list (bool, optional)`: Флаг, указывающий на возврат генератора или строки.\n    * `chunk_size (int, optional)`: Размер чанка для чтения.\n* **Выходные данные:** `Generator[str, None, None] | str | None`:  Генератор строк или строка, или `None` при ошибке.\n* **Логика:**  Использует `_read_file_lines_generator` или `_read_file_content` в зависимости от значения `as_list`.\n\n\n**5. `_read_file_content(file_path, chunk_size)`**\n\n* **Назначение:** Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки.  Используется для повышения эффективности при работе с очень большими файлами.\n* **Входные данные:**\n    * `file_path (Path)`: Путь к файлу.\n    * `chunk_size (int)`: Размер чанка.\n* **Выходные данные:** `str`:  Содержимое файла как одна строка.\n* **Логика:** Читает файл по частям размером `chunk_size`, накапливая данные в переменной `content`, и возвращает итоговую строку.  Обрабатывает лишние пробелы и экранирует кавычки.\n\n\n**6. `_read_file_lines_generator(file_path, chunk_size)`**\n\n* **Назначение:** Вспомогательная функция для чтения файла построчно с помощью генератора.  Эффективна для больших файлов, поскольку не загружает весь файл в память сразу.\n* **Входные данные:**\n    * `file_path (Path)`: Путь к файлу.\n    * `chunk_size (int)`: Размер чанка.\n* **Выходные данные:** `Generator[str, None, None]`:  Генератор, который выдает строки файла по одной.\n* **Логика:**  Читает файл по чанкам, разделяет чанк на строки с помощью `splitlines()`.  Обрабатывает случай, когда последняя строка в чанке неполная –  добавляет к ней следующий символ из файла.  Обрабатывает лишние пробелы и экранирует кавычки в каждой строке.\n\n\n**7. `get_filenames_from_directory(directory, ext\u003d\u0027*\u0027)`**\n\n* **Назначение:**  Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.\n* **Входные данные:**\n    * `directory (str | Path)`: Путь к директории.\n    * `ext (str | list[str], optional)`: Расширение или список расширений файлов для фильтрации.\n* **Выходные данные:** `list[str]`:  Список имен файлов.\n* **Логика:**  Итерирует по файлам в директории и возвращает список имен тех файлов, которые соответствуют указанному расширению (или всем файлам, если `ext\u003d\u0027*\u0027`).\n\n\n**8. `recursively_yield_file_path(root_dir, patterns\u003d\u0027*\u0027)`**\n\n* **Назначение:**  Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.\n* **Входные данные:**\n    * `root_dir (str | Path)`: Корневая директория.\n    * `patterns (str | list[str])`: Шаблоны имен файлов (например, `\u0027*.txt\u0027`, `[\u0027*.txt\u0027, \u0027*.log\u0027]`).\n* **Выходные данные:** `Generator[Path, None, None]`:  Генератор, который выдает пути к файлам.\n* **Логика:** Использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.\n\n\n**9. `recursively_get_file_path(root_dir, patterns\u003d\u0027*\u0027)`**\n\n* **Назначение:**  Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.\n* **Входные данные:** Аналогичны `recursively_yield_file_path`.\n* **Выходные данные:** `list[Path]`: Список путей к файлам.\n* **Логика:**  Использует `Path.rglob()` и собирает все найденные пути в список.\n\n\n**10. `recursively_read_text_files(root_dir, patterns, as_list\u003dFalse)`**\n\n* **Назначение:** Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.\n* **Входные данные:**\n    * `root_dir (str | Path)`: Корневая директория.\n    * `patterns (str | list[str])`: Шаблоны имен файлов.\n    * `as_list (bool, optional)`:  Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.\n* **Выходные данные:** `list[str]`: Список содержимого файлов (либо список списков строк).\n* **Логика:**  Использует `os.walk()` для рекурсивного обхода директории.  Читает файлы, соответствующие шаблонам, и добавляет их содержимое в результирующий список.\n\n\n**11. `get_directory_names(directory)`**\n\n* **Назначение:**  Возвращает список имен поддиректорий в указанной директории.\n* **Входные данные:** `directory (str | Path)`: Путь к директории.\n* **Выходные данные:** `list[str]`: Список имен поддиректорий.\n* **Логика:** Итерирует по элементам в директории и возвращает список имен только тех, которые являются директориями.\n\n\n**12. `remove_bom(path)`**\n\n* **Назначение:** Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.  BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.\n* **Входные данные:** `path (str | Path)`: Путь к файлу или директории.\n* **Выходные данные:** `None`.\n* **Логика:**  Если `path` – файл, удаляет BOM из него.  Если `path` – директория, рекурсивно обходит все `.py` файлы и удаляет BOM из них.\n\n\n**13. `main()`**\n\n* **Назначение:**  Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.\n* **Входные данные:**  Нет.\n* **Выходные данные:** `None`.\n* **Логика:** Вызывает `remove_bom()` для директории `src`.\n\n\nВ целом, модуль `file.py` предоставляет набор полезных функций для работы с файлами и директориями, включая обработку больших файлов с помощью генераторов и рекурсивный поиск файлов.  Функции хорошо структурированы и имеют ясное назначение.  Добавленные функции обработки лишних пробелов и экранирования кавычек улучшают функциональность.\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 3072
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}