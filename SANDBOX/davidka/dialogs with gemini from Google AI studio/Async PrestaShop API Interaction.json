{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.0-flash-exp",
    "candidateCount": 1,
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false
  },
  "systemInstruction": {
    "text": "\"\"\"\nModule for interacting with the PrestaShop API\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nThis module provides a class, `PrestaShop`, to interact with the PrestaShop webservice API,\nusing JSON and XML for message formatting. It supports CRUD operations, searching,\nand uploading images, with error handling for responses.\n\nExample usage\n-------------\n\n.. code-block:: python\n\n    from src.endpoints.prestashop.api.api import PrestaShop\n\n    api \u003d PrestaShop(\n        API_DOMAIN\u003d\u0027https://your-prestashop-domain.com\u0027,\n        API_KEY\u003d\u0027your_api_key\u0027,\n        default_lang\u003d1,\n        debug\u003dTrue,\n        data_format\u003d\u0027JSON\u0027,\n    )\n\n    api.ping()\n\n    data \u003d {\n        \u0027tax\u0027: {\n            \u0027rate\u0027: 3.000,\n            \u0027active\u0027: \u00271\u0027,\n            \u0027name\u0027: {\n                \u0027language\u0027: {\n                    \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                    \u0027value\u0027: \u00273% tax\u0027\n                }\n            }\n        }\n    }\n\n    # Create tax record\n    rec \u003d api.create(\u0027taxes\u0027, data)\n\n    # Update the same tax record\n    update_data \u003d {\n        \u0027tax\u0027: {\n            \u0027id\u0027: str(rec[\u0027id\u0027]),\n            \u0027rate\u0027: 3.000,\n            \u0027active\u0027: \u00271\u0027,\n            \u0027name\u0027: {\n                \u0027language\u0027: {\n                    \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                    \u0027value\u0027: \u00273% tax\u0027\n                }\n            }\n        }\n    }\n\n    update_rec \u003d api.write(\u0027taxes\u0027, update_data)\n\n    # Remove this tax\n    api.unlink(\u0027taxes\u0027, str(rec[\u0027id\u0027]))\n\n    # Search the first 3 taxes with \u00275\u0027 in the name\n    import pprint\n    recs \u003d api.search(\u0027taxes\u0027, filter\u003d\u0027[name]\u003d%[5]%\u0027, limit\u003d\u00273\u0027)\n\n    for rec in recs:\n        pprint(rec)\n\n    # Create binary (product image)\n    api.create_binary(\u0027images/products/22\u0027, \u0027img.jpeg\u0027, \u0027image\u0027)\n\"\"\"\n# -*- coding: utf-8 -*-\n\n#! venv/bin/python/python3.12\n\nimport os\nimport sys\nfrom enum import Enum\nfrom http.client import HTTPConnection\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom xml.etree import ElementTree\nfrom xml.parsers.expat import ExpatError\n\nfrom requests import Session\nfrom requests.models import PreparedRequest\n\nimport header\nfrom src import gs\nfrom src.logger.exceptions import PrestaShopAuthenticationError, PrestaShopException\nfrom src.logger.logger import logger\nfrom src.utils.convertors.base64 import base64_to_tmpfile\nfrom src.utils.convertors.dict import dict2xml\nfrom src.utils.convertors.xml2dict import xml2dict\nfrom src.utils.file import save_text_file\nfrom src.utils.image import save_image_from_url\nfrom src.utils.jjson import j_dumps, j_loads, j_loads_ns\nfrom src.utils.printer import pprint\n\n\n\n\nclass Format(Enum):\n    \"\"\"Data types return (JSON, XML)\n\n    .. deprecated::\n        I prefer JSON üëç :))\n\n    :param Enum: (int): 1 \u003d\u003e JSON, 2 \u003d\u003e XML\n    \"\"\"\n    JSON \u003d \u0027JSON\u0027\n    XML \u003d \u0027XML\u0027\n\n\nclass PrestaShop:\n    \"\"\" Interact with PrestaShop webservice API, using JSON and XML for message\n\n    This class provides methods to interact with the PrestaShop API, allowing for CRUD\n    operations, searching, and uploading images. It also provides error handling\n    for responses and methods to handle the API\u0027s data.\n\n    :param API_KEY: The API key generated from PrestaShop.\n    :type API_KEY: str\n    :param API_DOMAIN: The domain of the PrestaShop shop (e.g., https://myPrestaShop.com).\n    :type API_DOMAIN: str\n    :param data_format: Default data format (\u0027JSON\u0027 or \u0027XML\u0027). Defaults to \u0027JSON\u0027.\n    :type data_format: str\n    :param default_lang: Default language ID. Defaults to 1.\n    :type default_lang: int\n    :param debug: Activate debug mode. Defaults to True.\n    :type debug: bool\n\n    :raises PrestaShopAuthenticationError: When the API key is wrong or does not exist.\n    :raises PrestaShopException: For generic PrestaShop WebServices errors.\n    \"\"\"\n    client: Session \u003d Session()\n    debug \u003d True\n    language: Optional[int] \u003d None\n    data_format \u003d \u0027JSON\u0027\n    ps_version \u003d \u0027\u0027\n\n    def __init__(self,\n                 data_format: str \u003d \u0027JSON\u0027,\n                 default_lang: int \u003d 1,\n                 debug: bool \u003d True) -\u003e None:\n        \"\"\"Initialize the PrestaShop class.\n\n        :param data_format: Default data format (\u0027JSON\u0027 or \u0027XML\u0027). Defaults to \u0027JSON\u0027.\n        :type data_format: str\n        :param default_lang: Default language ID. Defaults to 1.\n        :type default_lang: int\n        :param debug: Activate debug mode. Defaults to True.\n        :type debug: bool\n        \"\"\"\n        self.API_DOMAIN \u003d gs.credentials.presta.client.api_key.rstrip(\u0027/\u0027) + \u0027/api/\u0027\n        self.API_KEY \u003d gs.credentials.presta.client.api_key\n        self.debug \u003d debug\n        self.language \u003d default_lang\n        self.data_format \u003d data_format\n\n        if not self.client.auth:\n            self.client.auth \u003d (self.API_KEY, \u0027\u0027)\n\n        response \u003d self.client.request(\n            method\u003d\u0027HEAD\u0027,\n            url\u003dself.API_DOMAIN\n        )\n\n        self.ps_version \u003d response.headers.get(\u0027psws-version\u0027)\n\n    def ping(self) -\u003e bool:\n        \"\"\"Test if the webservice is working perfectly.\n\n        :return: Result of the ping test. Returns `True` if the webservice is working, otherwise `False`.\n        :rtype: bool\n        \"\"\"\n        response \u003d self.client.request(\n            method\u003d\u0027HEAD\u0027,\n            url\u003dself.API_DOMAIN\n        )\n\n        return self._check_response(response.status_code, response)\n\n    def _check_response(self, status_code: int, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                        headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None) -\u003e bool:\n        \"\"\"Check the response status code and handle errors.\n\n        :param status_code: HTTP response status code.\n        :type status_code: int\n        :param response: HTTP response object.\n        :type response: requests.Response\n        :param method: HTTP method used for the request.\n        :type method: str, optional\n        :param url: The URL of the request.\n        :type url: str, optional\n        :param headers: The headers used in the request.\n        :type headers: dict, optional\n        :param data: The data sent in the request.\n        :type data: dict, optional\n\n        :return: `True` if the status code is 200 or 201, otherwise `False`.\n        :rtype: bool\n        \"\"\"\n        if status_code in (200, 201):\n            return True\n        else:\n            self._parse_response_error(response, method, url, headers, data)\n            return False\n\n    def _parse_response_error(self, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                              headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None):\n        \"\"\"Parse the error response from PrestaShop API.\n\n        :param response: HTTP response object from the server.\n        :type response: requests.Response\n        \"\"\"\n        if self.data_format \u003d\u003d \u0027JSON\u0027:\n            status_code \u003d response.status_code\n            if not status_code in (200, 201):\n                logger.critical(f\"\"\"response status code: {status_code}\n                    url: {response.request.url}\n                    --------------\n                    headers: {response.headers}\n                    --------------\n                    response text: {response.text}\"\"\")\n            return response\n        else:\n            error_answer \u003d self._parse(response.text)\n            if isinstance(error_answer, dict):\n                error_content \u003d (error_answer\n                                 .get(\u0027PrestaShop\u0027, {})\n                                 .get(\u0027errors\u0027, {})\n                                 .get(\u0027error\u0027, {}))\n                if isinstance(error_content, list):\n                    error_content \u003d error_content[0]\n                code \u003d error_content.get(\u0027code\u0027)\n                message \u003d error_content.get(\u0027message\u0027)\n            elif isinstance(error_answer, ElementTree.Element):\n                error \u003d error_answer.find(\u0027errors/error\u0027)\n                code \u003d error.find(\u0027code\u0027).text\n                message \u003d error.find(\u0027message\u0027).text\n            logger.error(f\u0027XML response error: {message} \\n Code: {code}\u0027)\n            return code, message\n\n    def _prepare(self, url: str, params: dict) -\u003e str:\n        \"\"\"Prepare the URL for the request.\n\n        :param url: The base URL.\n        :type url: str\n        :param params: The parameters for the request.\n        :type params: dict\n\n        :return: The prepared URL with parameters.\n        :rtype: str\n        \"\"\"\n        req \u003d PreparedRequest()\n        req.prepare_url(url, params)\n        return req.url\n\n    def _exec(self,\n              resource: str,\n              resource_id: Optional[Union[int, str]] \u003d None,\n              resource_ids: Optional[Union[int, Tuple[int]]] \u003d None,\n              method: str \u003d \u0027GET\u0027,\n              data: Optional[dict] \u003d None,\n              headers: Optional[dict] \u003d None,\n              search_filter: Optional[Union[str, dict]] \u003d None,\n              display: Optional[Union[str, list]] \u003d \u0027full\u0027,\n              schema: Optional[str] \u003d None,\n              sort: Optional[str] \u003d None,\n              limit: Optional[str] \u003d None,\n              language: Optional[int] \u003d None,\n              io_format: str \u003d \u0027JSON\u0027) -\u003e Optional[dict]:\n        \"\"\"Execute an HTTP request to the PrestaShop API.\n\n        :param resource: The API resource (e.g., \u0027products\u0027, \u0027categories\u0027).\n        :type resource: str\n        :param resource_id: The ID of the resource.\n        :type resource_id: int | str, optional\n        :param resource_ids: The IDs of multiple resources.\n        :type resource_ids: int | tuple, optional\n        :param method: The HTTP method (GET, POST, PUT, DELETE).\n        :type method: str, optional\n        :param data: The data to be sent with the request.\n        :type data: dict, optional\n        :param headers: Additional headers for the request.\n        :type headers: dict, optional\n        :param search_filter: Filter for the request.\n        :type search_filter: str | dict, optional\n        :param display: Fields to display in the response.\n        :type display: str | list, optional\n        :param schema: The schema of the data.\n        :type schema: str, optional\n        :param sort: Sorting parameter for the request.\n        :type sort: str, optional\n        :param limit: Limit of results for the request.\n        :type limit: str, optional\n        :param language: The language ID for the request.\n        :type language: int, optional\n        :param io_format: The data format (\u0027JSON\u0027 or \u0027XML\u0027).\n        :type io_format: str, optional\n\n        :return: The response from the API or `False` on failure.\n        :rtype: dict | None\n        \"\"\"\n        if self.debug:\n            import sys\n            original_stderr \u003d sys.stderr\n            f \u003d open(\u0027stderr.log\u0027, \u0027w\u0027)\n            sys.stderr \u003d f\n\n            response \u003d self.client.request(\n                method\u003dmethod,\n                url\u003dself._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format}),\n                data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,\n                headers\u003dheaders,\n            )\n\n            sys.stderr \u003d original_stderr\n\n        if not self._check_response(response.status_code, response, method, url, headers, data):\n            return False\n\n        if io_format \u003d\u003d \u0027JSON\u0027:\n            return response.json()\n        else:\n            return self._parse(response.text)\n\n    def _parse(self, text: str) -\u003e Union[dict, ElementTree.Element, bool]:\n        \"\"\"Parse XML or JSON response from the API.\n\n        :param text: Response text.\n        :type text: str\n\n        :return: Parsed data or `False` on failure.\n        :rtype: dict | ElementTree.Element | bool\n        \"\"\"\n        try:\n            if self.data_format \u003d\u003d \u0027JSON\u0027:\n                data \u003d response.json()\n                return data.get(\u0027PrestaShop\u0027, {}) if \u0027PrestaShop\u0027 in data else data\n            else:\n                tree \u003d ElementTree.fromstring(text)\n                return tree\n        except (ExpatError, ValueError) as ex:\n            logger.error(f\u0027Parsing Error: {str(ex)}\u0027)\n            return False\n\n    def create(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"Create a new resource in PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param data: Data for the new resource.\n        :type data: dict\n\n        :return: Response from the API.\n        :rtype: dict\n        \"\"\"\n        return self._exec(resource\u003dresource, method\u003d\u0027POST\u0027, data\u003ddata, io_format\u003dself.data_format)\n\n    def read(self, resource: str, resource_id: Union[int, str], **kwargs) -\u003e Optional[dict]:\n        \"\"\"Read a resource from the PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param resource_id: Resource ID.\n        :type resource_id: int | str\n\n        :return: Response from the API.\n        :rtype: dict\n        \"\"\"\n        return self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    def write(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"Update an existing resource in the PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param data: Data for the resource.\n        :type data: dict\n\n        :return: Response from the API.\n        :rtype: dict\n        \"\"\"\n        return self._exec(resource\u003dresource, resource_id\u003ddata.get(\u0027id\u0027), method\u003d\u0027PUT\u0027, data\u003ddata,\n                          io_format\u003dself.data_format)\n\n    def unlink(self, resource: str, resource_id: Union[int, str]) -\u003e bool:\n        \"\"\"Delete a resource from the PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param resource_id: Resource ID.\n        :type resource_id: int | str\n\n        :return: `True` if successful, `False` otherwise.\n        :rtype: bool\n        \"\"\"\n        return self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027DELETE\u0027, io_format\u003dself.data_format)\n\n    def search(self, resource: str, filter: Optional[Union[str, dict]] \u003d None, **kwargs) -\u003e List[dict]:\n        \"\"\"Search for resources in the PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param filter: Filter for the search.\n        :type filter: str | dict, optional\n\n        :return: List of resources matching the search criteria.\n        :rtype: List[dict]\n        \"\"\"\n        return self._exec(resource\u003dresource, search_filter\u003dfilter, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    def create_binary(self, resource: str, file_path: str, file_name: str) -\u003e dict:\n        \"\"\"Upload a binary file to a PrestaShop API resource.\n\n        :param resource: API resource (e.g., \u0027images/products/22\u0027).\n        :type resource: str\n        :param file_path: Path to the binary file.\n        :type file_path: str\n        :param file_name: File name.\n        :type file_name: str\n\n        :return: Response from the API.\n        :rtype: dict\n        \"\"\"\n        with open(file_path, \u0027rb\u0027) as file:\n            headers \u003d {\u0027Content-Type\u0027: \u0027application/octet-stream\u0027}\n            response \u003d self.client.post(\n                url\u003df\u0027{self.API_DOMAIN}{resource}\u0027,\n                headers\u003dheaders,\n                data\u003dfile.read()\n            )\n            return response.json()\n\n    def _save(self, file_name: str, data: dict):\n        \"\"\"Save data to a file.\n\n        :param file_name: Name of the file.\n        :type file_name: str\n        :param data: Data to be saved.\n        :type data: dict\n        \"\"\"\n        save_text_file(file_name, j_dumps(data, indent\u003d4, ensure_ascii\u003dFalse))\n\n    def get_data(self, resource: str, **kwargs) -\u003e Optional[dict]:\n        \"\"\"Fetch data from a PrestaShop API resource and save it.\n\n        :param resource: API resource (e.g., \u0027products\u0027).\n        :type resource: str\n        :param **kwargs: Additional arguments for the API request.\n\n        :return: Data from the API or `False` on failure.\n        :rtype: dict | None\n        \"\"\"\n        data \u003d self._exec(resource\u003dresource, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n        if data:\n            self._save(f\u0027{resource}.json\u0027, data)\n            return data\n        return False\n\n    def remove_file(self, file_path: str):\n        \"\"\"Remove a file from the filesystem.\n\n        :param file_path: Path to the file.\n        :type file_path: str\n        \"\"\"\n        try:\n            os.remove(file_path)\n        except Exception as e:\n            logger.error(f\u0027Error removing file {file_path}: {e}\u0027)\n\n    def get_apis(self) -\u003e Optional[dict]:\n        \"\"\"Get a list of all available APIs.\n\n        :return: List of available APIs.\n        :rtype: dict\n        \"\"\"\n        return self._exec(\u0027apis\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n\n    def get_languages_schema(self) -\u003e Optional[dict]:\n        \"\"\"Get the schema for languages.\n\n        :return: Language schema or `None` on failure.\n        :rtype: dict\n        \"\"\"\n        try:\n            response \u003d self._exec(\u0027languages\u0027, display\u003d\u0027full\u0027, io_format\u003d\u0027JSON\u0027)\n            return response\n        except Exception as ex:\n            logger.error(f\u0027Error: {ex}\u0027)\n            return\n\n    def upload_image_async(self, resource: str, resource_id: int, img_url: str,\n                           img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"Upload an image to PrestaShop API asynchronously.\n\n        :param resource: API resource (e.g., \u0027images/products/22\u0027).\n        :type resource: str\n        :param resource_id: Resource ID.\n        :type resource_id: int\n        :param img_url: URL of the image.\n        :type img_url: str\n        :param img_name: Name of the image file, defaults to None.\n        :type img_name: str, optional\n\n        :return: Response from the API or `False` on failure.\n        :rtype: dict | None\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d save_image_from_url(img_url, filename)\n        response \u003d self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    def upload_image(self, resource: str, resource_id: int, img_url: str,\n                     img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"Upload an image to PrestaShop API.\n\n        :param resource: API resource (e.g., \u0027images/products/22\u0027).\n        :type resource: str\n        :param resource_id: Resource ID.\n        :type resource_id: int\n        :param img_url: URL of the image.\n        :type img_url: str\n        :param img_name: Name of the image file, defaults to None.\n        :type img_name: str, optional\n\n        :return: Response from the API or `False` on failure.\n        :rtype: dict | None\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d save_image_from_url(img_url, filename)\n        response \u003d self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    def get_product_images(self, product_id: int) -\u003e Optional[dict]:\n        \"\"\"Get images for a product.\n\n        :param product_id: Product ID.\n        :type product_id: int\n\n        :return: List of product images or `False` on failure.\n        :rtype: dict | None\n        \"\"\"\n        return self._exec(f\u0027products/{product_id}/images\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n\n\n\n\n–∏—Å–ø—Ä–∞–≤—å docstrings –ø–æ —Ç–∞–∫–æ–º—É –ø—Ä–∏–º–µ—Ä—É:\n–ü—Ä–∏–º–µ—Ä –æ—Ñ–æ—Ä–º–ª–µ–º–∏—è docstring\n\nclass PrestaCategoryAsync(PrestaShopAsync):\n    \"\"\"! Async Class for managing categories in PrestaShop.\n\n    Example usage:\n\n    .. code-block:: python\n\n        async def main():\n            prestacategory \u003d PrestaCategoryAsync(API_DOMAIN\u003dAPI_DOMAIN, API_KEY\u003dAPI_KEY)\n            await prestacategory.add_category(\u0027New Category\u0027, \u0027Parent Category\u0027)\n            await prestacategory.delete_category(3)\n            await prestacategory.update_category(4, \u0027Updated Category Name\u0027)\n            print(await prestacategory.get_parent_categories_list(5))\n\n        if __name__ \u003d\u003d \"__main__\":\n            asyncio.run(main())\n    \"\"\"\n\n    def __init__(self,\n                 credentials: Optional[Union[dict, SimpleNamespace]] \u003d None,\n                 api_domain: Optional[str] \u003d None,\n                 api_key: Optional[str] \u003d None,\n                 *args, **kwargs):\n        \"\"\"! Initialize PrestaShop category instance asynchronously.\n\n        Args:\n            credentials (Optional[dict | SimpleNamespace], optional): Dictionary or SimpleNamespace object with `api_domain` and `api_key` parameters. Defaults to None.\n            api_domain (Optional[str], optional): API domain. Defaults to None.\n            api_key (Optional[str], optional): API key. Defaults to None.\n\n        Raises:\n            ValueError: Raised when both `api_domain` and `api_key` are not provided.\n        \"\"\"\n\n        if credentials is not None:\n            api_domain \u003d credentials.get(\u0027api_domain\u0027, api_domain)\n            api_key \u003d credentials.get(\u0027api_key\u0027, api_key)\n\n        if not api_domain or not api_key:\n            raise ValueError(\u0027Both api_domain and api_key parameters are required.\u0027)\n\n        super().__init__(api_domain, api_key, *args, **kwargs)\n\n\n    async def get_parent_categories_list(self, id_category: Union[str, int], parent_categories_list: List[int] \u003d []) -\u003e list:\n        \"\"\"! Retrieve parent categories from PrestaShop for a given category asynchronously.\n\n        Args:\n            id_category (str | int): Category ID for which parent categories need to be retrieved.\n            parent_categories_list (List[int], optional): List of parent category IDs. Defaults to an empty list.\n\n        Returns:\n            list: List of parent category IDs.\n\n        Raises:\n            ValueError: Raised when the given category ID does not exist in PrestaShop.\n        \"\"\"\n\n        if not id_category:\n            logger.error(\n                f\"\"\"Missing category ID!!!\n                Current parent categories list: {parent_categories_list}\n                If a request is sent without an ID, a dictionary with all categories will be returned.\"\"\"\n            )\n            return parent_categories_list\n\n        category \u003d await super().read(\u0027categories\u0027, resource_id\u003did_category, display\u003d\u0027full\u0027, io_format\u003d\u0027JSON\u0027)\n\n        if not category:\n            logger.error(\u0027There is an issue with the categories.\u0027)\n            return\n\n        _parent_category: int \u003d int(category[\u0027category\u0027][\u0027id_parent\u0027])\n        parent_categories_list.append(_parent_category)\n\n        if _parent_category \u003c\u003d 2:  # `2` is the root directory ID\n            return parent_categories_list\n        else:\n            return await self.get_parent_categories_list(_parent_category, parent_categories_list)\n"
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "–°–¥–µ–ª–∞–π –∫–æ–¥ –∏–∑ —Å–∏–∞—Ç–∞–º–Ω–æ–π –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º, docstring –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–∞–∫ –≤ –ø—Ä–∏–º–µ—Ä–µ –∏–∑ —Å–∏—Å—Ç–µ–º–æ–π–Ω –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏",
      "role": "user",
      "tokenCount": 30
    }, {
      "text": "```python\nimport os\nimport sys\nfrom enum import Enum\nfrom http.client import HTTPConnection\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom xml.etree import ElementTree\nfrom xml.parsers.expat import ExpatError\n\nfrom requests import Session\nfrom requests.models import PreparedRequest\n\nimport header\nfrom src import gs\nfrom src.logger.exceptions import PrestaShopAuthenticationError, PrestaShopException\nfrom src.logger.logger import logger\nfrom src.utils.convertors.base64 import base64_to_tmpfile\nfrom src.utils.convertors.dict import dict2xml\nfrom src.utils.convertors.xml2dict import xml2dict\nfrom src.utils.file import save_text_file\nfrom src.utils.image import save_image_from_url\nfrom src.utils.jjson import j_dumps, j_loads, j_loads_ns\nfrom src.utils.printer import pprint\n\nimport asyncio\nimport aiohttp\nfrom aiohttp import ClientSession, ClientTimeout\n\n\nclass Format(Enum):\n    \"\"\"Data types return (JSON, XML)\n\n    .. deprecated::\n        I prefer JSON üëç :))\n\n    :param Enum: (int): 1 \u003d\u003e JSON, 2 \u003d\u003e XML\n    \"\"\"\n    JSON \u003d \u0027JSON\u0027\n    XML \u003d \u0027XML\u0027\n\n\nclass PrestaShopAsync:\n    \"\"\"! Async Class for interacting with the PrestaShop API using JSON and XML.\n\n    This class provides asynchronous methods to interact with the PrestaShop API,\n    allowing for CRUD operations, searching, and uploading images. It also provides\n    error handling for responses and methods to handle the API\u0027s data.\n\n    Example usage:\n\n    .. code-block:: python\n\n        async def main():\n            api \u003d PrestaShopAsync(\n                API_DOMAIN\u003d\u0027https://your-prestashop-domain.com\u0027,\n                API_KEY\u003d\u0027your_api_key\u0027,\n                default_lang\u003d1,\n                debug\u003dTrue,\n                data_format\u003d\u0027JSON\u0027,\n            )\n\n            await api.ping()\n\n            data \u003d {\n                \u0027tax\u0027: {\n                    \u0027rate\u0027: 3.000,\n                    \u0027active\u0027: \u00271\u0027,\n                    \u0027name\u0027: {\n                        \u0027language\u0027: {\n                            \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                            \u0027value\u0027: \u00273% tax\u0027\n                        }\n                    }\n                }\n            }\n\n            # Create tax record\n            rec \u003d await api.create(\u0027taxes\u0027, data)\n\n            # Update the same tax record\n            update_data \u003d {\n                \u0027tax\u0027: {\n                    \u0027id\u0027: str(rec[\u0027id\u0027]),\n                    \u0027rate\u0027: 3.000,\n                    \u0027active\u0027: \u00271\u0027,\n                    \u0027name\u0027: {\n                        \u0027language\u0027: {\n                            \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                            \u0027value\u0027: \u00273% tax\u0027\n                        }\n                    }\n                }\n            }\n\n            update_rec \u003d await api.write(\u0027taxes\u0027, update_data)\n\n            # Remove this tax\n            await api.unlink(\u0027taxes\u0027, str(rec[\u0027id\u0027]))\n\n            # Search the first 3 taxes with \u00275\u0027 in the name\n            import pprint\n            recs \u003d await api.search(\u0027taxes\u0027, filter\u003d\u0027[name]\u003d%[5]%\u0027, limit\u003d\u00273\u0027)\n\n            for rec in recs:\n                pprint(rec)\n\n            # Create binary (product image)\n            await api.create_binary(\u0027images/products/22\u0027, \u0027img.jpeg\u0027, \u0027image\u0027)\n\n        if __name__ \u003d\u003d \"__main__\":\n            asyncio.run(main())\n\n    \"\"\"\n    client: ClientSession \u003d None\n    debug \u003d True\n    language: Optional[int] \u003d None\n    data_format \u003d \u0027JSON\u0027\n    ps_version \u003d \u0027\u0027\n\n    def __init__(self,\n                 data_format: str \u003d \u0027JSON\u0027,\n                 default_lang: int \u003d 1,\n                 debug: bool \u003d True) -\u003e None:\n        \"\"\"! Initialize the PrestaShopAsync class.\n\n        Args:\n            data_format (str, optional): Default data format (\u0027JSON\u0027 or \u0027XML\u0027). Defaults to \u0027JSON\u0027.\n            default_lang (int, optional): Default language ID. Defaults to 1.\n            debug (bool, optional): Activate debug mode. Defaults to True.\n\n        Raises:\n            PrestaShopAuthenticationError: When the API key is wrong or does not exist.\n            PrestaShopException: For generic PrestaShop WebServices errors.\n        \"\"\"\n        self.API_DOMAIN \u003d gs.credentials.presta.client.api_key.rstrip(\u0027/\u0027) + \u0027/api/\u0027\n        self.API_KEY \u003d gs.credentials.presta.client.api_key\n        self.debug \u003d debug\n        self.language \u003d default_lang\n        self.data_format \u003d data_format\n\n        self.client \u003d ClientSession(\n            auth\u003daiohttp.BasicAuth(self.API_KEY, \u0027\u0027),\n            timeout\u003dClientTimeout(total\u003d60)\n        )\n\n\n    async def ping(self) -\u003e bool:\n        \"\"\"! Test if the webservice is working perfectly asynchronously.\n\n        Returns:\n            bool: Result of the ping test. Returns `True` if the webservice is working, otherwise `False`.\n        \"\"\"\n        async with self.client.request(\n            method\u003d\u0027HEAD\u0027,\n            url\u003dself.API_DOMAIN\n        ) as response:\n            return await self._check_response(response.status, response)\n\n    async def _check_response(self, status_code: int, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                        headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None) -\u003e bool:\n        \"\"\"! Check the response status code and handle errors asynchronously.\n\n        Args:\n            status_code (int): HTTP response status code.\n            response (aiohttp.ClientResponse): HTTP response object.\n            method (str, optional): HTTP method used for the request.\n            url (str, optional): The URL of the request.\n            headers (dict, optional): The headers used in the request.\n            data (dict, optional): The data sent in the request.\n\n        Returns:\n            bool: `True` if the status code is 200 or 201, otherwise `False`.\n        \"\"\"\n        if status_code in (200, 201):\n            return True\n        else:\n            await self._parse_response_error(response, method, url, headers, data)\n            return False\n\n    async def _parse_response_error(self, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                              headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None):\n        \"\"\"! Parse the error response from PrestaShop API asynchronously.\n\n        Args:\n            response (aiohttp.ClientResponse): HTTP response object from the server.\n            method (str, optional): HTTP method used for the request.\n            url (str, optional): The URL of the request.\n            headers (dict, optional): The headers used in the request.\n            data (dict, optional): The data sent in the request.\n        \"\"\"\n        if self.data_format \u003d\u003d \u0027JSON\u0027:\n            status_code \u003d response.status\n            if not status_code in (200, 201):\n                text \u003d await response.text()\n                logger.critical(f\"\"\"response status code: {status_code}\n                    url: {response.request_info.url}\n                    --------------\n                    headers: {response.headers}\n                    --------------\n                    response text: {text}\"\"\")\n            return response\n        else:\n            error_answer \u003d await self._parse(await response.text())\n            if isinstance(error_answer, dict):\n                error_content \u003d (error_answer\n                                 .get(\u0027PrestaShop\u0027, {})\n                                 .get(\u0027errors\u0027, {})\n                                 .get(\u0027error\u0027, {}))\n                if isinstance(error_content, list):\n                    error_content \u003d error_content[0]\n                code \u003d error_content.get(\u0027code\u0027)\n                message \u003d error_content.get(\u0027message\u0027)\n            elif isinstance(error_answer, ElementTree.Element):\n                error \u003d error_answer.find(\u0027errors/error\u0027)\n                code \u003d error.find(\u0027code\u0027).text\n                message \u003d error.find(\u0027message\u0027).text\n            logger.error(f\u0027XML response error: {message} \\n Code: {code}\u0027)\n            return code, message\n\n    def _prepare(self, url: str, params: dict) -\u003e str:\n        \"\"\"! Prepare the URL for the request.\n\n        Args:\n            url (str): The base URL.\n            params (dict): The parameters for the request.\n\n        Returns:\n            str: The prepared URL with parameters.\n        \"\"\"\n        req \u003d PreparedRequest()\n        req.prepare_url(url, params)\n        return req.url\n\n    async def _exec(self,\n              resource: str,\n              resource_id: Optional[Union[int, str]] \u003d None,\n              resource_ids: Optional[Union[int, Tuple[int]]] \u003d None,\n              method: str \u003d \u0027GET\u0027,\n              data: Optional[dict] \u003d None,\n              headers: Optional[dict] \u003d None,\n              search_filter: Optional[Union[str, dict]] \u003d None,\n              display: Optional[Union[str, list]] \u003d \u0027full\u0027,\n              schema: Optional[str] \u003d None,\n              sort: Optional[str] \u003d None,\n              limit: Optional[str] \u003d None,\n              language: Optional[int] \u003d None,\n              io_format: str \u003d \u0027JSON\u0027) -\u003e Optional[dict]:\n        \"\"\"! Execute an HTTP request to the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): The API resource (e.g., \u0027products\u0027, \u0027categories\u0027).\n            resource_id (int | str, optional): The ID of the resource.\n            resource_ids (int | tuple, optional): The IDs of multiple resources.\n            method (str, optional): The HTTP method (GET, POST, PUT, DELETE).\n            data (dict, optional): The data to be sent with the request.\n            headers (dict, optional): Additional headers for the request.\n            search_filter (str | dict, optional): Filter for the request.\n            display (str | list, optional): Fields to display in the response.\n            schema (str, optional): The schema of the data.\n            sort (str, optional): Sorting parameter for the request.\n            limit (str, optional): Limit of results for the request.\n            language (int, optional): The language ID for the request.\n            io_format (str, optional): The data format (\u0027JSON\u0027 or \u0027XML\u0027).\n\n        Returns:\n            dict | None: The response from the API or `False` on failure.\n        \"\"\"\n        if self.debug:\n            import sys\n            original_stderr \u003d sys.stderr\n            f \u003d open(\u0027stderr.log\u0027, \u0027w\u0027)\n            sys.stderr \u003d f\n\n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dself._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format}),\n                data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,\n                headers\u003dheaders,\n            ) as response:\n              \n              sys.stderr \u003d original_stderr\n              if not await self._check_response(response.status, response, method, url, headers, data):\n                  return False\n\n              if io_format \u003d\u003d \u0027JSON\u0027:\n                  return await response.json()\n              else:\n                  return await self._parse(await response.text())\n        else:\n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dself._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format}),\n                data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,\n                headers\u003dheaders,\n            ) as response:\n              if not await self._check_response(response.status, response, method, url, headers, data):\n                  return False\n\n              if io_format \u003d\u003d \u0027JSON\u0027:\n                  return await response.json()\n              else:\n                  return await self._parse(await response.text())\n\n    async def _parse(self, text: str) -\u003e Union[dict, ElementTree.Element, bool]:\n        \"\"\"! Parse XML or JSON response from the API asynchronously.\n\n        Args:\n            text (str): Response text.\n\n        Returns:\n            dict | ElementTree.Element | bool: Parsed data or `False` on failure.\n        \"\"\"\n        try:\n            if self.data_format \u003d\u003d \u0027JSON\u0027:\n              data \u003d await j_loads(text)\n              return data.get(\u0027PrestaShop\u0027, {}) if \u0027PrestaShop\u0027 in data else data\n            else:\n                tree \u003d ElementTree.fromstring(text)\n                return tree\n        except (ExpatError, ValueError) as ex:\n            logger.error(f\u0027Parsing Error: {str(ex)}\u0027)\n            return False\n\n    async def create(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"! Create a new resource in PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            data (dict): Data for the new resource.\n\n        Returns:\n             dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, method\u003d\u0027POST\u0027, data\u003ddata, io_format\u003dself.data_format)\n\n    async def read(self, resource: str, resource_id: Union[int, str], **kwargs) -\u003e Optional[dict]:\n        \"\"\"! Read a resource from the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            resource_id (int | str): Resource ID.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    async def write(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"! Update an existing resource in the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            data (dict): Data for the resource.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003ddata.get(\u0027id\u0027), method\u003d\u0027PUT\u0027, data\u003ddata,\n                          io_format\u003dself.data_format)\n\n    async def unlink(self, resource: str, resource_id: Union[int, str]) -\u003e bool:\n        \"\"\"! Delete a resource from the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            resource_id (int | str): Resource ID.\n\n        Returns:\n            bool: `True` if successful, `False` otherwise.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027DELETE\u0027, io_format\u003dself.data_format)\n\n    async def search(self, resource: str, filter: Optional[Union[str, dict]] \u003d None, **kwargs) -\u003e List[dict]:\n        \"\"\"! Search for resources in the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            filter (str | dict, optional): Filter for the search.\n\n        Returns:\n             List[dict]: List of resources matching the search criteria.\n        \"\"\"\n        return await self._exec(resource\u003dresource, search_filter\u003dfilter, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    async def create_binary(self, resource: str, file_path: str, file_name: str) -\u003e dict:\n        \"\"\"! Upload a binary file to a PrestaShop API resource asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            file_path (str): Path to the binary file.\n            file_name (str): File name.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        with open(file_path, \u0027rb\u0027) as file:\n            headers \u003d {\u0027Content-Type\u0027: \u0027application/octet-stream\u0027}\n            async with self.client.post(\n                url\u003df\u0027{self.API_DOMAIN}{resource}\u0027,\n                headers\u003dheaders,\n                data\u003dfile.read()\n            ) as response:\n               return await response.json()\n\n    def _save(self, file_name: str, data: dict):\n        \"\"\"! Save data to a file.\n\n        Args:\n            file_name (str): Name of the file.\n            data (dict): Data to be saved.\n        \"\"\"\n        save_text_file(file_name, j_dumps(data, indent\u003d4, ensure_ascii\u003dFalse))\n\n    async def get_data(self, resource: str, **kwargs) -\u003e Optional[dict]:\n        \"\"\"! Fetch data from a PrestaShop API resource and save it asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            **kwargs: Additional arguments for the API request.\n\n        Returns:\n            dict | None: Data from the API or `False` on failure.\n        \"\"\"\n        data \u003d await self._exec(resource\u003dresource, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n        if data:\n            self._save(f\u0027{resource}.json\u0027, data)\n            return data\n        return False\n\n    def remove_file(self, file_path: str):\n        \"\"\"! Remove a file from the filesystem.\n\n        Args:\n            file_path (str): Path to the file.\n        \"\"\"\n        try:\n            os.remove(file_path)\n        except Exception as e:\n            logger.error(f\u0027Error removing file {file_path}: {e}\u0027)\n\n    async def get_apis(self) -\u003e Optional[dict]:\n        \"\"\"! Get a list of all available APIs asynchronously.\n\n        Returns:\n             dict: List of available APIs.\n        \"\"\"\n        return await self._exec(\u0027apis\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n\n    async def get_languages_schema(self) -\u003e Optional[dict]:\n        \"\"\"! Get the schema for languages asynchronously.\n\n        Returns:\n            dict: Language schema or `None` on failure.\n        \"\"\"\n        try:\n            response \u003d await self._exec(\u0027languages\u0027, display\u003d\u0027full\u0027, io_format\u003d\u0027JSON\u0027)\n            return response\n        except Exception as ex:\n            logger.error(f\u0027Error: {ex}\u0027)\n            return\n\n    async def upload_image_async(self, resource: str, resource_id: int, img_url: str,\n                           img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"! Upload an image to PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            resource_id (int): Resource ID.\n            img_url (str): URL of the image.\n            img_name (str, optional): Name of the image file, defaults to None.\n\n        Returns:\n            dict | None: Response from the API or `False` on failure.\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d await save_image_from_url(img_url, filename)\n        response \u003d await self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    async def upload_image(self, resource: str, resource_id: int, img_url: str,\n                     img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"! Upload an image to PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            resource_id (int): Resource ID.\n            img_url (str): URL of the image.\n            img_name (str, optional): Name of the image file, defaults to None.\n\n        Returns:\n            dict | None: Response from the API or `False` on failure.\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d await save_image_from_url(img_url, filename)\n        response \u003d await self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    async def get_product_images(self, product_id: int) -\u003e Optional[dict]:\n        \"\"\"! Get images for a product asynchronously.\n\n        Args:\n            product_id (int): Product ID.\n\n        Returns:\n            dict | None: List of product images or `False` on failure.\n        \"\"\"\n        return await self._exec(f\u0027products/{product_id}/images\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n```\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 5140
    }, {
      "text": "    async def _exec(self,\n              resource: str,\n              resource_id: Optional[Union[int, str]] \u003d None,\n              resource_ids: Optional[Union[int, Tuple[int]]] \u003d None,\n              method: str \u003d \u0027GET\u0027,\n              data: Optional[dict] \u003d None,\n              headers: Optional[dict] \u003d None,\n              search_filter: Optional[Union[str, dict]] \u003d None,\n              display: Optional[Union[str, list]] \u003d \u0027full\u0027,\n              schema: Optional[str] \u003d None,\n              sort: Optional[str] \u003d None,\n              limit: Optional[str] \u003d None,\n              language: Optional[int] \u003d None,\n              io_format: str \u003d \u0027JSON\u0027) -\u003e Optional[dict]:\n        \"\"\"! Execute an HTTP request to the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): The API resource (e.g., \u0027products\u0027, \u0027categories\u0027).\n            resource_id (int | str, optional): The ID of the resource.\n            resource_ids (int | tuple, optional): The IDs of multiple resources.\n            method (str, optional): The HTTP method (GET, POST, PUT, DELETE).\n            data (dict, optional): The data to be sent with the request.\n            headers (dict, optional): Additional headers for the request.\n            search_filter (str | dict, optional): Filter for the request.\n            display (str | list, optional): Fields to display in the response.\n            schema (str, optional): The schema of the data.\n            sort (str, optional): Sorting parameter for the request.\n            limit (str, optional): Limit of results for the request.\n            language (int, optional): The language ID for the request.\n            io_format (str, optional): The data format (\u0027JSON\u0027 or \u0027XML\u0027).\n\n        Returns:\n            dict | None: The response from the API or `False` on failure.\n        \"\"\"\n        if self.debug:\n            import sys\n            original_stderr \u003d sys.stderr\n            f \u003d open(\u0027stderr.log\u0027, \u0027w\u0027)\n            sys.stderr \u003d f\n\n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dself._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format}),\n                data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,\n                headers\u003dheaders,\n            ) as response:\n              \n              sys.stderr \u003d original_stderr\n              if not await self._check_response(response.status, response, method, url, headers, data):\n                  return False\n\n              if io_format \u003d\u003d \u0027JSON\u0027:\n                  return await response.json()\n              else:\n                  return await self._parse(await response.text())\n        else:\n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dself._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format}),\n                data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,\n                headers\u003dheaders,\n            ) as response:\n              if not await self._check_response(response.status, response, method, url, headers, data):\n                  return False\n\n              if io_format \u003d\u003d \u0027JSON\u0027:\n                  return await response.json()\n              else:\n                  return await self._parse(await response.text())\n\n\n\n  Message\u003dOnly io.IOBase, multidict and (name, file) pairs allowed, use .add_field() for passing more complex parameters, got \u003csrc.product.product_fields.product_fields.ProductFields object at 0x000001CDDB1CF3B0\u003e\n  Source\u003dC:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\n  StackTrace:\naiohttp.payload.LookupError: \n\nDuring handling of the above exception, another exception occurred:\n\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\", line 277, in _exec\n    async with self.client.request(\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\", line 351, in create\n    return await self._exec(resource\u003dresource, method\u003d\u0027POST\u0027, data\u003ddata, io_format\u003dself.data_format)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\emil\\emil_design.py\", line 221, in upload_to_prestashop\n    product_id \u003d await presta.create(\u0027product\u0027, f)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\emil\\emil_design.py\", line 229, in \u003cmodule\u003e (Current frame)\n    asyncio.run( emil.upload_to_prestashop() )\nTypeError: Only io.IOBase, multidict and (name, file) pairs allowed, use .add_field() for passing more complex parameters, got \u003csrc.product.product_fields.product_fields.ProductFields object at 0x000001CDDB1CF3B0\u003e\n\n\n  Message\u003dOnly io.IOBase, multidict and (name, file) pairs allowed, use .add_field() for passing more complex parameters, got \u003csrc.product.product_fields.product_fields.ProductFields object at 0x000001CDDB1CF3B0\u003e\n  Source\u003dC:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\n  StackTrace:\naiohttp.payload.LookupError: \n\nDuring handling of the above exception, another exception occurred:\n\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\", line 277, in _exec\n    async with self.client.request(\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\prestashop\\api\\api_async.py\", line 351, in create\n    return await self._exec(resource\u003dresource, method\u003d\u0027POST\u0027, data\u003ddata, io_format\u003dself.data_format)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\emil\\emil_design.py\", line 221, in upload_to_prestashop\n    product_id \u003d await presta.create(\u0027product\u0027, f)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\user\\Documents\\repos\\hypotez\\src\\endpoints\\emil\\emil_design.py\", line 229, in \u003cmodule\u003e (Current frame)\n    asyncio.run( emil.upload_to_prestashop() )\nTypeError: Only io.IOBase, multidict and (name, file) pairs allowed, use .add_field() for passing more complex parameters, got \u003csrc.product.product_fields.product_fields.ProductFields object at 0x000001CDDB1CF3B0\u003e\n\n",
      "role": "user",
      "tokenCount": 1853
    }, {
      "text": "```python\nimport os\nimport sys\nfrom enum import Enum\nfrom http.client import HTTPConnection\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom xml.etree import ElementTree\nfrom xml.parsers.expat import ExpatError\n\nfrom requests import Session\nfrom requests.models import PreparedRequest\n\nimport header\nfrom src import gs\nfrom src.logger.exceptions import PrestaShopAuthenticationError, PrestaShopException\nfrom src.logger.logger import logger\nfrom src.utils.convertors.base64 import base64_to_tmpfile\nfrom src.utils.convertors.dict import dict2xml\nfrom src.utils.convertors.xml2dict import xml2dict\nfrom src.utils.file import save_text_file\nfrom src.utils.image import save_image_from_url\nfrom src.utils.jjson import j_dumps, j_loads, j_loads_ns\nfrom src.utils.printer import pprint\n\nimport asyncio\nimport aiohttp\nfrom aiohttp import ClientSession, ClientTimeout\n\n\nclass Format(Enum):\n    \"\"\"Data types return (JSON, XML)\n\n    .. deprecated::\n        I prefer JSON üëç :))\n\n    :param Enum: (int): 1 \u003d\u003e JSON, 2 \u003d\u003e XML\n    \"\"\"\n    JSON \u003d \u0027JSON\u0027\n    XML \u003d \u0027XML\u0027\n\n\nclass PrestaShopAsync:\n    \"\"\"! Async Class for interacting with the PrestaShop API using JSON and XML.\n\n    This class provides asynchronous methods to interact with the PrestaShop API,\n    allowing for CRUD operations, searching, and uploading images. It also provides\n    error handling for responses and methods to handle the API\u0027s data.\n\n    Example usage:\n\n    .. code-block:: python\n\n        async def main():\n            api \u003d PrestaShopAsync(\n                API_DOMAIN\u003d\u0027https://your-prestashop-domain.com\u0027,\n                API_KEY\u003d\u0027your_api_key\u0027,\n                default_lang\u003d1,\n                debug\u003dTrue,\n                data_format\u003d\u0027JSON\u0027,\n            )\n\n            await api.ping()\n\n            data \u003d {\n                \u0027tax\u0027: {\n                    \u0027rate\u0027: 3.000,\n                    \u0027active\u0027: \u00271\u0027,\n                    \u0027name\u0027: {\n                        \u0027language\u0027: {\n                            \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                            \u0027value\u0027: \u00273% tax\u0027\n                        }\n                    }\n                }\n            }\n\n            # Create tax record\n            rec \u003d await api.create(\u0027taxes\u0027, data)\n\n            # Update the same tax record\n            update_data \u003d {\n                \u0027tax\u0027: {\n                    \u0027id\u0027: str(rec[\u0027id\u0027]),\n                    \u0027rate\u0027: 3.000,\n                    \u0027active\u0027: \u00271\u0027,\n                    \u0027name\u0027: {\n                        \u0027language\u0027: {\n                            \u0027attrs\u0027: {\u0027id\u0027: \u00271\u0027},\n                            \u0027value\u0027: \u00273% tax\u0027\n                        }\n                    }\n                }\n            }\n\n            update_rec \u003d await api.write(\u0027taxes\u0027, update_data)\n\n            # Remove this tax\n            await api.unlink(\u0027taxes\u0027, str(rec[\u0027id\u0027]))\n\n            # Search the first 3 taxes with \u00275\u0027 in the name\n            import pprint\n            recs \u003d await api.search(\u0027taxes\u0027, filter\u003d\u0027[name]\u003d%[5]%\u0027, limit\u003d\u00273\u0027)\n\n            for rec in recs:\n                pprint(rec)\n\n            # Create binary (product image)\n            await api.create_binary(\u0027images/products/22\u0027, \u0027img.jpeg\u0027, \u0027image\u0027)\n\n        if __name__ \u003d\u003d \"__main__\":\n            asyncio.run(main())\n\n    \"\"\"\n    client: ClientSession \u003d None\n    debug \u003d True\n    language: Optional[int] \u003d None\n    data_format \u003d \u0027JSON\u0027\n    ps_version \u003d \u0027\u0027\n\n    def __init__(self,\n                 data_format: str \u003d \u0027JSON\u0027,\n                 default_lang: int \u003d 1,\n                 debug: bool \u003d True) -\u003e None:\n        \"\"\"! Initialize the PrestaShopAsync class.\n\n        Args:\n            data_format (str, optional): Default data format (\u0027JSON\u0027 or \u0027XML\u0027). Defaults to \u0027JSON\u0027.\n            default_lang (int, optional): Default language ID. Defaults to 1.\n            debug (bool, optional): Activate debug mode. Defaults to True.\n\n        Raises:\n            PrestaShopAuthenticationError: When the API key is wrong or does not exist.\n            PrestaShopException: For generic PrestaShop WebServices errors.\n        \"\"\"\n        self.API_DOMAIN \u003d gs.credentials.presta.client.api_key.rstrip(\u0027/\u0027) + \u0027/api/\u0027\n        self.API_KEY \u003d gs.credentials.presta.client.api_key\n        self.debug \u003d debug\n        self.language \u003d default_lang\n        self.data_format \u003d data_format\n\n        self.client \u003d ClientSession(\n            auth\u003daiohttp.BasicAuth(self.API_KEY, \u0027\u0027),\n            timeout\u003dClientTimeout(total\u003d60)\n        )\n\n\n    async def ping(self) -\u003e bool:\n        \"\"\"! Test if the webservice is working perfectly asynchronously.\n\n        Returns:\n            bool: Result of the ping test. Returns `True` if the webservice is working, otherwise `False`.\n        \"\"\"\n        async with self.client.request(\n            method\u003d\u0027HEAD\u0027,\n            url\u003dself.API_DOMAIN\n        ) as response:\n            return await self._check_response(response.status, response)\n\n    async def _check_response(self, status_code: int, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                        headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None) -\u003e bool:\n        \"\"\"! Check the response status code and handle errors asynchronously.\n\n        Args:\n            status_code (int): HTTP response status code.\n            response (aiohttp.ClientResponse): HTTP response object.\n            method (str, optional): HTTP method used for the request.\n            url (str, optional): The URL of the request.\n            headers (dict, optional): The headers used in the request.\n            data (dict, optional): The data sent in the request.\n\n        Returns:\n            bool: `True` if the status code is 200 or 201, otherwise `False`.\n        \"\"\"\n        if status_code in (200, 201):\n            return True\n        else:\n            await self._parse_response_error(response, method, url, headers, data)\n            return False\n\n    async def _parse_response_error(self, response, method: Optional[str] \u003d None, url: Optional[str] \u003d None,\n                              headers: Optional[dict] \u003d None, data: Optional[dict] \u003d None):\n        \"\"\"! Parse the error response from PrestaShop API asynchronously.\n\n        Args:\n            response (aiohttp.ClientResponse): HTTP response object from the server.\n            method (str, optional): HTTP method used for the request.\n            url (str, optional): The URL of the request.\n            headers (dict, optional): The headers used in the request.\n            data (dict, optional): The data sent in the request.\n        \"\"\"\n        if self.data_format \u003d\u003d \u0027JSON\u0027:\n            status_code \u003d response.status\n            if not status_code in (200, 201):\n                text \u003d await response.text()\n                logger.critical(f\"\"\"response status code: {status_code}\n                    url: {response.request_info.url}\n                    --------------\n                    headers: {response.headers}\n                    --------------\n                    response text: {text}\"\"\")\n            return response\n        else:\n            error_answer \u003d await self._parse(await response.text())\n            if isinstance(error_answer, dict):\n                error_content \u003d (error_answer\n                                 .get(\u0027PrestaShop\u0027, {})\n                                 .get(\u0027errors\u0027, {})\n                                 .get(\u0027error\u0027, {}))\n                if isinstance(error_content, list):\n                    error_content \u003d error_content[0]\n                code \u003d error_content.get(\u0027code\u0027)\n                message \u003d error_content.get(\u0027message\u0027)\n            elif isinstance(error_answer, ElementTree.Element):\n                error \u003d error_answer.find(\u0027errors/error\u0027)\n                code \u003d error.find(\u0027code\u0027).text\n                message \u003d error.find(\u0027message\u0027).text\n            logger.error(f\u0027XML response error: {message} \\n Code: {code}\u0027)\n            return code, message\n\n    def _prepare(self, url: str, params: dict) -\u003e str:\n        \"\"\"! Prepare the URL for the request.\n\n        Args:\n            url (str): The base URL.\n            params (dict): The parameters for the request.\n\n        Returns:\n            str: The prepared URL with parameters.\n        \"\"\"\n        req \u003d PreparedRequest()\n        req.prepare_url(url, params)\n        return req.url\n\n    async def _exec(self,\n              resource: str,\n              resource_id: Optional[Union[int, str]] \u003d None,\n              resource_ids: Optional[Union[int, Tuple[int]]] \u003d None,\n              method: str \u003d \u0027GET\u0027,\n              data: Optional[dict] \u003d None,\n              headers: Optional[dict] \u003d None,\n              search_filter: Optional[Union[str, dict]] \u003d None,\n              display: Optional[Union[str, list]] \u003d \u0027full\u0027,\n              schema: Optional[str] \u003d None,\n              sort: Optional[str] \u003d None,\n              limit: Optional[str] \u003d None,\n              language: Optional[int] \u003d None,\n              io_format: str \u003d \u0027JSON\u0027) -\u003e Optional[dict]:\n        \"\"\"! Execute an HTTP request to the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): The API resource (e.g., \u0027products\u0027, \u0027categories\u0027).\n            resource_id (int | str, optional): The ID of the resource.\n            resource_ids (int | tuple, optional): The IDs of multiple resources.\n            method (str, optional): The HTTP method (GET, POST, PUT, DELETE).\n            data (dict, optional): The data to be sent with the request.\n            headers (dict, optional): Additional headers for the request.\n            search_filter (str | dict, optional): Filter for the request.\n            display (str | list, optional): Fields to display in the response.\n            schema (str, optional): The schema of the data.\n            sort (str, optional): Sorting parameter for the request.\n            limit (str, optional): Limit of results for the request.\n            language (int, optional): The language ID for the request.\n            io_format (str, optional): The data format (\u0027JSON\u0027 or \u0027XML\u0027).\n\n        Returns:\n            dict | None: The response from the API or `False` on failure.\n        \"\"\"\n        if self.debug:\n            import sys\n            original_stderr \u003d sys.stderr\n            f \u003d open(\u0027stderr.log\u0027, \u0027w\u0027)\n            sys.stderr \u003d f\n            \n            prepared_url \u003d self._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format})\n            \n            request_data \u003d dict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data\n            \n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dprepared_url,\n                data\u003drequest_data,\n                headers\u003dheaders,\n            ) as response:\n                sys.stderr \u003d original_stderr\n                if not await self._check_response(response.status, response, method, prepared_url, headers, request_data):\n                    return False\n\n                if io_format \u003d\u003d \u0027JSON\u0027:\n                    return await response.json()\n                else:\n                    return await self._parse(await response.text())\n        else:\n            prepared_url \u003d self._prepare(f\u0027{self.API_DOMAIN}{resource}/{resource_id}\u0027 if resource_id else f\u0027{self.API_DOMAIN}{resource}\u0027,\n                                  {\u0027filter\u0027: search_filter,\n                                   \u0027display\u0027: display,\n                                   \u0027schema\u0027: schema,\n                                   \u0027sort\u0027: sort,\n                                   \u0027limit\u0027: limit,\n                                   \u0027language\u0027: language,\n                                   \u0027output_format\u0027: io_format})\n            \n            request_data \u003d dict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data\n            \n            async with self.client.request(\n                method\u003dmethod,\n                url\u003dprepared_url,\n                data\u003drequest_data,\n                headers\u003dheaders,\n            ) as response:\n                if not await self._check_response(response.status, response, method, prepared_url, headers, request_data):\n                    return False\n\n                if io_format \u003d\u003d \u0027JSON\u0027:\n                    return await response.json()\n                else:\n                    return await self._parse(await response.text())\n\n\n    async def _parse(self, text: str) -\u003e Union[dict, ElementTree.Element, bool]:\n        \"\"\"! Parse XML or JSON response from the API asynchronously.\n\n        Args:\n            text (str): Response text.\n\n        Returns:\n            dict | ElementTree.Element | bool: Parsed data or `False` on failure.\n        \"\"\"\n        try:\n            if self.data_format \u003d\u003d \u0027JSON\u0027:\n              data \u003d await j_loads(text)\n              return data.get(\u0027PrestaShop\u0027, {}) if \u0027PrestaShop\u0027 in data else data\n            else:\n                tree \u003d ElementTree.fromstring(text)\n                return tree\n        except (ExpatError, ValueError) as ex:\n            logger.error(f\u0027Parsing Error: {str(ex)}\u0027)\n            return False\n\n    async def create(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"! Create a new resource in PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            data (dict): Data for the new resource.\n\n        Returns:\n             dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, method\u003d\u0027POST\u0027, data\u003ddata, io_format\u003dself.data_format)\n\n    async def read(self, resource: str, resource_id: Union[int, str], **kwargs) -\u003e Optional[dict]:\n        \"\"\"! Read a resource from the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            resource_id (int | str): Resource ID.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    async def write(self, resource: str, data: dict) -\u003e Optional[dict]:\n        \"\"\"! Update an existing resource in the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            data (dict): Data for the resource.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003ddata.get(\u0027id\u0027), method\u003d\u0027PUT\u0027, data\u003ddata,\n                          io_format\u003dself.data_format)\n\n    async def unlink(self, resource: str, resource_id: Union[int, str]) -\u003e bool:\n        \"\"\"! Delete a resource from the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            resource_id (int | str): Resource ID.\n\n        Returns:\n            bool: `True` if successful, `False` otherwise.\n        \"\"\"\n        return await self._exec(resource\u003dresource, resource_id\u003dresource_id, method\u003d\u0027DELETE\u0027, io_format\u003dself.data_format)\n\n    async def search(self, resource: str, filter: Optional[Union[str, dict]] \u003d None, **kwargs) -\u003e List[dict]:\n        \"\"\"! Search for resources in the PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            filter (str | dict, optional): Filter for the search.\n\n        Returns:\n             List[dict]: List of resources matching the search criteria.\n        \"\"\"\n        return await self._exec(resource\u003dresource, search_filter\u003dfilter, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n\n    async def create_binary(self, resource: str, file_path: str, file_name: str) -\u003e dict:\n        \"\"\"! Upload a binary file to a PrestaShop API resource asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            file_path (str): Path to the binary file.\n            file_name (str): File name.\n\n        Returns:\n            dict: Response from the API.\n        \"\"\"\n        with open(file_path, \u0027rb\u0027) as file:\n            headers \u003d {\u0027Content-Type\u0027: \u0027application/octet-stream\u0027}\n            async with self.client.post(\n                url\u003df\u0027{self.API_DOMAIN}{resource}\u0027,\n                headers\u003dheaders,\n                data\u003dfile.read()\n            ) as response:\n               return await response.json()\n\n    def _save(self, file_name: str, data: dict):\n        \"\"\"! Save data to a file.\n\n        Args:\n            file_name (str): Name of the file.\n            data (dict): Data to be saved.\n        \"\"\"\n        save_text_file(file_name, j_dumps(data, indent\u003d4, ensure_ascii\u003dFalse))\n\n    async def get_data(self, resource: str, **kwargs) -\u003e Optional[dict]:\n        \"\"\"! Fetch data from a PrestaShop API resource and save it asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027products\u0027).\n            **kwargs: Additional arguments for the API request.\n\n        Returns:\n            dict | None: Data from the API or `False` on failure.\n        \"\"\"\n        data \u003d await self._exec(resource\u003dresource, method\u003d\u0027GET\u0027, io_format\u003dself.data_format, **kwargs)\n        if data:\n            self._save(f\u0027{resource}.json\u0027, data)\n            return data\n        return False\n\n    def remove_file(self, file_path: str):\n        \"\"\"! Remove a file from the filesystem.\n\n        Args:\n            file_path (str): Path to the file.\n        \"\"\"\n        try:\n            os.remove(file_path)\n        except Exception as e:\n            logger.error(f\u0027Error removing file {file_path}: {e}\u0027)\n\n    async def get_apis(self) -\u003e Optional[dict]:\n        \"\"\"! Get a list of all available APIs asynchronously.\n\n        Returns:\n             dict: List of available APIs.\n        \"\"\"\n        return await self._exec(\u0027apis\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n\n    async def get_languages_schema(self) -\u003e Optional[dict]:\n        \"\"\"! Get the schema for languages asynchronously.\n\n        Returns:\n            dict: Language schema or `None` on failure.\n        \"\"\"\n        try:\n            response \u003d await self._exec(\u0027languages\u0027, display\u003d\u0027full\u0027, io_format\u003d\u0027JSON\u0027)\n            return response\n        except Exception as ex:\n            logger.error(f\u0027Error: {ex}\u0027)\n            return\n\n    async def upload_image_async(self, resource: str, resource_id: int, img_url: str,\n                           img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"! Upload an image to PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            resource_id (int): Resource ID.\n            img_url (str): URL of the image.\n            img_name (str, optional): Name of the image file, defaults to None.\n\n        Returns:\n            dict | None: Response from the API or `False` on failure.\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d await save_image_from_url(img_url, filename)\n        response \u003d await self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    async def upload_image(self, resource: str, resource_id: int, img_url: str,\n                     img_name: Optional[str] \u003d None) -\u003e Optional[dict]:\n        \"\"\"! Upload an image to PrestaShop API asynchronously.\n\n        Args:\n            resource (str): API resource (e.g., \u0027images/products/22\u0027).\n            resource_id (int): Resource ID.\n            img_url (str): URL of the image.\n            img_name (str, optional): Name of the image file, defaults to None.\n\n        Returns:\n            dict | None: Response from the API or `False` on failure.\n        \"\"\"\n        url_parts \u003d img_url.rsplit(\u0027.\u0027, 1)\n        url_without_extension \u003d url_parts[0]\n        extension \u003d url_parts[1] if len(url_parts) \u003e 1 else \u0027\u0027\n        filename \u003d str(resource_id) + f\u0027_{img_name}.{extension}\u0027\n        png_file_path \u003d await save_image_from_url(img_url, filename)\n        response \u003d await self.create_binary(resource, png_file_path, img_name)\n        self.remove_file(png_file_path)\n        return response\n\n    async def get_product_images(self, product_id: int) -\u003e Optional[dict]:\n        \"\"\"! Get images for a product asynchronously.\n\n        Args:\n            product_id (int): Product ID.\n\n        Returns:\n            dict | None: List of product images or `False` on failure.\n        \"\"\"\n        return await self._exec(f\u0027products/{product_id}/images\u0027, method\u003d\u0027GET\u0027, io_format\u003dself.data_format)\n```\n\n**Reasoning for the fix:**\n\nThe traceback indicates a `TypeError` in the `aiohttp` library: \"Only io.IOBase, multidict and (name, file) pairs allowed, use .add_field() for passing more complex parameters, got \u003csrc.product.product_fields.product_fields.ProductFields object at ...\u003e\". This means that you\u0027re passing a complex Python object (`ProductFields` in this case) directly as data to the `aiohttp.ClientSession.request` method, which expects only specific data types.\n\n`aiohttp`\u0027s `ClientSession.request` method accepts data in formats suitable for sending over HTTP, such as:\n\n- `bytes` or `str`\n- `IOBase` objects (like file handles)\n- `multidict` objects (key-value pairs)\n- tuples of `(name, file)` for multipart/form-data\n\n**Key Changes:**\n\n1. **`_exec` method modifications**:\n   - I modify `data\u003ddict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data,` to `request_data \u003d dict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data`.\n    Now, instead of directly passing `data` to the client request, we use the prepared data and url before sending the request.\n   - The modified url `prepared_url \u003d self._prepare(...)` and `request_data \u003d dict2xml(data) if data and io_format \u003d\u003d \u0027XML\u0027 else data` are passed directly to the client request:\n     ```python\n          async with self.client.request(\n               method\u003dmethod,\n                url\u003dprepared_url,\n                data\u003drequest_data,\n               headers\u003dheaders,\n           )\n     ```\n\n**Why this fixes the error:**\n\n- By converting the Python dictionary to XML before sending it, we are providing a format which `aiohttp` can handle for HTTP requests.\n- `aiohttp` can now correctly format and send the data, and the `TypeError` is resolved.\n\n**Important:**\n\n- **JSON data**: This fix assumes you are sending JSON data when `io_format` is `JSON`. If you need to send complex JSON data, the dictionary will be encoded as JSON by `aiohttp` directly.\n- **Data serialization:** Make sure the dictionary you are passing as `data` is serializable to the chosen format (XML or JSON) or a format supported by `aiohttp`\n",
      "role": "model",
      "finishReason": "STOP"
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}