{
  "runSettings": {
    "temperature": 1.0,
    "model": "models/gemini-2.0-flash-exp",
    "candidateCount": 1,
    "topP": 0.95,
    "topK": 40,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_NONE"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false
  },
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "## \\file /src/fast_api/fast_api_rpc.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\nFastAPI сервер с XML-RPC интерфейсом для удалённого управления\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n.. module:: src.fast_api.fast_api_rpc\n    :platform: Windows, Unix\n    :synopsis: FastAPI сервер с интерфейсом XML-RPC для удалённого управления\n\n\"\"\"\nimport asyncio\nimport functools\nimport json\nimport os\nimport sys\nimport threading\nfrom types import SimpleNamespace\nfrom typing import List, Callable, Dict\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom dotenv import load_dotenv\n\nimport uvicorn\nfrom fastapi import FastAPI, APIRouter\n\nimport header  # \u003c-- Обязательный импорт\nfrom header import __root__\nfrom src import gs\nfrom src.utils.jjson import j_loads, j_loads_ns\n#from src.endpoints.bots.telegram.webhooks import telegram_webhook\nfrom src.utils.printer import pprint as print\nfrom src.logger import logger\n\nimport re\n\nload_dotenv()\n\n\ntry:\n    config: SimpleNamespace \u003d j_loads_ns(__root__ / \u0027src\u0027 / \u0027fast_api\u0027 / \u0027fast_api.json\u0027)\n    config.ports: list \u003d config.ports if isinstance(config.ports, list) else [config.ports]\nexcept Exception as ex:\n    logger.critical(f\"Config file not found!\")\n    sys.exit()\n\n_api_server_instance \u003d None\n\n\nclass FastApiServer:\n    \"\"\"FastAPI сервер с реализацией Singleton.\"\"\"\n\n    _instance \u003d None\n    app: FastAPI \u003d FastAPI()\n    host: str \u003d config.host\n    port: int \u003d 8000\n    router: APIRouter \u003d APIRouter()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance \u003d super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, host: str \u003d \"127.0.0.1\", title: str \u003d \"FastAPI RPC Server\", **kwargs):\n        if hasattr(self, \u0027_initialized\u0027):\n            return\n        self._initialized \u003d True\n        self.add_route(\"/hello\", test_function)\n        self.add_route(\"/post\", test_post, methods\u003d[\"POST\"])\n        self.add_route(\"/telegram_webhook\", telegram_webhook, methods\u003d[\"POST\"])\n\n        self.app \u003d FastAPI()\n        self.host \u003d host or config.host\n        self.server_tasks \u003d {}\n        self.servers \u003d {}\n        self.app.include_router(self.router)\n\n    def add_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет маршрут к FastAPI приложению.\"\"\"\n        self.router.add_api_route(path, func, methods\u003dmethods, **kwargs)\n\n    def add_new_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет новый маршрут к уже работающему приложению.\"\"\"\n        self.add_route(path, func, methods, **kwargs)\n\n    async def _start_server(self, port: int):\n        \"\"\"Запускает uvicorn сервер асинхронно.\"\"\"\n        config \u003d uvicorn.Config(self.app, host\u003dself.host, port\u003dport, log_level\u003d\"info\")\n        server \u003d uvicorn.Server(config)\n        try:\n            await server.serve()\n            logger.success(f\"Server started on: {self.host}:{port}\")\n        except Exception as e:\n            logger.error(f\"Error running server on port {port}: {e}\")\n        finally:\n            self.servers.pop(port, None)\n\n    def start(self, port: int, as_thread:bool \u003d True):\n        \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            print(f\"Server already running on port {port}\")\n            return\n\n        task \u003d threading.Thread(target\u003dasyncio.run, args\u003d(self._start_server(port),), daemon\u003dTrue)\n        self.server_tasks[port] \u003d task\n        self.servers[port] \u003d task\n        task.start()\n\n    def stop(self, port: int):\n        \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            try:\n                self.servers[port]._thread.join(1)\n                self.servers.pop(port)\n                print(f\"Server on port {port} stopped.\")\n            except Exception as e:\n                logger.error(f\"Error stopping server on port {port}: {e}\")\n        else:\n            print(f\"Server on port {port} is not running or already stopped.\")\n\n    def stop_all(self):\n        \"\"\"Останавливает все запущенные сервера.\"\"\"\n        for port in list(self.servers):\n            self.stop(port)\n\n    def get_servers_status(self):\n        \"\"\"Возвращает статус всех серверов.\"\"\"\n        return {port: \"Running\" if task.is_alive() else \"Stopped\" for port, task in self.servers.items()}\n\n    def get_app(self):\n        \"\"\"Возвращает FastAPI приложение.\"\"\"\n        return self.app\n\n\ndef telegram_webhook():\n    \"\"\"\"\"\"\n    return \u0027Hello, World!\u0027\n\n\ndef test_function():\n    return \"It is working!!!\"\n\n\ndef test_post(data: Dict[str, str]):\n    return {\"result\": \"post ok\", \"data\": data}\n\n\ndef start_server(port: int, host: str):\n    \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance is None:\n        _api_server_instance \u003d FastApiServer(host\u003dhost)\n    _api_server_instance.start(port\u003dport)\n\n\ndef stop_server(port: int):\n    \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop(port\u003dport)\n\n\ndef stop_all_servers():\n    \"\"\"Останавливает все запущенные FastAPI серверы.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop_all()\n\n\ndef status_servers():\n    \"\"\"Показывает статус серверов.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        servers \u003d _api_server_instance.get_servers_status()\n        if servers:\n            print(f\"Server initialized on host {_api_server_instance.host}\")\n            for port, status in servers.items():\n                print(f\"  - Port {port}: {status}\")\n        else:\n            print(\"No servers running\")\n    else:\n        print(\"Server not initialized.\")\n\n\ndef add_new_route(path: str, func: Callable, methods: List[str] \u003d [\"GET\"]):\n    \"\"\"Добавляет новый роут к серверу.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.add_new_route(path\u003dpath, func\u003dfunc, methods\u003dmethods)\n        print(f\"Route added: {path}, {methods\u003d}\")\n    else:\n        print(\"Server not initialized. Start server first\")\n\n\ndef parse_port_range(range_str):\n    \"\"\"Разбирает строку с диапазоном портов.\"\"\"\n    if not re.match(r\u0027^[\\d-]+$\u0027, range_str):\n        print(f\"Invalid port range: {range_str}\")\n        return []\n    if \u0027-\u0027 in range_str:\n        try:\n            start, end \u003d map(int, range_str.split(\u0027-\u0027))\n            if start \u003e end:\n                raise ValueError(\"Invalid port range\")\n            return list(range(start, end + 1))\n        except ValueError:\n            print(f\"Invalid port range: {range_str}\")\n            return []\n    else:\n        try:\n            return [int(range_str)]\n        except ValueError:\n            print(f\"Invalid port: {range_str}\")\n            return []\n\n\nclass CommandHandler:\n    \"\"\"Обработчик команд для FastAPI сервера через XML-RPC.\"\"\"\n\n    def __init__(self, rpc_port\u003d9000):\n        self.rpc_port \u003d rpc_port\n        self.rpc_server \u003d SimpleXMLRPCServer((\"localhost\", self.rpc_port), allow_none\u003dTrue)\n        self.rpc_server.register_instance(self)\n        threading.Thread(target\u003dself.rpc_server.serve_forever, daemon\u003dTrue).start()\n        print(f\"RPC server started on port: {self.rpc_port}\")\n\n    def start_server(self, port: int, host: str):\n        start_server(port\u003dport, host\u003dhost)\n\n    def stop_server(self, port: int):\n        stop_server(port\u003dport)\n\n    def stop_all_servers(self):\n        stop_all_servers()\n\n    def status_servers(self):\n        status_servers()\n\n    def add_new_route(self, path: str, func: str, methods: List[str] \u003d [\"GET\"]):\n        # Передаем ссылку на функцию вместо eval.\n        func_ref \u003d globals().get(func)\n        if func_ref:\n            add_new_route(path\u003dpath, func\u003dfunc_ref, methods\u003dmethods)\n        else:\n            print(f\"Function {func} not found.\")\n\n    def shutdown(self):\n        self.stop_all_servers()\n        self.rpc_server.shutdown()\n        print(\"RPC server shutdown\")\n        sys.exit(0)\n\n\n## \\file /src/fast_api/main.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\n.. module:: src.fast_api.main \n    :platform: Windows, Unix\n    :synopsis: Управаление параметрами Fast Api сервера\n\n\"\"\"\n\nimport sys\nimport header  # \u003c-- Обязательный импорт\nfrom src.fast_api.fast_api import CommandHandler, logger\n\n\ndef display_menu():\n    \"\"\"Выводит меню с доступными командами.\"\"\"\n    print(\"\\nAvailable commands:\")\n    print(\"  start \u003cport\u003e        - Start server on the specified port\")\n    print(\"  status              - Show all served ports status\")\n    print(\"  stop \u003cport\u003e         - Stop server on the specified port\")\n    print(\"  stop_all            - Stop all servers\")\n    print(\"  add_route \u003cpath\u003e    - Add a new route to the server\")\n    print(\"  shutdown            - Stop all servers and exit\")\n    print(\"  help                - Show this help menu\")\n    print(\"  exit                - Exit the program\")\n\n\ndef main():\n    \"\"\"Основная функция управления сервером.\"\"\"\n    command_handler \u003d CommandHandler()\n    while True:\n        display_menu()\n        try:\n            command_line \u003d input(\"Enter command: \").strip().lower()\n            if not command_line:\n                continue\n\n            parts \u003d command_line.split()\n            command \u003d parts[0]\n\n            if command \u003d\u003d \"start\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: start \u003cport\u003e\")\n                    continue\n                try:\n                    port \u003d int(parts[1])\n                    host \u003d input(\"Enter host address (default: 127.0.0.1): \").strip() or \"127.0.0.1\"\n                    command_handler.start_server(port\u003dport, host\u003dhost)\n                except ValueError:\n                    print(\"Invalid port number.\")\n                except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n            elif command \u003d\u003d \"status\":\n                command_handler.status_servers()\n            \n            elif command \u003d\u003d \"stop\":\n               if len(parts) !\u003d 2:\n                   print(\"Usage: stop \u003cport\u003e\")\n                   continue\n               try:\n                    port \u003d int(parts[1])\n                    command_handler.stop_server(port\u003dport)\n               except ValueError:\n                   print(\"Invalid port number.\")\n               except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n            \n            elif command \u003d\u003d \"stop_all\":\n               command_handler.stop_all_servers()\n            \n            elif command \u003d\u003d \"add_route\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: add_route \u003cpath\u003e\")\n                    continue\n                path \u003d parts[1]\n                methods \u003d input(\"Enter HTTP methods (comma-separated, default: GET): \").strip().upper() or \"GET\"\n                methods \u003d [method.strip() for method in methods.split(\",\")]\n                command_handler.add_new_route(path\u003dpath, func\u003dlambda: {\"message\": \"Hello from the new route\"}, methods\u003dmethods)\n\n            elif command \u003d\u003d \"shutdown\":\n                command_handler.stop_all_servers()\n                print(\"Shutting down all servers.\")\n                sys.exit(0)\n\n            elif command \u003d\u003d \"help\":\n                display_menu()\n\n            elif command \u003d\u003d \"exit\":\n                print(\"Exiting the program.\")\n                sys.exit(0)\n            \n            else:\n                print(\"Unknown command. Type \u0027help\u0027 to see the list of available commands\")\n\n        except Exception as ex:\n            logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    main()\n\nЗадача. Перепиши меню  файле main(), чтобы я мог посмотреть подключенные роуты",
      "role": "user",
      "tokenCount": 3254
    }, {
      "text": "```python\n## \\file /src/fast_api/fast_api_rpc.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\nFastAPI сервер с XML-RPC интерфейсом для удалённого управления\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n.. module:: src.fast_api.fast_api_rpc\n    :platform: Windows, Unix\n    :synopsis: FastAPI сервер с интерфейсом XML-RPC для удалённого управления\n\n\"\"\"\nimport asyncio\nimport functools\nimport json\nimport os\nimport sys\nimport threading\nfrom types import SimpleNamespace\nfrom typing import List, Callable, Dict\nfrom pathlib import Path\nfrom contextlib import asynccontextmanager\nfrom xmlrpc.server import SimpleXMLRPCServer\nfrom dotenv import load_dotenv\n\nimport uvicorn\nfrom fastapi import FastAPI, APIRouter\n\nimport header  # \u003c-- Обязательный импорт\nfrom header import __root__\nfrom src import gs\nfrom src.utils.jjson import j_loads, j_loads_ns\n#from src.endpoints.bots.telegram.webhooks import telegram_webhook\nfrom src.utils.printer import pprint as print\nfrom src.logger import logger\n\nimport re\n\nload_dotenv()\n\n\ntry:\n    config: SimpleNamespace \u003d j_loads_ns(__root__ / \u0027src\u0027 / \u0027fast_api\u0027 / \u0027fast_api.json\u0027)\n    config.ports: list \u003d config.ports if isinstance(config.ports, list) else [config.ports]\nexcept Exception as ex:\n    logger.critical(f\"Config file not found!\")\n    sys.exit()\n\n_api_server_instance \u003d None\n\n\nclass FastApiServer:\n    \"\"\"FastAPI сервер с реализацией Singleton.\"\"\"\n\n    _instance \u003d None\n    app: FastAPI \u003d FastAPI()\n    host: str \u003d config.host\n    port: int \u003d 8000\n    router: APIRouter \u003d APIRouter()\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance \u003d super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, host: str \u003d \"127.0.0.1\", title: str \u003d \"FastAPI RPC Server\", **kwargs):\n        if hasattr(self, \u0027_initialized\u0027):\n            return\n        self._initialized \u003d True\n        self.add_route(\"/hello\", test_function)\n        self.add_route(\"/post\", test_post, methods\u003d[\"POST\"])\n        self.add_route(\"/telegram_webhook\", telegram_webhook, methods\u003d[\"POST\"])\n\n        self.app \u003d FastAPI()\n        self.host \u003d host or config.host\n        self.server_tasks \u003d {}\n        self.servers \u003d {}\n        self.app.include_router(self.router)\n\n    def add_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет маршрут к FastAPI приложению.\"\"\"\n        self.router.add_api_route(path, func, methods\u003dmethods, **kwargs)\n\n    def add_new_route(self, path: str, func: Callable, methods: List[str] \u003d [\"GET\"], **kwargs):\n        \"\"\"Добавляет новый маршрут к уже работающему приложению.\"\"\"\n        self.add_route(path, func, methods, **kwargs)\n\n    async def _start_server(self, port: int):\n        \"\"\"Запускает uvicorn сервер асинхронно.\"\"\"\n        config \u003d uvicorn.Config(self.app, host\u003dself.host, port\u003dport, log_level\u003d\"info\")\n        server \u003d uvicorn.Server(config)\n        try:\n            await server.serve()\n            logger.success(f\"Server started on: {self.host}:{port}\")\n        except Exception as e:\n            logger.error(f\"Error running server on port {port}: {e}\")\n        finally:\n            self.servers.pop(port, None)\n\n    def start(self, port: int, as_thread:bool \u003d True):\n        \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            print(f\"Server already running on port {port}\")\n            return\n\n        task \u003d threading.Thread(target\u003dasyncio.run, args\u003d(self._start_server(port),), daemon\u003dTrue)\n        self.server_tasks[port] \u003d task\n        self.servers[port] \u003d task\n        task.start()\n\n    def stop(self, port: int):\n        \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n        if port in self.servers:\n            try:\n                self.servers[port]._thread.join(1)\n                self.servers.pop(port)\n                print(f\"Server on port {port} stopped.\")\n            except Exception as e:\n                logger.error(f\"Error stopping server on port {port}: {e}\")\n        else:\n            print(f\"Server on port {port} is not running or already stopped.\")\n\n    def stop_all(self):\n        \"\"\"Останавливает все запущенные сервера.\"\"\"\n        for port in list(self.servers):\n            self.stop(port)\n\n    def get_servers_status(self):\n        \"\"\"Возвращает статус всех серверов.\"\"\"\n        return {port: \"Running\" if task.is_alive() else \"Stopped\" for port, task in self.servers.items()}\n\n    def get_routes(self):\n      \"\"\"Возвращает список всех роутов.\"\"\"\n      routes \u003d []\n      for route in self.app.routes:\n          if hasattr(route, \"path\"):\n            methods \u003d getattr(route, \"methods\", [\"GET\"])\n            routes.append({\"path\": route.path, \"methods\": list(methods)})\n      return routes\n\n    def get_app(self):\n        \"\"\"Возвращает FastAPI приложение.\"\"\"\n        return self.app\n\n\ndef telegram_webhook():\n    \"\"\"\"\"\"\n    return \u0027Hello, World!\u0027\n\n\ndef test_function():\n    return \"It is working!!!\"\n\n\ndef test_post(data: Dict[str, str]):\n    return {\"result\": \"post ok\", \"data\": data}\n\n\ndef start_server(port: int, host: str):\n    \"\"\"Запускает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance is None:\n        _api_server_instance \u003d FastApiServer(host\u003dhost)\n    _api_server_instance.start(port\u003dport)\n\n\ndef stop_server(port: int):\n    \"\"\"Останавливает FastAPI сервер на указанном порту.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop(port\u003dport)\n\n\ndef stop_all_servers():\n    \"\"\"Останавливает все запущенные FastAPI серверы.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.stop_all()\n\n\ndef status_servers():\n    \"\"\"Показывает статус серверов.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        servers \u003d _api_server_instance.get_servers_status()\n        if servers:\n            print(f\"Server initialized on host {_api_server_instance.host}\")\n            for port, status in servers.items():\n                print(f\"  - Port {port}: {status}\")\n        else:\n            print(\"No servers running\")\n    else:\n        print(\"Server not initialized.\")\n\ndef get_routes():\n    \"\"\"Показывает все роуты.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n      routes \u003d _api_server_instance.get_routes()\n      if routes:\n        print(\"Available routes:\")\n        for route in routes:\n          print(f\"  - Path: {route[\u0027path\u0027]}, Methods: {route[\u0027methods\u0027]}\")\n      else:\n        print(\"No routes defined\")\n    else:\n        print(\"Server not initialized.\")\n\n\ndef add_new_route(path: str, func: Callable, methods: List[str] \u003d [\"GET\"]):\n    \"\"\"Добавляет новый роут к серверу.\"\"\"\n    global _api_server_instance\n    if _api_server_instance:\n        _api_server_instance.add_new_route(path\u003dpath, func\u003dfunc, methods\u003dmethods)\n        print(f\"Route added: {path}, {methods\u003d}\")\n    else:\n        print(\"Server not initialized. Start server first\")\n\n\ndef parse_port_range(range_str):\n    \"\"\"Разбирает строку с диапазоном портов.\"\"\"\n    if not re.match(r\u0027^[\\d-]+$\u0027, range_str):\n        print(f\"Invalid port range: {range_str}\")\n        return []\n    if \u0027-\u0027 in range_str:\n        try:\n            start, end \u003d map(int, range_str.split(\u0027-\u0027))\n            if start \u003e end:\n                raise ValueError(\"Invalid port range\")\n            return list(range(start, end + 1))\n        except ValueError:\n            print(f\"Invalid port range: {range_str}\")\n            return []\n    else:\n        try:\n            return [int(range_str)]\n        except ValueError:\n            print(f\"Invalid port: {range_str}\")\n            return []\n\n\nclass CommandHandler:\n    \"\"\"Обработчик команд для FastAPI сервера через XML-RPC.\"\"\"\n\n    def __init__(self, rpc_port\u003d9000):\n        self.rpc_port \u003d rpc_port\n        self.rpc_server \u003d SimpleXMLRPCServer((\"localhost\", self.rpc_port), allow_none\u003dTrue)\n        self.rpc_server.register_instance(self)\n        threading.Thread(target\u003dself.rpc_server.serve_forever, daemon\u003dTrue).start()\n        print(f\"RPC server started on port: {self.rpc_port}\")\n\n    def start_server(self, port: int, host: str):\n        start_server(port\u003dport, host\u003dhost)\n\n    def stop_server(self, port: int):\n        stop_server(port\u003dport)\n\n    def stop_all_servers(self):\n        stop_all_servers()\n\n    def status_servers(self):\n        status_servers()\n\n    def get_routes(self):\n        get_routes()\n\n    def add_new_route(self, path: str, func: str, methods: List[str] \u003d [\"GET\"]):\n        # Передаем ссылку на функцию вместо eval.\n        func_ref \u003d globals().get(func)\n        if func_ref:\n            add_new_route(path\u003dpath, func\u003dfunc_ref, methods\u003dmethods)\n        else:\n            print(f\"Function {func} not found.\")\n\n    def shutdown(self):\n        self.stop_all_servers()\n        self.rpc_server.shutdown()\n        print(\"RPC server shutdown\")\n        sys.exit(0)\n\n\n## \\file /src/fast_api/main.py\n# -*- coding: utf-8 -*-\n#! venv/bin/python/python3.12\n\n\"\"\"\n.. module:: src.fast_api.main \n    :platform: Windows, Unix\n    :synopsis: Управаление параметрами Fast Api сервера\n\n\"\"\"\n\nimport sys\nimport header  # \u003c-- Обязательный импорт\nfrom src.fast_api.fast_api import CommandHandler, logger\n\n\ndef display_menu():\n    \"\"\"Выводит меню с доступными командами.\"\"\"\n    print(\"\\nAvailable commands:\")\n    print(\"  start \u003cport\u003e        - Start server on the specified port\")\n    print(\"  status              - Show all served ports status\")\n    print(\"  routes              - Show all registered routes\")\n    print(\"  stop \u003cport\u003e         - Stop server on the specified port\")\n    print(\"  stop_all            - Stop all servers\")\n    print(\"  add_route \u003cpath\u003e    - Add a new route to the server\")\n    print(\"  shutdown            - Stop all servers and exit\")\n    print(\"  help                - Show this help menu\")\n    print(\"  exit                - Exit the program\")\n\n\ndef main():\n    \"\"\"Основная функция управления сервером.\"\"\"\n    command_handler \u003d CommandHandler()\n    while True:\n        display_menu()\n        try:\n            command_line \u003d input(\"Enter command: \").strip().lower()\n            if not command_line:\n                continue\n\n            parts \u003d command_line.split()\n            command \u003d parts[0]\n\n            if command \u003d\u003d \"start\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: start \u003cport\u003e\")\n                    continue\n                try:\n                    port \u003d int(parts[1])\n                    host \u003d input(\"Enter host address (default: 127.0.0.1): \").strip() or \"127.0.0.1\"\n                    command_handler.start_server(port\u003dport, host\u003dhost)\n                except ValueError:\n                    print(\"Invalid port number.\")\n                except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n            elif command \u003d\u003d \"status\":\n                command_handler.status_servers()\n\n            elif command \u003d\u003d \"routes\":\n                command_handler.get_routes()\n            \n            elif command \u003d\u003d \"stop\":\n               if len(parts) !\u003d 2:\n                   print(\"Usage: stop \u003cport\u003e\")\n                   continue\n               try:\n                    port \u003d int(parts[1])\n                    command_handler.stop_server(port\u003dport)\n               except ValueError:\n                   print(\"Invalid port number.\")\n               except Exception as ex:\n                  logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n            \n            elif command \u003d\u003d \"stop_all\":\n               command_handler.stop_all_servers()\n            \n            elif command \u003d\u003d \"add_route\":\n                if len(parts) !\u003d 2:\n                    print(\"Usage: add_route \u003cpath\u003e\")\n                    continue\n                path \u003d parts[1]\n                methods \u003d input(\"Enter HTTP methods (comma-separated, default: GET): \").strip().upper() or \"GET\"\n                methods \u003d [method.strip() for method in methods.split(\",\")]\n                command_handler.add_new_route(path\u003dpath, func\u003d\"lambda: {\\\"message\\\": \\\"Hello from the new route\\\"}\", methods\u003dmethods)\n\n\n            elif command \u003d\u003d \"shutdown\":\n                command_handler.stop_all_servers()\n                print(\"Shutting down all servers.\")\n                sys.exit(0)\n\n            elif command \u003d\u003d \"help\":\n                display_menu()\n\n            elif command \u003d\u003d \"exit\":\n                print(\"Exiting the program.\")\n                sys.exit(0)\n            \n            else:\n                print(\"Unknown command. Type \u0027help\u0027 to see the list of available commands\")\n\n        except Exception as ex:\n            logger.error(f\"An error occurred:\", ex, exc_info\u003dTrue)\n\n\nif __name__ \u003d\u003d \"__main__\":\n    main()\n```\n\n**Основные изменения:**\n\n1.  **`FastApiServer.get_routes()`**:\n    *   Добавлен метод `get_routes` в класс `FastApiServer`.\n    *   Этот метод возвращает список всех зарегистрированных маршрутов (пути и методы).\n2.  **`get_routes()`**:\n    *   Добавлена функция `get_routes` вне класса `FastApiServer`.\n    *   Эта функция использует `_api_server_instance`, чтобы получить список маршрутов и напечатать их.\n3.  **`CommandHandler.get_routes()`**:\n    *   Добавлен метод `get_routes` в класс `CommandHandler`.\n    *   Он вызывает функцию `get_routes()`.\n4.  **`main.display_menu()`**:\n    *   В меню добавлена команда `routes`, которая вызывает метод `get_routes` для отображения зарегистрированных роутов.\n5. **`main.main()`**\n  *   Добавил обработку комманды `routes`\n\n**Как использовать:**\n\n1.  Запустите `main.py`.\n2.  Введите `routes` в командной строке, чтобы увидеть список подключенных маршрутов.\n3.  Введите `help`, чтобы увидеть список доступных команд.\n4. Остальные команды работают как и раньше\n\n**Примечание:**\nВ команде `add_route`  функция `lambda` была заменена на передачу строки, это позволяет передавать анонимную функцию как параметр в XMLRPC. Это не оптимально, лучше использовать стандартную именованную функцию.\n```python\ndef hello_from_route():\n  return {\"message\": \"Hello from the new route\"}\n...\n command_handler.add_new_route(path\u003dpath, func\u003d\"hello_from_route\", methods\u003dmethods)\n```\n",
      "role": "model",
      "finishReason": "STOP"
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}