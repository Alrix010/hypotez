
# `file.py`
&nbsp;&nbsp;&nbsp;&nbsp; Модуль `file.py` предоставляет набор функций для работы с файлами и директориями, включая обработку больших файлов с помощью генераторов и рекурсивный поиск файлов.  Функции хорошо структурированы и имеют ясное назначение.  Добавленные функции обработки лишних пробелов и экранирования кавычек улучшают функциональность.

**1. `save_text_file(data, file_path, mode='w')`**

* **Назначение:**  Записывает данные в указанный текстовый файл.  Поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).
* **Входные данные:**
    * `data (str | list[str] | dict)`: Данные для записи в файл.  Может быть строкой, списком строк или словарем.
    * `file_path (str | Path)`: Путь к файлу, куда нужно записать данные.  Может быть строкой или объектом `Path` из библиотеки `pathlib`.
    * `mode (str, optional)`: Режим открытия файла.  По умолчанию `'w'` (запись, перезаписывает файл).  Можно использовать `'a'` (добавление, добавляет данные в конец файла).
* **Выходные данные:**
    * `bool`: `True`, если запись прошла успешно, `False` в случае ошибки.
* **Логика:**
    1. Создает директории, если они не существуют, используя `file_path.parent.mkdir(parents=True, exist_ok=True)`.
    2. Открывает файл в указанном режиме с кодировкой UTF-8.
    3. В зависимости от типа данных `data`:
        * Если это строка, записывает её в файл.
        * Если это список строк, записывает каждую строку с добавлением символа новой строки (`\n`).
        * Если это словарь, сериализует его в JSON с отступами для читаемости и записывает в файл.
    4. Возвращает `True` при успешной записи, `False` и логирует ошибку при возникновении исключения.


**2. `read_text_file_generator(file_path, as_list=False, extensions=None, chunk_size=8192, recursive=False, patterns=None)`**

* **Назначение:** Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов.  Поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.
* **Входные данные:**
    * `file_path (str | Path)`: Путь к файлу или директории.
    * `as_list (bool, optional)`:  Если `True`, возвращает генератор строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
    * `extensions (list[str], optional)`: Список расширений файлов для фильтрации при чтении директории.
    * `chunk_size (int, optional)`: Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.
    * `recursive (bool, optional)`:  Если `True`, рекурсивно обходит все поддиректории.
    * `patterns (str | list[str], optional)`: Шаблоны для фильтрации файлов (например, `'*.txt'`, `['*.txt', '*.csv']`).  Используется вместе с `recursive`.
* **Выходные данные:**
    * `Generator[str, None, None] | str | list[str] | None`:  Возвращает генератор строк (`as_list=True`), строку (`as_list=False` и файл), объединенную строку из всех файлов директории (`as_list=False` и директория), или `None` в случае ошибки.
* **Логика:**
    1. Проверяет, является ли `file_path` файлом или директорией.
    2. Для файлов:
        * Если `as_list=True`, использует `_read_file_lines_generator` для возврата генератора строк.
        * Если `as_list=False`, использует `_read_file_content` для возврата всего содержимого как строки.
    3. Для директорий:
        * Если `recursive=True`, рекурсивно находит все файлы, соответствующие `patterns` и `extensions`, и обрабатывает их.
        * Если `recursive=False`, обрабатывает только файлы в текущей директории.
        * Если `as_list=True`, возвращает генератор, объединяющий строки из всех файлов.
        * Если `as_list=False`, возвращает объединенную строку из всех файлов.
    4. Возвращает `None` при ошибках и логирует их.


**3. `read_text_file(file_path, as_list=False, extensions=None, exc_info=True, chunk_size=8192)`**

* **Назначение:**  Читает содержимое файла или директории.  Более простая версия, чем `read_text_file_generator`, не использующая генераторы.
* **Входные данные:**  Аналогичны `read_text_file_generator`, но без `recursive` и `patterns`.
* **Выходные данные:** `str | list[str] | None`: Строка (если `as_list=False`) или список строк (если `as_list=True`).  `None` в случае ошибки.
* **Логика:**  Проще, чем `read_text_file_generator`. Для директорий рекурсивно считывает все файлы, соответствующие `extensions`, и объединяет их содержимое в одну строку или список строк.


**4. `yield_text_from_files(file_path, as_list=False, chunk_size=8192)`**

* **Назначение:**  Читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`).  Вспомогательная функция для `read_text_file_generator`.
* **Входные данные:**
    * `file_path (str | Path)`: Путь к файлу.
    * `as_list (bool, optional)`: Флаг, указывающий на возврат генератора или строки.
    * `chunk_size (int, optional)`: Размер чанка для чтения.
* **Выходные данные:** `Generator[str, None, None] | str | None`:  Генератор строк или строка, или `None` при ошибке.
* **Логика:**  Использует `_read_file_lines_generator` или `_read_file_content` в зависимости от значения `as_list`.


**5. `_read_file_content(file_path, chunk_size)`**

* **Назначение:** Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки.  Используется для повышения эффективности при работе с очень большими файлами.
* **Входные данные:**
    * `file_path (Path)`: Путь к файлу.
    * `chunk_size (int)`: Размер чанка.
* **Выходные данные:** `str`:  Содержимое файла как одна строка.
* **Логика:** Читает файл по частям размером `chunk_size`, накапливая данные в переменной `content`, и возвращает итоговую строку.  Обрабатывает лишние пробелы и экранирует кавычки.


**6. `_read_file_lines_generator(file_path, chunk_size)`**

* **Назначение:** Вспомогательная функция для чтения файла построчно с помощью генератора.  Эффективна для больших файлов, поскольку не загружает весь файл в память сразу.
* **Входные данные:**
    * `file_path (Path)`: Путь к файлу.
    * `chunk_size (int)`: Размер чанка.
* **Выходные данные:** `Generator[str, None, None]`:  Генератор, который выдает строки файла по одной.
* **Логика:**  Читает файл по чанкам, разделяет чанк на строки с помощью `splitlines()`.  Обрабатывает случай, когда последняя строка в чанке неполная –  добавляет к ней следующий символ из файла.  Обрабатывает лишние пробелы и экранирует кавычки в каждой строке.


**7. `get_filenames_from_directory(directory, ext='*')`**

* **Назначение:**  Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.
* **Входные данные:**
    * `directory (str | Path)`: Путь к директории.
    * `ext (str | list[str], optional)`: Расширение или список расширений файлов для фильтрации.
* **Выходные данные:** `list[str]`:  Список имен файлов.
* **Логика:**  Итерирует по файлам в директории и возвращает список имен тех файлов, которые соответствуют указанному расширению (или всем файлам, если `ext='*'`).


**8. `recursively_yield_file_path(root_dir, patterns='*')`**

* **Назначение:**  Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.
* **Входные данные:**
    * `root_dir (str | Path)`: Корневая директория.
    * `patterns (str | list[str])`: Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).
* **Выходные данные:** `Generator[Path, None, None]`:  Генератор, который выдает пути к файлам.
* **Логика:** Использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.


**9. `recursively_get_file_path(root_dir, patterns='*')`**

* **Назначение:**  Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.
* **Входные данные:** Аналогичны `recursively_yield_file_path`.
* **Выходные данные:** `list[Path]`: Список путей к файлам.
* **Логика:**  Использует `Path.rglob()` и собирает все найденные пути в список.


**10. `recursively_read_text_files(root_dir, patterns, as_list=False)`**

* **Назначение:** Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.
* **Входные данные:**
    * `root_dir (str | Path)`: Корневая директория.
    * `patterns (str | list[str])`: Шаблоны имен файлов.
    * `as_list (bool, optional)`:  Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.
* **Выходные данные:** `list[str]`: Список содержимого файлов (либо список списков строк).
* **Логика:**  Использует `os.walk()` для рекурсивного обхода директории.  Читает файлы, соответствующие шаблонам, и добавляет их содержимое в результирующий список.


**11. `get_directory_names(directory)`**

* **Назначение:**  Возвращает список имен поддиректорий в указанной директории.
* **Входные данные:** `directory (str | Path)`: Путь к директории.
* **Выходные данные:** `list[str]`: Список имен поддиректорий.
* **Логика:** Итерирует по элементам в директории и возвращает список имен только тех, которые являются директориями.


**12. `remove_bom(path)`**

* **Назначение:** Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.  BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.
* **Входные данные:** `path (str | Path)`: Путь к файлу или директории.
* **Выходные данные:** `None`.
* **Логика:**  Если `path` – файл, удаляет BOM из него.  Если `path` – директория, рекурсивно обходит все `.py` файлы и удаляет BOM из них.


**13. `main()`**

* **Назначение:**  Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.
* **Входные данные:**  Нет.
* **Выходные данные:** `None`.
* **Логика:** Вызывает `remove_bom()` для директории `src`.

