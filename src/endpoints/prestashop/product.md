
# Модуль `PrestaProduct` (`src/endpoints/prestashop/product.py`)

## Назначение

Модуль `PrestaProduct` предназначен для непосредственного взаимодействия с **товарами** через PrestaShop Web Service API. Он наследуется от базового класса `PrestaShop` (из `api.py`), который обеспечивает общую функциональность для работы с API (методы CRUD, обработка запросов и ответов).

Класс `PrestaProduct` добавляет специфическую логику для работы именно с ресурсом `products` API PrestaShop, упрощая такие задачи, как:

1.  **Получение схемы товара:** Запрос структуры данных для ресурса `products`.
2.  **Добавление нового товара:** Прием данных о товаре в формате объекта `ProductFields`, их подготовка (включая обработку категорий) и отправка запроса на создание товара (`POST /api/products`).
3.  **Получение информации о товаре:** Запрос данных конкретного товара по его ID (`GET /api/products/{id}`).
4.  **Обработка иерархии категорий:** Автоматическое определение и добавление всех родительских категорий для товара при его создании.
5.  **Загрузка изображений:** (Неявно через `PrestaShop.create_binary` и `upload_image_from_url`) Возможность загрузить основное изображение для только что созданного товара.

Основной сценарий использования: после того как `Graber` собрал данные со страницы поставщика и заполнил объект `ProductFields`, этот объект передается в метод `add_new_product` класса `PrestaProduct` для создания соответствующего товара в магазине PrestaShop.

## Ключевые возможности и методы

*   **Наследование от `PrestaShop`:** Получает всю базовую функциональность для взаимодействия с API (аутентификация, выполнение запросов `_exec`, базовые CRUD-методы, пинг и т.д.).
*   **Конфигурация (`Config`):**
    *   Использует вложенный класс `Config` для определения `API_DOMAIN` и `API_KEY`.
    *   Поддерживает несколько режимов (`MODE`): 'dev', 'dev8', 'prod', позволяя легко переключаться между разными инстансами PrestaShop.
    *   Может считывать учетные данные из переменных окружения (`USE_ENV=True`) или из конфигурационного объекта `gs.credentials` (в зависимости от `MODE`).
*   **`__init__(self, api_key, api_domain, ...)`:**
    *   Инициализирует объект, передавая `api_key` и `api_domain` в конструктор родительского класса `PrestaShop`. Если они не переданы явно, используются значения из `Config`.
*   **`get_product_schema(self, resource_id=None, schema=None)`:**
    *   Запрашивает схему данных для ресурса `products` у API PrestaShop.
    *   Позволяет получить пустую схему (`schema='blank'`) для создания нового товара или полную схему (по умолчанию).
*   **`get_parent_category(self, id_category)`:**
    *   Вспомогательный метод для получения ID родительской категории для указанной `id_category`. Использует `self.read('categories', ...)`.
*   **`_add_parent_categories(self, f: ProductFields)`:**
    *   **Важный внутренний метод.** Принимает объект `ProductFields`.
    *   Анализирует список категорий, уже добавленных в `f.additional_categories` (включая `id_category_default`).
    *   Рекурсивно (через `get_parent_category`) находит **всех** родительских категорий для каждой из начальных категорий, поднимаясь по иерархии до корневых категорий (ID <= 2).
    *   Добавляет **уникальные** найденные родительские ID обратно в `f.additional_categories`, обеспечивая привязку товара ко всей ветке категорий.
*   **`get_product(self, id_product, **kwargs)`:**
    *   Получает данные конкретного товара из PrestaShop по его ID.
    *   Использует `self.read('products', resource_id=id_product)`.
    *   Возвращает словарь с данными товара.
*   **`add_new_product(self, f: ProductFields)`:**
    *   **Основной метод для создания товара.**
    *   Принимает заполненный объект `ProductFields`.
    *   Вызывает `_add_parent_categories(f)` для добавления родительских категорий.
    *   Вызывает `f.to_dict()` для преобразования данных товара в словарь, совместимый с API.
    *   Формирует тело запроса (включая обертку `{'prestashop': {'products': [...]}}`).
    *   Преобразует словарь в XML с помощью `dict2xml`.
    *   Отправляет `POST` запрос на `/api/products` с XML-данными с помощью `self.create('products', data=presta_product_xml)`.
    *   В случае успеха:
        *   Парсит ответ, получает ID созданного товара.
        *   Пытается загрузить изображение:
            *   Если в `f.local_image_path` есть путь к локальному файлу, использует `self.create_binary` для его загрузки.
            *   Если в `f.default_image_url` есть URL, использует `self.upload_image_from_url` для скачивания и загрузки.
        *   Логирует успех и возвращает `SimpleNamespace` с данными добавленного товара (из ответа API).
    *   В случае ошибки (при создании товара или загрузке изображения) логирует ошибку и возвращает пустой словарь `{}`.

## Типичный рабочий процесс

1.  **Сбор данных:** Экземпляр `Graber` (или его наследник) собирает данные со страницы товара поставщика и заполняет объект `ProductFields` (`f`).
2.  **Инициализация `PrestaProduct`:** Создается экземпляр `PrestaProduct` с нужными учетными данными API.
    ```python
    from src.endpoints.prestashop.product import PrestaProduct
    from src.endpoints.prestashop.product_fields import ProductFields

    # pf - это объект ProductFields, заполненный грабером
    pf: ProductFields = get_product_data_from_supplier()

    # Инициализация PrestaProduct (API ключи возьмутся из Config)
    pp = PrestaProduct()
    ```
3.  **Добавление товара:** Вызывается метод `add_new_product`.
    ```python
    # Добавление товара в PrestaShop
    result = pp.add_new_product(pf)

    if result:
        print(f"Товар успешно добавлен. ID: {result.id}")
    else:
        print("Не удалось добавить товар.")
    ```
4.  **Внутри `add_new_product`:**
    *   Определяются и добавляются родительские категории (`_add_parent_categories`).
    *   Данные `ProductFields` преобразуются в словарь (`pf.to_dict()`).
    *   Словарь преобразуется в XML (`dict2xml`).
    *   Отправляется POST-запрос в API (`self.create`).
    *   Загружается изображение (если доступно) (`self.create_binary` или `self.upload_image_from_url`).

## Примеры использования

В конце файла `product.py` приведены примеры функций:

*   **`example_add_new_product()`:** Демонстрирует, как можно вручную создать словарь данных (или загрузить из JSON-схемы) и отправить его для создания товара, используя метод `_exec` напрямую (для большей гибкости) или `create`. Этот пример полезен для отладки структуры данных, отправляемых в API.
*   **`example_get_product(id_product)`:** Показывает, как получить данные существующего товара по его ID и сохранить их в JSON-файл для анализа.

Эти примеры можно запустить, если файл `product.py` выполняется как основной скрипт (`if __name__ == '__main__':`).

```python
if __name__ == '__main__':
    # Получить данные товара с ID 2191 и сохранить в JSON
    example_get_product(2191)

    # Попытаться добавить новый товар на основе данных из файла схемы
    # (предварительно нужно создать или скачать файл 'product_schema.2191_....json')
    # example_add_new_product()
