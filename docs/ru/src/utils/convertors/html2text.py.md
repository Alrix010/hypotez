# Модуль `html2text`

## Обзор

Модуль `html2text` предназначен для преобразования HTML-документов в Markdown-форматированный текст. Он обеспечивает читаемость контента, удаляя HTML-теги и применяя Markdown-разметку для сохранения структуры документа. Модуль поддерживает различные опции, такие как обработка HTML-сущностей, обертывание текста и стилизацию списков.

## Подробней

Этот модуль является частью проекта `hypotez` и используется для конвертации HTML-контента в более простой и читаемый формат Markdown. Он может быть полезен для извлечения текста из веб-страниц, обработки HTML-писем и других задач, где требуется преобразование HTML в текстовый формат.

## Функции

### `has_key(x, y)`

**Назначение**: Проверяет, содержит ли словарь `x` ключ `y`.

**Параметры**:
- `x`: Словарь, в котором производится поиск ключа.
- `y`: Ключ, наличие которого проверяется в словаре.

**Возвращает**:
- `bool`: `True`, если словарь `x` содержит ключ `y`, иначе `False`.

**Как работает функция**:
Функция проверяет наличие ключа `y` в словаре `x`. Если у объекта `x` есть метод `has_key`, он используется для проверки наличия ключа. В противном случае используется оператор `in` для проверки наличия ключа в словаре.

**Примеры**:

```python
x = {'a': 1, 'b': 2}
print(has_key(x, 'a'))  # Вывод: True
print(has_key(x, 'c'))  # Вывод: False
```

### `name2cp(k)`

**Назначение**: Преобразует имя HTML-сущности в кодовую точку Unicode.

**Параметры**:
- `k` (str): Имя HTML-сущности.

**Возвращает**:
- `int`: Кодовая точка Unicode для данной HTML-сущности.

**Вызывает исключения**:
- `KeyError`: Если HTML-сущность не найдена.

**Как работает функция**:
Функция принимает имя HTML-сущности и возвращает соответствующую кодовую точку Unicode. Сначала функция проверяет, является ли сущность `'apos'`. Затем, если доступен атрибут `name2codepoint` в модуле `htmlentitydefs` (Python 2.3+), она использует его для преобразования имени в кодовую точку. В противном случае, она использует `entitydefs` и преобразует результат в кодовую точку Unicode.

**Примеры**:

```python
print(name2cp('copy'))  # doctest: +SKIP
# Вывод: 169
print(name2cp('uuml'))  # doctest: +SKIP
# Вывод: 252
```

### `charref(name)`

**Назначение**: Преобразует символьную ссылку (character reference) в символ Unicode.

**Параметры**:
- `name` (str): Символьная ссылка в виде строки (например, "160" или "x41").

**Возвращает**:
- `str`: Соответствующий символ Unicode.

**Как работает функция**:
Функция преобразует символьную ссылку (в виде десятичного или шестнадцатеричного числа) в символ Unicode. Сначала определяется основание системы счисления (10 или 16) в зависимости от префикса `x` или `X`. Затем число преобразуется в целое число и, если `UNICODE_SNOB` не установлен, проверяется наличие символа в словаре `unifiable_n`. Если символ найден в `unifiable_n`, возвращается соответствующее значение. В противном случае возвращается символ Unicode, соответствующий данному коду.

**Примеры**:

```python
print(charref('160'))  # doctest: +SKIP
# Вывод:  
print(charref('x41'))  # doctest: +SKIP
# Вывод: A
```

### `entityref(c)`

**Назначение**: Преобразует ссылку на HTML-сущность в символ Unicode.

**Параметры**:
- `c` (str): Строка, представляющая ссылку на HTML-сущность (например, "nbsp").

**Возвращает**:
- `str`: Соответствующий символ Unicode или исходная строка, если преобразование невозможно.

**Как работает функция**:
Функция пытается преобразовать ссылку на HTML-сущность в символ Unicode. Если глобальная настройка `UNICODE_SNOB` не установлена и сущность `c` присутствует в словаре `unifiable`, функция возвращает соответствующее значение из `unifiable`. В противном случае, функция пытается получить кодовую точку для сущности с помощью `name2cp(c)`. Если сущность не найдена (выбрасывается `KeyError`), функция возвращает исходную строку в формате "&c;". Если кодовая точка получена успешно, функция возвращает соответствующий символ Unicode.

**Примеры**:

```python
print(entityref('nbsp'))  # doctest: +SKIP
# Вывод:  
print(entityref('uuml'))  # doctest: +SKIP
# Вывод: ü
print(entityref('unknown'))
# Вывод: &unknown;
```

### `replaceEntities(s)`

**Назначение**: Заменяет HTML-сущности в строке на соответствующие символы.

**Параметры**:
- `s` (Match object): Объект Match, представляющий найденную HTML-сущность.

**Возвращает**:
- `str`: Строка, в которой HTML-сущность заменена на соответствующий символ.

**Как работает функция**:
Функция принимает объект Match, содержащий HTML-сущность, и заменяет её на соответствующий символ. Если сущность является символьной ссылкой (начинается с `#`), вызывается функция `charref` для преобразования ссылки в символ. В противном случае вызывается функция `entityref` для преобразования ссылки на HTML-сущность в символ.

**Примеры**:

```python
test_string = "&nbsp;Test&#160;"
def test_func(s):
    s = s.group(1)
    if s[0] == "#":
        return 'decoded_charref'
    else:
        return 'decoded_entityref'

r_unescape = re.compile(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));")
result = r_unescape.sub(test_func, test_string)

print(result)
# Вывод: decoded_entityrefTestdecoded_charref
```

### `unescape(s)`

**Назначение**: Декодирует HTML-сущности в строке.

**Параметры**:
- `s` (str): Строка, содержащая HTML-сущности.

**Возвращает**:
- `str`: Строка, в которой все HTML-сущности заменены на соответствующие символы.

**Как работает функция**:
Функция использует регулярное выражение `r_unescape` для поиска HTML-сущностей в строке `s` и заменяет их на соответствующие символы с помощью функции `replaceEntities`.

**Примеры**:

```python
print(unescape('&amp;'))
# Вывод: &
print(unescape('Test &eacute;'))
# Вывод: Test é
```

### `onlywhite(line)`

**Назначение**: Проверяет, состоит ли строка только из пробельных символов.

**Параметры**:
- `line` (str): Строка для проверки.

**Возвращает**:
- `bool`: `True`, если строка состоит только из пробельных символов, иначе `False`.

**Как работает функция**:
Функция проверяет, состоит ли строка только из пробельных символов. Она перебирает каждый символ в строке и, если находит символ, отличный от пробела, возвращает `False`. Если все символы в строке являются пробелами, функция возвращает `True`.

**Примеры**:

```python
print(onlywhite('   '))
# Вывод: True
print(onlywhite('  a '))
# Вывод: False
```

### `optwrap(text)`

**Назначение**: Оборачивает текст в абзацы заданной ширины.

**Параметры**:
- `text` (str): Текст для оборачивания.

**Возвращает**:
- `str`: Текст, обернутый в абзацы заданной ширины.

**Как работает функция**:
Функция оборачивает текст в абзацы заданной ширины `BODY_WIDTH`. Если `BODY_WIDTH` равно 0, функция возвращает исходный текст без изменений. Текст разбивается на абзацы по символу новой строки. Если абзац начинается не с пробела, дефиса или звездочки, он оборачивается с использованием функции `wrap` из модуля `textwrap`.

**Примеры**:

```python
BODY_WIDTH = 20
print(optwrap('This is a long line of text that needs to be wrapped.'))  # doctest: +SKIP
# Вывод:
# This is a long
# line of text that
# needs to be
# wrapped.
#
```

### `hn(tag)`

**Назначение**: Определяет уровень заголовка HTML-тега.

**Параметры**:
- `tag` (str): HTML-тег.

**Возвращает**:
- `int`: Уровень заголовка (1-9), если тег является заголовком, иначе 0.

**Как работает функция**:
Функция проверяет, является ли переданный тег HTML-заголовком (например, `h1`, `h2`). Если тег является заголовком, функция извлекает уровень заголовка из тега и возвращает его в виде целого числа. Если тег не является заголовком или уровень заголовка не является числом, функция возвращает 0.

**Примеры**:

```python
print(hn('h1'))
# Вывод: 1
print(hn('h6'))
# Вывод: 6
print(hn('p'))
# Вывод: 0
```

### `dumb_property_dict(style)`

**Назначение**: Преобразует строку CSS-стилей в словарь атрибутов.

**Параметры**:
- `style` (str): Строка CSS-стилей.

**Возвращает**:
- `dict`: Словарь, где ключи - это атрибуты CSS, а значения - их значения.

**Как работает функция**:
Функция принимает строку CSS-стилей и преобразует её в словарь, где ключами являются атрибуты CSS, а значениями - их значения. Строка разбивается на пары атрибут-значение по символу `;`, затем каждая пара разбивается по символу `:`, и из полученных частей создается словарь.

**Примеры**:

```python
print(dumb_property_dict('color: red; font-size: 12px'))
# Вывод: {'color': 'red', 'font-size': '12px'}
```

### `dumb_css_parser(data)`

**Назначение**: Преобразует CSS-данные в словарь селекторов и их стилей.

**Параметры**:
- `data` (str): Строка, содержащая CSS-данные.

**Возвращает**:
- `dict`: Словарь, где ключи - это CSS-селекторы, а значения - словари атрибутов стилей.

**Как работает функция**:
Функция принимает строку CSS-данных и преобразует её в словарь, где ключами являются CSS-селекторы, а значениями - словари атрибутов стилей. Функция сначала удаляет все `@import` предложения, затем разбивает строку на блоки по символу `}`, и каждый блок разбивается на селектор и стили по символу `{`. Затем для каждого селектора создается словарь стилей с помощью функции `dumb_property_dict`.

**Примеры**:

```python
css_data = 'body { color: black; } h1 { font-size: 20px; }'
print(dumb_css_parser(css_data))
# Вывод: {'body': {'color': 'black'}, 'h1': {'font-size': '20px'}}
```

### `element_style(attrs, style_def, parent_style)`

**Назначение**: Определяет итоговый стиль элемента на основе атрибутов, CSS-определений и стилей родительского элемента.

**Параметры**:
- `attrs` (dict): Словарь атрибутов элемента.
- `style_def` (dict): Словарь CSS-стилей, полученный из `dumb_css_parser`.
- `parent_style` (dict): Словарь стилей родительского элемента.

**Возвращает**:
- `dict`: Словарь, представляющий итоговый стиль элемента.

**Как работает функция**:
Функция определяет итоговый стиль элемента, учитывая стили родительского элемента, стили, определенные в CSS (`style_def`) и атрибуты элемента (`attrs`). Сначала создается копия стилей родительского элемента. Затем, если у элемента есть атрибут `class`, стили из CSS-определений (`style_def`) применяются к элементу. Если у элемента есть атрибут `style`, стили из этого атрибута также применяются к элементу.

**Примеры**:

```python
attrs = {'class': 'my-class', 'style': 'font-weight: bold'}
style_def = {'.my-class': {'color': 'red'}}
parent_style = {'font-size': '12px'}
print(element_style(attrs, style_def, parent_style))
# Вывод: {'font-size': '12px', 'color': 'red', 'font-weight': 'bold'}
```

### `google_list_style(style)`

**Назначение**: Определяет, является ли список упорядоченным или неупорядоченным на основе CSS-стилей Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `str`: `'ul'`, если список неупорядоченный, и `'ol'`, если список упорядоченный.

**Как работает функция**:
Функция анализирует CSS-стили элемента и определяет, является ли список упорядоченным или неупорядоченным. Если в стилях присутствует атрибут `list-style-type` и его значение равно `'disc'`, `'circle'`, `'square'` или `'none'`, то список считается неупорядоченным и функция возвращает `'ul'`. В противном случае список считается упорядоченным и функция возвращает `'ol'`.

**Примеры**:

```python
style1 = {'list-style-type': 'disc'}
style2 = {'list-style-type': 'decimal'}
print(google_list_style(style1))
# Вывод: ul
print(google_list_style(style2))
# Вывод: ol
```

### `google_nest_count(style)`

**Назначение**: Вычисляет уровень вложенности списка Google Docs на основе CSS-стилей.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `int`: Уровень вложенности списка.

**Как работает функция**:
Функция вычисляет уровень вложенности списка Google Docs на основе значения атрибута `margin-left` в CSS-стилях элемента. Если атрибут `margin-left` присутствует в стилях, его значение делится на `GOOGLE_LIST_INDENT` (количество пикселей, на которое Google Docs сдвигает вложенные списки), и результат преобразуется в целое число.

**Примеры**:

```python
style1 = {'margin-left': '36px'}
style2 = {'margin-left': '72px'}
print(google_nest_count(style1))
# Вывод: 1
print(google_nest_count(style2))
# Вывод: 2
```

### `google_has_height(style)`

**Назначение**: Проверяет, определен ли атрибут `height` в CSS-стилях элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `bool`: `True`, если атрибут `height` определен в стилях, иначе `False`.

**Как работает функция**:
Функция проверяет, присутствует ли атрибут `height` в словаре CSS-стилей элемента. Если атрибут присутствует, функция возвращает `True`, иначе `False`.

**Примеры**:

```python
style1 = {'height': '10px'}
style2 = {'width': '100px'}
print(google_has_height(style1))
# Вывод: True
print(google_has_height(style2))
# Вывод: False
```

### `google_text_emphasis(style)`

**Назначение**: Возвращает список всех модификаторов выделения текста из CSS-стилей элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `list`: Список модификаторов выделения текста.

**Как работает функция**:
Функция извлекает все модификаторы выделения текста из CSS-стилей элемента. Если в стилях присутствует атрибут `text-decoration`, его значение добавляется в список. Если в стилях присутствует атрибут `font-style`, его значение также добавляется в список. Если в стилях присутствует атрибут `font-weight`, его значение также добавляется в список.

**Примеры**:

```python
style1 = {'text-decoration': 'underline', 'font-style': 'italic'}
style2 = {'font-weight': 'bold'}
print(google_text_emphasis(style1))
# Вывод: ['underline', 'italic']
print(google_text_emphasis(style2))
# Вывод: ['font-weight']
```

### `google_fixed_width_font(style)`

**Назначение**: Проверяет, используется ли шрифт фиксированной ширины в CSS-стилях элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей элемента.

**Возвращает**:
- `bool`: `True`, если используется шрифт фиксированной ширины, иначе `False`.

**Как работает функция**:
Функция проверяет, используется ли шрифт фиксированной ширины в CSS-стилях элемента. Если в стилях присутствует атрибут `font-family` и его значение равно `'Courier New'` или `'Consolas'`, функция возвращает `True`. В противном случае функция возвращает `False`.

**Примеры**:

```python
style1 = {'font-family': 'Courier New'}
style2 = {'font-family': 'Arial'}
print(google_fixed_width_font(style1))
# Вывод: True
print(google_fixed_width_font(style2))
# Вывод: False
```

### `list_numbering_start(attrs)`

**Назначение**: Извлекает начальный номер из атрибутов элемента списка.

**Параметры**:
- `attrs` (dict): Словарь атрибутов элемента.

**Возвращает**:
- `int`: Начальный номер списка.

**Как работает функция**:
Функция извлекает начальный номер из атрибутов элемента списка. Если в атрибутах присутствует атрибут `start`, его значение преобразуется в целое число и уменьшается на 1. Если атрибут `start` отсутствует, функция возвращает 0.

**Примеры**:

```python
attrs1 = {'start': '3'}
attrs2 = {}
print(list_numbering_start(attrs1))
# Вывод: 2
print(list_numbering_start(attrs2))
# Вывод: 0
```

### `_html2text`

**Описание**: Класс для преобразования HTML в текст.

**Наследует**:
- `HTMLParser.HTMLParser`

**Атрибуты**:
- `out` (callable): Функция для вывода текста.
- `outtextlist` (list): Список для хранения выводимых символов.
- `outtext` (str): Результирующий текст.
- `quiet` (int): Счетчик для определения "тихих" зон (например, внутри тегов `<script>`).
- `p_p` (int): Количество символов новой строки для вставки перед следующим выводом.
- `outcount` (int): Счетчик выведенных символов.
- `start` (int): Флаг, указывающий на начало документа.
- `space` (int): Флаг, указывающий на необходимость вставить пробел.
- `a` (list): Список ссылок.
- `astack` (list): Стек атрибутов ссылок.
- `acount` (int): Счетчик ссылок.
- `list` (list): Список стилей списков.
- `blockquote` (int): Уровень цитирования.
- `pre` (int): Флаг, указывающий на нахождение внутри тега `<pre>`.
- `startpre` (int): Флаг, указывающий на начало тега `<pre>`.
- `code` (bool): Флаг, указывающий на нахождение внутри тега `<code>`.
- `br_toggle` (str): Строка для вставки перед символом новой строки.
- `lastWasNL` (bool): Флаг, указывающий, что последний выведенный символ был символом новой строки.
- `lastWasList` (bool): Флаг, указывающий, что последним обработанным тегом был тег списка.
- `style` (int): Счетчик тегов `<style>`.
- `style_def` (dict): Определения стилей CSS.
- `tag_stack` (list): Стек тегов.
- `emphasis` (int): Счетчик выделений текста.
- `drop_white_space` (int): Счетчик пробелов для удаления.
- `inheader` (bool): Флаг, указывающий на нахождение внутри заголовка.
- `abbr_title` (str | None): Заголовок текущего определения аббревиатуры.
- `abbr_data` (str | None): Последний внутренний HTML для определения аббревиатуры.
- `abbr_list` (dict): Список аббревиатур для вывода позже.
- `baseurl` (str): Базовый URL для ссылок.

**Методы**:

#### `__init__(self, out=None, baseurl='')`

**Назначение**: Инициализирует объект класса `_html2text`.

**Параметры**:
- `out` (callable, optional): Функция для вывода текста. По умолчанию `self.outtextf`.
- `baseurl` (str, optional): Базовый URL для ссылок. По умолчанию ''.

**Как работает функция**:
Конструктор класса `_html2text` инициализирует объект, устанавливая функцию вывода текста, базовый URL и различные флаги и счетчики, используемые в процессе преобразования HTML в текст.

#### `feed(self, data)`

**Назначение**: Обрабатывает данные HTML.

**Параметры**:
- `data` (str): Данные HTML для обработки.

**Как работает функция**:
Функция принимает данные HTML, заменяет в них конструкцию `</\' + \'script>` на `</ignore>` и передает их базовому классу `HTMLParser.HTMLParser` для дальнейшей обработки.

#### `outtextf(self, s)`

**Назначение**: Добавляет текст в список вывода.

**Параметры**:
- `s` (str): Текст для добавления.

**Как работает функция**:
Функция добавляет текст `s` в список `self.outtextlist`. Если текст не пустой, обновляет флаг `self.lastWasNL`, чтобы указать, заканчивается ли текст символом новой строки.

#### `close(self)`

**Назначение**: Завершает обработку HTML и возвращает результирующий текст.

**Как работает функция**:
Функция завершает обработку HTML, вызывая метод `close` базового класса `HTMLParser.HTMLParser`. Затем она вызывает `self.pbr()`, `self.o('', 0, 'end')`, объединяет все элементы списка `self.outtextlist` в одну строку и возвращает полученный текст.

#### `handle_charref(self, c)`

**Назначение**: Обрабатывает символьные ссылки.

**Параметры**:
- `c` (str): Символьная ссылка.

**Как работает функция**:
Функция обрабатывает символьную ссылку, вызывая функцию `charref` для преобразования ссылки в символ Unicode и выводит результат с помощью метода `self.o`.

#### `handle_entityref(self, c)`

**Назначение**: Обрабатывает ссылки на HTML-сущности.

**Параметры**:
- `c` (str): Ссылка на HTML-сущность.

**Как работает функция**:
Функция обрабатывает ссылку на HTML-сущность, вызывая функцию `entityref` для преобразования ссылки в символ Unicode и выводит результат с помощью метода `self.o`.

#### `handle_starttag(self, tag, attrs)`

**Назначение**: Обрабатывает открывающий тег.

**Параметры**:
- `tag` (str): Имя тега.
- `attrs` (list): Список атрибутов тега.

**Как работает функция**:
Функция обрабатывает открывающий тег, вызывая метод `handle_tag` с параметром `start=1`.

#### `handle_endtag(self, tag)`

**Назначение**: Обрабатывает закрывающий тег.

**Параметры**:
- `tag` (str): Имя тега.

**Как работает функция**:
Функция обрабатывает закрывающий тег, вызывая метод `handle_tag` с параметром `start=0`.

#### `previousIndex(self, attrs)`

**Назначение**: Возвращает индекс набора атрибутов ссылки в списке `self.a`.

**Параметры**:
- `attrs` (dict): Атрибуты ссылки.

**Возвращает**:
- `int | None`: Индекс набора атрибутов в списке `self.a`, если найден, иначе `None`.

**Как работает функция**:
Функция ищет набор атрибутов ссылки в списке `self.a` и возвращает его индекс. Если набор атрибутов не найден, функция возвращает `None`.

#### `drop_last(self, nLetters)`

**Назначение**: Удаляет последние `nLetters` символов из `self.outtext`, если не в "тихом" режиме.

**Параметры**:
- `nLetters` (int): Количество символов для удаления.

**Как работает функция**:
Если парсер не находится в "тихом" режиме (`self.quiet == 0`), функция удаляет последние `nLetters` символов из строки `self.outtext`.

#### `handle_emphasis(self, start, tag_style, parent_style)`

**Назначение**: Обрабатывает различные виды выделения текста (полужирный, курсив, зачеркнутый).

**Параметры**:
- `start` (bool): True, если это начало тега, False - если конец.
- `tag_style` (dict): Стили текущего тега.
- `parent_style` (dict): Стили родительского тега.

**Как работает функция**:
Функция обрабатывает различные виды выделения текста, такие как полужирный, курсив и зачеркнутый, на основе CSS-стилей Google Docs.

#### `handle_tag(self, tag, attrs, start)`

**Назначение**: Обрабатывает HTML-теги.

**Параметры**:
- `tag` (str): Имя тега.
- `attrs` (dict | None): Атрибуты тега.
- `start` (int): 1, если это открывающий тег, 0 - если закрывающий.

**Как работает функция**:
Функция обрабатывает HTML-теги, определяя их тип и выполняя соответствующие действия. Она обрабатывает заголовки, параграфы, разрывы строк, горизонтальные линии, теги `<head>`, `<style>`, `<body>`, `<blockquote>`, теги выделения текста, ссылки, изображения, списки, таблицы и теги `<pre>`.

#### `pbr(self)`

**Назначение**: Устанавливает флаг для вставки одного символа новой строки.

**Как работает функция**:
Если `self.p_p` равно 0, устанавливает `self.p_p` в 1.

#### `p(self)`

**Назначение**: Устанавливает флаг для вставки двух символов новой строки.

**Как работает функция**:
Устанавливает `self.p_p` в 2.

#### `soft_br(self)`

**Назначение**: Устанавливает флаг для вставки мягкого переноса строки.

**Как работает функция**:
Вызывает `self.pbr()` и устанавливает `self.br_toggle` в `  `.

#### `o(self, data, puredata=0, force=0)`

**Назначение**: Выводит данные с учетом текущего состояния парсера.

**Параметры**:
- `data` (str): Данные для вывода.
- `puredata` (int, optional): Флаг, указывающий, что данные не содержат HTML-теги. По умолчанию 0.
- `force` (int | str, optional): Флаг, указывающий на принудительный вывод данных. По умолчанию 0.

**Как работает функция**:
Функция выводит данные с учетом текущего состояния парсера, такого как "тихий" режим, уровень цитирования, нахождение внутри тега `<pre>`, необходимость вставки пробела или символа новой строки.

#### `handle_data(self, data)`

**Назначение**: Обрабатывает текстовые данные.

**Параметры**:
- `data` (str): Текстовые данные для обработки.

**Как работает функция**:
Функция обрабатывает текстовые данные, добавляя их в список вывода и обновляя флаги состояния парсера.

#### `unknown_decl(self, data)`

**Назначение**: Обрабатывает неизвестные объявления.

**Параметры**:
- `data` (str): Неизвестные данные объявления.

**Как работает функция**:
Функция ничего не делает, просто принимает данные.

### `wrapwrite(text)`

**Назначение**: Кодирует текст в UTF-8 и выводит его в `sys.stdout`.

**Параметры**:
- `text` (str): Текст для вывода.

**Как работает функция**:
Функция кодирует текст в UTF-8 и выводит его в `sys.stdout`. В Python 3 используется `sys.stdout.buffer.write`, в Python 2 - `sys.stdout.write`.

**Примеры**:

```python
wrapwrite('Hello, world!')  # doctest: +SKIP
# Вывод: Hello, world!
```

### `html2text_file(html, out=wrapwrite, baseurl='')`

**Назначение**: Преобразует HTML-код в текст и выводит его с использованием указанной функции вывода.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `out` (callable, optional): Функция для вывода текста. По умолчанию `wrapwrite`.
- `baseurl` (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию ''.

**Как работает функция**:
Функция создает экземпляр класса `_html2text`, передает ему HTML-код для обработки и возвращает результирующий текст.

**Примеры**:

```python
html = '<p>Hello, <b>world</b>!</p>'
html2text_file(html)  # doctest: +SKIP
# Вывод: Hello, **world**!
```

### `html2text(html, baseurl='')`

**Назначение**: Преобразует HTML-код в текст с возможностью обертывания текста по заданной ширине.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `baseurl` (str, optional): Базовый URL для разрешения относительных ссылок. По умолчанию ''.

**Возвращает**:
- `str`: Преобразованный текст.

**Как работает функция**:
Функция преобразует HTML-код в текст с помощью функции `html2text_file` и оборачивает текст по заданной ширине с помощью функции `optwrap`.

**Примеры**:

```python
html = '<p>This is a long line of text.</p>'
html2text(html)  # doctest: +SKIP
# Вывод: This is a long line of text.
```

### `Storage`

**Описание**: Пустой класс для хранения опций.

### `options`

**Описание**: Объект класса `Storage`, используемый для хранения опций.

## Параметры класса

- `google_doc` (bool): Флаг, указывающий, что входной HTML-код является документом Google Docs.
- `ul_item_mark` (str): Маркер для элементов неупорядоченного списка.

## Запуск из командной строки

Модуль можно запустить из командной строки, указав имя файла или URL в качестве аргумента. Можно также указать кодировку входного файла.

Пример:

```
python html2text.py input.html utf-8
```
```
python html2text.py http://example.com utf-8