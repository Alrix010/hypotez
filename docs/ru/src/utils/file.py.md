# Модуль `src.utils.file`

## Обзор

Модуль `src.utils.file` предоставляет набор утилит для работы с файлами, включая чтение, запись, поиск и обработку текстовых файлов. Он поддерживает чтение и запись файлов различных размеров, а также рекурсивный поиск файлов в директориях.

## Подробнее

Модуль содержит функции для сохранения данных в текстовые файлы, чтения содержимого файлов, получения списка файлов в директории и рекурсивного поиска файлов по заданным шаблонам. Он также включает функции для удаления BOM (Byte Order Mark) из файлов.

## Функции

### `save_text_file`

**Назначение**: Сохраняет данные в текстовый файл.

**Параметры**:

- `data` (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.
- `file_path` (str | Path): Путь к файлу для сохранения.
- `mode` (str, optional): Режим записи файла ('w' для записи, 'a' для добавления). По умолчанию 'w'.

**Возвращает**:

- `bool`: `True`, если файл успешно сохранен, `False` в противном случае.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при записи в файл.

**Как работает функция**:

Функция принимает путь к файлу и данные для сохранения. Она создает родительские директории, если они не существуют, и записывает данные в файл в указанном режиме. Если данные являются списком, каждая строка записывается в файл с новой строки. Если данные являются словарем, они записываются в файл в формате JSON с отступами.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
data = 'Пример текста'
result = save_text_file(file_path, data)
print(result) # Вывод: True
```

### `read_text_file_generator`

**Назначение**: Читает содержимое файла(ов) или директории с использованием генератора для экономии памяти.

**Параметры**:

- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах. По умолчанию 8192.
- `recursive` (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно. По умолчанию `False`.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске. По умолчанию `None`.

**Возвращает**:

- `Generator[str, None, None] | str | list[str] | None`:
    - Если `as_list` is `True` и `file_path` является файлом, возвращает генератор строк.
    - Если `as_list` is `True` и `file_path` является директорией и `recursive` is `True`, возвращает генератор строк.
    - Если `as_list` is `False` и `file_path` является файлом, возвращает строку.
    - Если `as_list` is `False` и `file_path` является директорией, возвращает объединенную строку.
    - Возвращает `None` в случае ошибки.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:

Функция принимает путь к файлу или директории и возвращает содержимое файла в виде генератора строк или одной строки. Если указан путь к директории, функция может рекурсивно обходить все поддиректории и читать файлы с заданными расширениями. Функция использует генератор для чтения больших файлов по частям, что позволяет экономить память.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
content = read_text_file_generator(file_path)
if content:
    print(f'File content: {content[:100]}...')
# Вывод: File content: Пример текста...
```

### `read_text_file`

**Назначение**: Читает содержимое файла.

**Параметры**:

- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает содержимое в виде списка строк. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `exc_info` (bool, optional): Если `True`, логирует трассировку ошибки. По умолчанию `True`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах. По умолчанию 8192.

**Возвращает**:

- `str | list[str] | None`: Содержимое файла в виде строки или списка строк, или `None`, если произошла ошибка.

**Как работает функция**:

Функция принимает путь к файлу и возвращает его содержимое в виде строки или списка строк. Если указан путь к директории, функция рекурсивно обходит все поддиректории и читает файлы с заданными расширениями. Функция также выполняет дополнительную обработку содержимого файла, заменяя множественные пробелы на один и экранируя двойные кавычки.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
    print(f'File content: {content[:100]}...')
# Вывод: File content: Пример текста...
```

### `yield_text_from_files`

**Назначение**: Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

**Параметры**:

- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. По умолчанию `False`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах. По умолчанию 8192.

**Возвращает**:

- `Generator[str, None, None] | str | None`: Генератор строк, объединенная строка или `None` в случае ошибки.

**Как работает функция**:

Функция принимает путь к файлу и возвращает его содержимое в виде генератора строк или одной строки. Если `as_list` равен `True`, функция возвращает генератор, который выдает строки из файла по одной. В противном случае функция возвращает одну строку, содержащую все содержимое файла.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
for line in yield_text_from_files(file_path, as_list=True):
    print(line)
# Вывод:
# Первая строка файла
# Вторая строка файла
```

### `_read_file_content`

**Назначение**: Читает содержимое файла по чанкам и возвращает как строку.

**Параметры**:

- `file_path` (Path): Путь к файлу для чтения.
- `chunk_size` (int): Размер чанка для чтения файла в байтах.

**Возвращает**:

- `str`: Содержимое файла в виде строки.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:

Функция принимает путь к файлу и размер чанка и читает файл по частям, объединяя прочитанные чанки в одну строку. Функция также выполняет дополнительную обработку содержимого файла, заменяя множественные пробелы на один и экранируя двойные кавычки.

### `_read_file_lines_generator`

**Назначение**: Читает файл по строкам с помощью генератора.

**Параметры**:

- `file_path` (Path): Путь к файлу для чтения.
- `chunk_size` (int): Размер чанка для чтения файла в байтах.

**Yields**:

- `str`: Строки из файла.

**Вызывает исключения**:

- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:

Функция принимает путь к файлу и размер чанка и читает файл по частям, разделяя каждый чанк на строки. Функция использует генератор для выдачи строк по одной, что позволяет экономить память при работе с большими файлами. Функция также выполняет дополнительную обработку каждой строки, заменяя множественные пробелы на один и экранируя двойные кавычки.

### `get_filenames_from_directory`

**Назначение**: Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.

**Параметры**:

- `directory` (str | Path): Путь к директории для поиска.
- `ext` (str | list[str], optional): Расширения для фильтрации. По умолчанию '*'.

**Возвращает**:

- `list[str]`: Список имен файлов, найденных в директории.

**Как работает функция**:

Функция принимает путь к директории и список расширений и возвращает список имен файлов, найденных в директории, которые соответствуют заданным расширениям. Если список расширений не указан, функция возвращает имена всех файлов в директории.

**Примеры**:

```python
from pathlib import Path
directory = Path('.')
get_filenames_from_directory(directory, ['.txt', '.md'])
# Вывод: ['example.txt', 'readme.md']
```

### `recursively_yield_file_path`

**Назначение**: Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

**Параметры**:

- `root_dir` (str | Path): Корневая директория для поиска.
- `patterns` (str | list[str]): Шаблоны для фильтрации файлов.

**Yields**:

- `Path`: Путь к файлу, соответствующему шаблону.

**Как работает функция**:

Функция принимает путь к корневой директории и список шаблонов и рекурсивно обходит все поддиректории, возвращая пути ко всем файлам, которые соответствуют заданным шаблонам.

**Примеры**:

```python
from pathlib import Path
root_dir = Path('.')
for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
    print(path)
# Вывод:
# ./example.txt
# ./readme.md
```

### `recursively_get_file_path`

**Назначение**: Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

**Параметры**:

- `root_dir` (str | Path): Корневая директория для поиска.
- `patterns` (str | list[str]): Шаблоны для фильтрации файлов.

**Возвращает**:

- `list[Path]`: Список путей к файлам, соответствующим шаблонам.

**Как работает функция**:

Функция принимает путь к корневой директории и список шаблонов и рекурсивно обходит все поддиректории, возвращая список путей ко всем файлам, которые соответствуют заданным шаблонам.

**Примеры**:

```python
from pathlib import Path
root_dir = Path('.')
paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
print(paths)
# Вывод: [Path('./example.txt'), Path('./readme.md')]
```

### `recursively_read_text_files`

**Назначение**: Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.

**Параметры**:

- `root_dir` (str | Path): Путь к корневой директории для поиска.
- `patterns` (str | list[str]): Шаблон(ы) имени файла для фильтрации. Может быть как одиночным шаблоном (например, '*.txt'), так и списком.
- `as_list` (bool, optional): Если `True`, то возвращает содержимое файла как список строк. По умолчанию `False`.

**Возвращает**:

- `list[str]`: Список содержимого файлов (или список строк, если `as_list=True`), соответствующих заданным шаблонам.

**Как работает функция**:

Функция принимает путь к корневой директории, список шаблонов и флаг `as_list` и рекурсивно обходит все поддиректории, читая текстовые файлы, которые соответствуют заданным шаблонам. Если флаг `as_list` установлен в `True`, функция возвращает содержимое файлов в виде списка строк. В противном случае функция возвращает содержимое файлов в виде списка строк.

**Примеры**:

```python
from pathlib import Path
root_dir = Path('.')
contents = recursively_read_text_files(root_dir, ['*.txt', '*.md'], as_list=True)
for line in contents:
    print(line)
# Вывод:
# Содержимое example.txt
# Первая строка readme.md
# Вторая строка readme.md
```

### `get_directory_names`

**Назначение**: Возвращает список имен директорий из указанной директории.

**Параметры**:

- `directory` (str | Path): Путь к директории, из которой нужно получить имена.

**Возвращает**:

- `list[str]`: Список имен директорий, найденных в указанной директории.

**Как работает функция**:

Функция принимает путь к директории и возвращает список имен поддиректорий, найденных в указанной директории.

**Примеры**:

```python
from pathlib import Path
directory = Path('.')
get_directory_names(directory)
# Вывод: ['dir1', 'dir2']
```

### `remove_bom`

**Назначение**: Удаляет BOM из текстового файла или из всех файлов Python в директории.

**Параметры**:

- `path` (str | Path): Путь к файлу или директории.

**Как работает функция**:

Функция принимает путь к файлу или директории и удаляет BOM (Byte Order Mark) из указанного файла или из всех файлов Python в указанной директории.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')
with open(file_path, 'w', encoding='utf-8') as f:
    f.write('\ufeffПример текста с BOM')
remove_bom(file_path)
with open(file_path, 'r', encoding='utf-8') as f:
    print(f.read())
# Вывод: Пример текста с BOM
```

### `main`

**Назначение**: Точка входа для удаления BOM в файлах Python.

**Как работает функция**:

Функция `main` определяет корневую директорию `src` и вызывает функцию `remove_bom` для удаления BOM из всех файлов Python в этой директории.