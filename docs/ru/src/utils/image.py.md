# Модуль `src.utils.image`

## Обзор

Модуль предоставляет асинхронные функции для загрузки, сохранения и обработки изображений.
Он включает в себя такие функции, как сохранение изображений из URL-адресов, сохранение данных изображений в файлы,
извлечение данных изображений, поиск случайных изображений в каталогах, добавление водяных знаков, изменение размера
и преобразование форматов изображений.

## Подробнее

Модуль предназначен для упрощения задач обработки изображений, предоставляя удобные функции для выполнения общих операций.
Он использует библиотеки `aiohttp`, `aiofiles` и `PIL` (Pillow) для обеспечения асинхронной загрузки и обработки изображений.
Модуль также включает ведение журнала для записи ошибок и предупреждений.

## Классы

### `ImageError`

**Описание**: Пользовательское исключение для ошибок, связанных с изображениями.
**Наследует**: `Exception`
**Атрибуты**:
- Отсутствуют

**Методы**:
- Отсутствуют

## Функции

### `save_image_from_url_async`

**Назначение**: Асинхронно загружает изображение из URL-адреса и сохраняет его локально.

**Параметры**:
- `image_url` (str): URL-адрес для загрузки изображения.
- `filename` (Union[str, Path]): Имя файла для сохранения изображения.

**Возвращает**:
- `Optional[str]`: Путь к сохраненному файлу или `None`, если операция не удалась.

**Вызывает исключения**:
- `ImageError`: Если загрузка или сохранение изображения не удается.

**Как работает функция**:
1. Функция принимает URL-адрес изображения и имя файла в качестве входных данных.
2. Она использует `aiohttp.ClientSession` для асинхронной отправки HTTP-запроса для загрузки изображения.
3. Функция проверяет статус ответа и вызывает исключение `HTTPError` для плохих ответов (4xx или 5xx).
4. Полученные данные изображения считываются из ответа.
5. Функция вызывает `save_image_async` для асинхронного сохранения данных изображения в указанный файл.
6. В случае успеха возвращается путь к сохраненному файлу; в противном случае возвращается `None`.
7. При возникновении каких-либо исключений они перехватываются, регистрируются с помощью `logger.error`, а затем вызывается исключение `ImageError`.

**Примеры**:

```python
import asyncio
from pathlib import Path

async def main():
    image_url = "https://www.easygifanimator.net/images/samples/video-to-gif-sample.gif"
    filename = Path("downloaded_image.gif")
    result = await save_image_from_url_async(image_url, filename)
    if result:
        print(f"Изображение успешно сохранено в: {result}")
    else:
        print("Не удалось сохранить изображение.")

if __name__ == "__main__":
    asyncio.run(main())
```

### `save_image`

**Назначение**: Сохраняет данные изображения в файл в указанном формате.

**Параметры**:
- `image_data` (bytes): Двоичные данные изображения.
- `file_name` (Union[str, Path]): Имя файла для сохранения изображения.
- `format` (str): Формат для сохранения изображения, по умолчанию "PNG".

**Возвращает**:
- `Optional[str]`: Путь к сохраненному файлу или `None`, если операция не удалась.

**Вызывает исключения**:
- `ImageError`: Если файл не может быть создан, сохранен или если сохраненный файл пуст.

**Как работает функция**:
1. Функция принимает двоичные данные изображения, имя файла и формат в качестве входных данных.
2. Она создает объект `Path` из `file_name`.
3. Функция пытается создать родительский каталог файла, если он не существует.
4. Он использует `BytesIO` для чтения данных изображения и открытия его с помощью PIL (`Image.open`).
5. Изображение сохраняется в `BytesIO` в указанном формате.
6. Функция записывает данные изображения из `BytesIO` в указанный файл.
7. Он проверяет, был ли создан файл и не пуст ли он.
8. В случае успеха возвращается путь к сохраненному файлу; в противном случае возвращается `None`.
9. При возникновении каких-либо исключений они перехватываются, регистрируются с помощью `logger.exception`, а затем вызывается исключение `ImageError`.

**Примеры**:

```python
from pathlib import Path
import requests

# Пример с использованием URL
image_url = "https://www.easygifanimator.net/images/samples/video-to-gif-sample.gif"
filename = Path("downloaded_image.gif")

# Чтение данных изображения из URL
response = requests.get(image_url)
image_data = response.content

file_path = save_image(image_data, filename)

if file_path:
    print(f"Изображение успешно сохранено в: {file_path}")
else:
    print("Не удалось сохранить изображение.")
```

### `save_image_async`

**Назначение**: Асинхронно сохраняет данные изображения в файл в указанном формате.

**Параметры**:
- `image_data` (bytes): Двоичные данные изображения.
- `file_name` (Union[str, Path]): Имя файла для сохранения изображения.
- `format` (str): Формат для сохранения изображения, по умолчанию "PNG".

**Возвращает**:
- `Optional[str]`: Путь к сохраненному файлу или `None`, если операция не удалась.

**Вызывает исключения**:
- `ImageError`: Если файл не может быть создан, сохранен или если сохраненный файл пуст.

**Как работает функция**:
1. Функция принимает двоичные данные изображения, имя файла и формат в качестве входных данных.
2. Она создает объект `Path` из `file_name`.
3. Функция асинхронно пытается создать родительский каталог файла, если он не существует.
4. Функция записывает данные изображения в указанный файл, используя `aiofiles`.
5. Он проверяет, был ли создан файл и не пуст ли он.
6. В случае успеха возвращается путь к сохраненному файлу; в противном случае возвращается `None`.
7. При возникновении каких-либо исключений они перехватываются, регистрируются с помощью `logger.exception`, а затем вызывается исключение `ImageError`.

**Примеры**:

```python
import asyncio
import aiohttp
from pathlib import Path

async def main():
    image_url = "https://www.easygifanimator.net/images/samples/video-to-gif-sample.gif"
    filename = Path("downloaded_image.gif")

    async with aiohttp.ClientSession() as session:
        async with session.get(image_url) as response:
            image_data = await response.read()

    file_path = await save_image_async(image_data, filename)

    if file_path:
        print(f"Изображение успешно сохранено в: {file_path}")
    else:
        print("Не удалось сохранить изображение.")

if __name__ == "__main__":
    asyncio.run(main())
```

### `get_image_bytes`

**Назначение**: Считывает изображение с помощью Pillow и возвращает его байты в формате JPEG.

**Параметры**:
- `image_path` (Path): Путь к файлу изображения.
- `raw` (bool): Если `True`, возвращает объект `BytesIO`; в противном случае возвращает байты. По умолчанию `True`.

**Возвращает**:
- `Optional[Union[BytesIO, bytes]]`: Байты изображения в формате JPEG или `None`, если происходит ошибка.

**Как работает функция**:
1. Функция принимает путь к файлу изображения и логическое значение `raw` в качестве входных данных.
2. Она пытается открыть изображение с помощью `Image.open`.
3. Изображение сохраняется в `BytesIO` в формате JPEG.
4. Если `raw` имеет значение `True`, возвращается объект `BytesIO`; в противном случае возвращаются байты из `BytesIO`.
5. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

image_path = Path("downloaded_image.jpg")  # Замените на реальный путь к изображению
image_bytes = get_image_bytes(image_path)

if image_bytes:
    print(f"Байты изображения успешно получены.")
else:
    print("Не удалось получить байты изображения.")
```

### `get_raw_image_data`

**Назначение**: Извлекает необработанные двоичные данные файла, если он существует.

**Параметры**:
- `file_name` (Union[str, Path]): Имя или путь к файлу для чтения.

**Возвращает**:
- `Optional[bytes]`: Двоичные данные файла или `None`, если файл не существует или происходит ошибка.

**Как работает функция**:
1. Функция принимает имя файла или путь в качестве входных данных.
2. Она создает объект `Path` из `file_name`.
3. Функция проверяет, существует ли файл.
4. Если файл существует, функция пытается прочитать двоичные данные файла с помощью `file_path.read_bytes()`.
5. В случае успеха возвращаются двоичные данные файла; в противном случае возвращается `None`.
6. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

file_path = Path("downloaded_image.gif")  # Замените на реальный путь к изображению
raw_data = get_raw_image_data(file_path)

if raw_data:
    print(f"Двоичные данные успешно получены.")
else:
    print("Не удалось получить двоичные данные.")
```

### `random_image`

**Назначение**: Рекурсивно ищет случайное изображение в указанном каталоге.

**Параметры**:
- `root_path` (Union[str, Path]): Каталог для поиска изображений.

**Возвращает**:
- `Optional[str]`: Путь к случайному изображению или `None`, если изображения не найдены.

**Как работает функция**:
1. Функция принимает путь к корневому каталогу в качестве входных данных.
2. Она определяет список расширений изображений для поиска (`.jpg`, `.jpeg`, `.png`, `.gif`, `.bmp`).
3. Функция рекурсивно ищет все файлы в каталоге и фильтрует те, которые являются файлами и имеют одно из указанных расширений изображений.
4. Если изображения не найдены, функция регистрирует предупреждение с помощью `logger.warning` и возвращает `None`.
5. В противном случае функция выбирает случайный файл изображения из списка и возвращает его путь.

**Примеры**:

```python
from pathlib import Path

root_path = Path(".")  # Текущий каталог
random_image_path = random_image(root_path)

if random_image_path:
    print(f"Случайное изображение: {random_image_path}")
else:
    print("Изображения не найдены.")
```

### `add_text_watermark`

**Назначение**: Добавляет текстовый водяной знак на изображение.

**Параметры**:
- `image_path` (Union[str, Path]): Путь к файлу изображения.
- `watermark_text` (str): Текст для использования в качестве водяного знака.
- `output_path` (Optional[Union[str, Path]]): Путь для сохранения изображения с водяным знаком. По умолчанию перезаписывает исходное изображение.

**Возвращает**:
- `Optional[str]`: Путь к изображению с водяным знаком или `None` в случае сбоя.

**Как работает функция**:
1. Функция принимает путь к изображению, текст водяного знака и путь вывода (необязательно) в качестве входных данных.
2. Она открывает изображение с помощью PIL и преобразует его в формат RGBA.
3. Создается прозрачный слой для водяного знака.
4. Определяется размер шрифта на основе размеров изображения.
5. Текст водяного знака рисуется на прозрачном слое.
6. Изображение и водяной знак объединяются с использованием альфа-композитинга.
7. Изображение с водяным знаком сохраняется в указанном пути вывода.
8. В случае успеха возвращается путь к изображению с водяным знаком; в противном случае возвращается `None`.
9. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

image_path = Path("downloaded_image.gif")  # Замените на реальный путь к изображению
watermark_text = "Пример водяного знака"
output_path = Path("watermarked_image.png")
watermarked_image_path = add_text_watermark(image_path, watermark_text, output_path)

if watermarked_image_path:
    print(f"Изображение с водяным знаком успешно сохранено в: {watermarked_image_path}")
else:
    print("Не удалось добавить водяной знак на изображение.")
```

### `add_image_watermark`

**Назначение**: Добавляет водяной знак к изображению и сохраняет результат в указанном пути вывода.

**Параметры**:
- `input_image_path` (Path): Путь к исходному изображению.
- `watermark_image_path` (Path): Путь к изображению водяного знака.
- `output_image_path` (Optional[Path]): Путь для сохранения изображения с водяным знаком. Если не указан, изображение будет сохранено в каталоге "output".

**Возвращает**:
- `Optional[Path]`: Путь к сохраненному изображению с водяным знаком или `None`, если операция не удалась.

**Как работает функция**:
1. Функция принимает путь к входному изображению, путь к изображению водяного знака и путь вывода (необязательно) в качестве входных данных.
2. Она открывает входное изображение и изображение водяного знака с помощью PIL.
3. Размер водяного знака изменяется до 8% от ширины базового изображения.
4. Положение водяного знака определяется как нижний правый угол с отступом 20px.
5. Создается новый прозрачный слой для объединения изображений.
6. Базовое изображение вставляется на новый слой.
7. Водяной знак вставляется поверх базового изображения.
8. Проверяется режим изображения, и прозрачный слой преобразуется в исходный режим.
9. Окончательное изображение сохраняется в указанном пути вывода с оптимизированным качеством.
10. В случае успеха возвращается путь к изображению с водяным знаком; в противном случае возвращается `None`.
11. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

input_image_path = Path("downloaded_image.gif")  # Замените на реальный путь к изображению
watermark_image_path = Path("watermark.png")  # Замените на реальный путь к изображению водяного знака
output_image_path = Path("image_with_watermark.png")

watermarked_image_path = add_image_watermark(input_image_path, watermark_image_path, output_image_path)

if watermarked_image_path:
    print(f"Изображение с водяным знаком успешно сохранено в: {watermarked_image_path}")
else:
    print("Не удалось добавить водяной знак на изображение.")
```

### `resize_image`

**Назначение**: Изменяет размер изображения до указанных размеров.

**Параметры**:
- `image_path` (Union[str, Path]): Путь к файлу изображения.
- `size` (Tuple[int, int]): Кортеж, содержащий желаемую ширину и высоту изображения.
- `output_path` (Optional[Union[str, Path]]): Путь для сохранения изображения с измененным размером. По умолчанию перезаписывает исходное изображение.

**Возвращает**:
- `Optional[str]`: Путь к изображению с измененным размером или `None` в случае сбоя.

**Как работает функция**:
1. Функция принимает путь к изображению, кортеж размера и путь вывода (необязательно) в качестве входных данных.
2. Она открывает изображение с помощью PIL.
3. Размер изображения изменяется до указанных размеров.
4. Изображение с измененным размером сохраняется в указанном пути вывода.
5. В случае успеха возвращается путь к изображению с измененным размером; в противном случае возвращается `None`.
6. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

image_path = Path("downloaded_image.gif")  # Замените на реальный путь к изображению
size = (500, 300)  # Ширина и высота
output_path = Path("resized_image.png")
resized_image_path = resize_image(image_path, size, output_path)

if resized_image_path:
    print(f"Изображение с измененным размером успешно сохранено в: {resized_image_path}")
else:
    print("Не удалось изменить размер изображения.")
```

### `convert_image`

**Назначение**: Преобразует изображение в указанный формат.

**Параметры**:
- `image_path` (Union[str, Path]): Путь к файлу изображения.
- `format` (str): Формат для преобразования изображения (например, "JPEG", "PNG").
- `output_path` (Optional[Union[str, Path]]): Путь для сохранения преобразованного изображения. По умолчанию перезаписывает исходное изображение.

**Возвращает**:
- `Optional[str]`: Путь к преобразованному изображению или `None` в случае сбоя.

**Как работает функция**:
1. Функция принимает путь к изображению, формат и путь вывода (необязательно) в качестве входных данных.
2. Она открывает изображение с помощью PIL.
3. Изображение сохраняется в указанном формате в указанном пути вывода.
4. В случае успеха возвращается путь к преобразованному изображению; в противном случае возвращается `None`.
5. Если во время процесса возникают какие-либо исключения, они перехватываются, регистрируются с помощью `logger.error`, и возвращается `None`.

**Примеры**:

```python
from pathlib import Path

image_path = Path("downloaded_image.gif")  # Замените на реальный путь к изображению
format = "JPEG"  # Формат
output_path = Path("converted_image.jpeg")
converted_image_path = convert_image(image_path, format, output_path)

if converted_image_path:
    print(f"Изображение успешно преобразовано и сохранено в: {converted_image_path}")
else:
    print("Не удалось преобразовать изображение.")
```

### `process_images_with_watermark`

**Назначение**: Обрабатывает все изображения в указанной папке, добавляя водяной знак и сохраняя их в каталоге "output".

**Параметры**:
- `folder_path` (Path): Путь к папке, содержащей изображения.
- `watermark_path` (Path): Путь к изображению водяного знака.

**Возвращает**:
- `None`

**Как работает функция**:
1. Функция принимает путь к папке и путь к водяному знаку в качестве входных данных.
2. Она проверяет, существует ли папка.
3. Если папка не существует, регистрируется ошибка с помощью `logger.error`, и функция возвращается.
4. Создается каталог "output", если он не существует.
5. Функция перебирает каждый файл в папке.
6. Для каждого файла проверяется, является ли он файлом и имеет ли он расширение `.png`, `.jpg` или `.jpeg`.
7. Для каждого файла изображения вызывается `add_image_watermark` для добавления водяного знака и сохранения изображения в каталоге "output".

**Примеры**:

```python
from pathlib import Path

folder_path = Path(".")  # Замените на реальный путь к папке
watermark_path = Path("watermark.png")  # Замените на реальный путь к изображению водяного знака

process_images_with_watermark(folder_path, watermark_path)