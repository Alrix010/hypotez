# Модуль для работы с асинхронными HTTP-запросами с использованием aiohttp

## Обзор

Модуль предоставляет классы и функции для выполнения асинхронных HTTP-запросов с использованием библиотеки `aiohttp`. Он включает поддержку потоковой передачи данных, обработки Server-Sent Events (SSE) и прокси. Модуль предназначен для использования в асинхронных приложениях, где требуется эффективная обработка сетевых запросов.

## Подробней

Модуль содержит класс `StreamResponse`, который расширяет возможности `ClientResponse` из `aiohttp`, добавляя методы для итерации по строкам и содержимому ответа, а также для обработки SSE. Класс `StreamSession` предоставляет удобный способ создания сессий `aiohttp` с поддержкой прокси и пользовательских заголовков. Функция `get_connector` создает коннектор для `aiohttp` с поддержкой прокси, используя библиотеку `aiohttp_socks`, если она установлена.

## Классы

### `StreamResponse`

**Описание**: Класс, расширяющий `ClientResponse` из `aiohttp` для поддержки потоковой обработки данных и SSE.

**Наследует**:

- `ClientResponse` (из `aiohttp`)

**Методы**:

- `iter_lines()`: Асинхронный итератор по строкам ответа.
- `iter_content()`: Асинхронный итератор по блокам содержимого ответа.
- `json(content_type: str = None)`: Асинхронно декодирует JSON из ответа.
- `sse()`: Асинхронный итератор по Server-Sent Events (SSE) ответа.

#### `iter_lines`

```python
async def iter_lines(self) -> AsyncIterator[bytes]:
    """Асинхронно итерирует по строкам ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по строкам ответа, удаляя завершающие символы перевода строки.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[bytes]`: Асинхронный итератор, возвращающий строки ответа в виде байтов.

**Как работает функция**:

1. Итерирует по содержимому ответа асинхронно.
2. Для каждой строки удаляет завершающие символы перевода строки (`\r\n`).
3. Возвращает строку в виде байтов.

**Примеры**:

```python
async for line in response.iter_lines():
    print(line)
```

#### `iter_content`

```python
async def iter_content(self) -> AsyncIterator[bytes]:
    """Асинхронно итерирует по блокам содержимого ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по блокам содержимого ответа.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[bytes]`: Асинхронный итератор, возвращающий блоки содержимого в виде байтов.

**Как работает функция**:

1. Итерирует по содержимому ответа, используя `iter_any()`, для получения блоков данных.
2. Возвращает каждый блок данных в виде байтов.

**Примеры**:

```python
async for chunk in response.iter_content():
    print(chunk)
```

#### `json`

```python
async def json(self, content_type: str = None) -> Any:
    """Асинхронно декодирует JSON из ответа."""
    ...
```

**Назначение**: Асинхронно декодирует JSON из тела ответа.

**Параметры**:

- `content_type` (str, optional): Тип содержимого для проверки. По умолчанию `None`.

**Возвращает**:

- `Any`: Декодированные данные JSON.

**Как работает функция**:

1. Вызывает метод `json()` родительского класса (`ClientResponse`) для декодирования JSON.
2. Возвращает декодированные данные.

**Примеры**:

```python
data = await response.json()
print(data)
```

#### `sse`

```python
async def sse(self) -> AsyncIterator[dict]:
    """Асинхронно итерирует по Server-Sent Events (SSE) ответа."""
    ...
```

**Назначение**: Асинхронно итерирует по Server-Sent Events (SSE) ответа.

**Параметры**:

- Нет

**Возвращает**:

- `AsyncIterator[dict]`: Асинхронный итератор, возвращающий события SSE в виде словарей.

**Как работает функция**:

1.  **Начало**: Инициализация асинхронной итерации по строкам содержимого ответа.
2.  **Обработка строк**: Для каждой строки проверяется, начинается ли она с `b"data: "`.
3.  **Извлечение данных**: Если строка начинается с `b"data: "`, извлекается часть строки, содержащая данные (после префикса `b"data: "`).
4.  **Завершение потока**: Если извлеченные данные начинаются с `b"[DONE]"`, итерация завершается.
5.  **Декодирование JSON**: Попытка декодировать извлеченные данные как JSON.
6.  **Возврат данных**: Если декодирование успешно, возвращается словарь с данными. Если происходит ошибка декодирования JSON (`json.JSONDecodeError`), итерация продолжается со следующей строки.

**Примеры**:

```python
async for event in response.sse():
    print(event)
```

### `StreamSession`

**Описание**: Класс, расширяющий `ClientSession` из `aiohttp` для добавления поддержки прокси, пользовательских заголовков и пользовательского класса ответа (`StreamResponse`).

**Наследует**:

- `ClientSession` (из `aiohttp`)

**Параметры**:

- `headers` (dict, optional): Дополнительные заголовки для сессии. По умолчанию `{}`.
- `timeout` (int, optional): Время ожидания для запросов. По умолчанию `None`. Может быть кортежем `(connect, read)`, где `connect` — время ожидания соединения, а `read` — время ожидания чтения данных.
- `connector` (BaseConnector, optional): Пользовательский коннектор для сессии. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `proxies` (dict, optional): Словарь URL прокси-серверов для разных протоколов. По умолчанию `{}`.
- `impersonate` (bool, optional): Указывает, следует ли использовать заголовки для имитации браузера. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы, передаваемые в конструктор `ClientSession`.

#### **Принцип работы**:

- Класс `StreamSession` инициализирует сессию `aiohttp` с пользовательскими параметрами, такими как заголовки, таймауты, коннектор и прокси.
- Если указан параметр `impersonate`, добавляются заголовки по умолчанию для имитации браузера.
- Если указан прокси-сервер, создается коннектор с поддержкой прокси.
- В конструктор `ClientSession` передается пользовательский класс ответа `StreamResponse`.

**Примеры**:

```python
session = StreamSession(proxy='socks5://user:password@host:port')
async with session.get('https://example.com') as response:
    async for line in response.iter_lines():
        print(line)
```

## Функции

### `get_connector`

```python
def get_connector(connector: BaseConnector = None, proxy: str = None, rdns: bool = False) -> Optional[BaseConnector]:
    """Создает коннектор для aiohttp с поддержкой прокси."""
    ...
```

**Назначение**: Создает коннектор для `aiohttp` с поддержкой прокси, используя библиотеку `aiohttp_socks`.

**Параметры**:

- `connector` (BaseConnector, optional): Существующий коннектор для использования. По умолчанию `None`.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `rdns` (bool, optional): Указывает, следует ли выполнять удаленный DNS-запрос через прокси-сервер. По умолчанию `False`.

**Возвращает**:

- `Optional[BaseConnector]`: Коннектор для `aiohttp` с поддержкой прокси, или `None`, если прокси не указан.

**Вызывает исключения**:

- `MissingRequirementsError`: Если библиотека `aiohttp_socks` не установлена и требуется поддержка прокси.

**Как работает функция**:

1.  **Проверка прокси и коннектора**: Проверяется, указан ли прокси-сервер и отсутствует ли существующий коннектор.
2.  **Импорт aiohttp_socks**: Пытается импортировать `ProxyConnector` из `aiohttp_socks`. Если импорт не удается, вызывается исключение `MissingRequirementsError`.
3.  **Преобразование URL прокси**: Если схема прокси `socks5h://`, она заменяется на `socks5://`, и устанавливается флаг `rdns`.
4.  **Создание ProxyConnector**: Создается экземпляр `ProxyConnector` из URL прокси-сервера и флага `rdns`.
5.  **Возврат коннектора**: Возвращается созданный коннектор. Если прокси не указан, возвращается исходный коннектор или `None`.

**Примеры**:

```python
connector = get_connector(proxy='socks5://user:password@host:port')
session = ClientSession(connector=connector)
async with session.get('https://example.com') as response:
    print(response.status)
```

```python
connector = get_connector(proxy='socks5h://user:password@host:port', rdns=True)
session = ClientSession(connector=connector)
async with session.get('https://example.com') as response:
    print(response.status)
```
```ascii
    ┌─────────────────────────────┐
    │  Проверка: proxy и  connector│
    └─────────────┬───────────────┘
                  │
         Нет proxy│
                  │ Да proxy
                  ▼
    ┌─────────────────────────────┐
    │      Импорт aiohttp_socks    │
    └─────────────┬───────────────┘
                  │Ошибка импорта
                  │ -> MissingRequirementsError
                  ▼Успешный импорт
    ┌─────────────────────────────┐
    │  Преобразование URL прокси   │
    └─────────────┬───────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │    Создание ProxyConnector   │
    └─────────────┬───────────────┘
                  │
                  ▼
    ┌─────────────────────────────┐
    │      Возврат коннектора     │
    └─────────────────────────────┘