# Модуль Cromicle

## Обзор

Модуль `Cromicle` предоставляет класс `Cromicle`, который является асинхронным генератором для взаимодействия с сервисом Cromicle (cromicle.top). Этот модуль предназначен для отправки запросов к API Cromicle и получения ответов в виде асинхронного потока данных. Он поддерживает модель `gpt-3.5-turbo`.

## Подробнее

Модуль использует библиотеки `aiohttp` для асинхронных HTTP-запросов и `hashlib` для вычисления хешей. Он определяет функции для создания заголовков и полезной нагрузки запросов, необходимых для взаимодействия с API Cromicle.
Модуль является частью проекта `hypotez` и предназначен для использования с другими модулями, такими как `AsyncGeneratorProvider` и `format_prompt`.

## Классы

### `Cromicle`

**Описание**: Класс `Cromicle` предоставляет асинхронный генератор для взаимодействия с API Cromicle.

**Наследует**:
- `AsyncGeneratorProvider`: Наследует функциональность асинхронного генератора от базового класса `AsyncGeneratorProvider`.

**Атрибуты**:
- `url` (str): URL-адрес сервиса Cromicle (`https://cromicle.top`).
- `working` (bool): Флаг, указывающий, работает ли провайдер (по умолчанию `False`).
- `supports_gpt_35_turbo` (bool): Флаг, указывающий, поддерживает ли провайдер модель `gpt-3.5-turbo` (по умолчанию `True`).

**Методы**:
- `create_async_generator`: Создает асинхронный генератор для отправки запросов к API Cromicle.

### `create_async_generator`

```python
    @classmethod
    async def create_async_generator(
        cls,
        model: str,
        messages: Messages,
        proxy: str = None,
        **kwargs
    ) -> AsyncResult:
        """
        Создает асинхронный генератор для взаимодействия с API Cromicle.

        Args:
            model (str): Модель для использования.
            messages (Messages): Список сообщений для отправки.
            proxy (str, optional): URL прокси-сервера. По умолчанию `None`.
            **kwargs: Дополнительные аргументы.

        Returns:
            AsyncResult: Асинхронный генератор, возвращающий поток данных от API Cromicle.

        Raises:
            Exception: Если возникает ошибка при отправке запроса или обработке ответа.
        """
```

**Назначение**: Создает асинхронный генератор для отправки запросов к API Cromicle и получения ответов в виде потока данных.

**Параметры**:
- `cls`: Ссылка на класс `Cromicle`.
- `model` (str): Модель для использования.
- `messages` (Messages): Список сообщений для отправки.
- `proxy` (str, optional): URL прокси-сервера. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы.

**Возвращает**:
- `AsyncResult`: Асинхронный генератор, возвращающий поток данных от API Cromicle.

**Вызывает исключения**:
- `Exception`: Если возникает ошибка при отправке запроса или обработке ответа.

**Как работает функция**:

1. **Создание сессии `aiohttp`**:
   - Создается асинхронная сессия `aiohttp.ClientSession` с заголовками, полученными из функции `_create_header()`. Это обеспечивает правильную настройку запроса.
2. **Отправка POST-запроса**:
   - Отправляется POST-запрос к адресу `{cls.url}/chat` с использованием созданной сессии.
   - Параметр `proxy` передается для использования прокси-сервера, если он указан.
   - Полезная нагрузка запроса формируется функцией `_create_payload()`, которая принимает отформатированные сообщения.
3. **Обработка потока данных**:
   - Полученный ответ обрабатывается как асинхронный поток данных.
   - Для каждого полученного фрагмента данных выполняется декодирование (`stream.decode()`), и результат передается через `yield`, делая функцию генератором.

```text
Создание сессии aiohttp
    |
    --> Отправка POST-запроса к API Cromicle
    |
    --> Обработка потока данных из ответа
    |
    --> Возврат декодированных фрагментов данных через yield
```

**Примеры**:

```python
# Пример использования create_async_generator
messages = [{"role": "user", "content": "Hello"}]
async def main():
    async for message in Cromicle.create_async_generator(model="gpt-3.5-turbo", messages=messages):
        print(message)

# Запуск примера
# asyncio.run(main())
```

## Функции

### `_create_header`

```python
def _create_header() -> Dict[str, str]:
    """
    Создает словарь с заголовками для HTTP-запроса.

    Returns:
        Dict[str, str]: Словарь с заголовками 'accept' и 'content-type'.
    """
```

**Назначение**: Функция создает словарь с заголовками для HTTP-запроса.

**Параметры**:
- Отсутствуют

**Возвращает**:
- `Dict[str, str]`: Словарь с заголовками `accept` и `content-type`.

**Как работает функция**:
1. **Создание словаря заголовков**:
   - Функция создает и возвращает словарь, содержащий два ключа:
     - `'accept'`: Указывает, что клиент принимает любой тип контента (`'*/*'`).
     - `'content-type'`: Указывает, что отправляемый контент имеет тип `application/json`.

```text
Создание словаря заголовков
    |
    --> Возврат словаря с заголовками accept и content-type
```

**Примеры**:

```python
# Пример использования _create_header
headers = _create_header()
print(headers)  # {'accept': '*/*', 'content-type': 'application/json'}
```

### `_create_payload`

```python
def _create_payload(message: str) -> Dict[str, str]:
    """
    Создает словарь с полезной нагрузкой для HTTP-запроса.

    Args:
        message (str): Сообщение для отправки в запросе.

    Returns:
        Dict[str, str]: Словарь с полезной нагрузкой, включающий сообщение, токен и хеш.
    """
```

**Назначение**: Функция создает словарь с полезной нагрузкой для HTTP-запроса, включая сообщение, токен и хеш.

**Параметры**:
- `message` (str): Сообщение для отправки в запросе.

**Возвращает**:
- `Dict[str, str]`: Словарь с полезной нагрузкой, включающий сообщение, токен и хеш.

**Как работает функция**:
1. **Кодирование сообщения**:
   - Сообщение кодируется в байты с использованием кодировки UTF-8.
2. **Вычисление хеша**:
   - Вычисляется хеш SHA256 конкатенации токена (`'abc'`) и закодированного сообщения.
3. **Создание словаря полезной нагрузки**:
   - Функция создает и возвращает словарь, содержащий следующие ключи:
     - `'message'`: Сообщение для отправки.
     - `'token'`: Статический токен `'abc'`.
     - `'hash'`: Вычисленный хеш.

```text
Кодирование сообщения
    |
    --> Вычисление хеша SHA256
    |
    --> Создание словаря с сообщением, токеном и хешем
    |
    --> Возврат словаря с полезной нагрузкой
```

**Примеры**:

```python
# Пример использования _create_payload
message = "Hello, world!"
payload = _create_payload(message)
print(payload)
# Примерный вывод: {'message': 'Hello, world!', 'token': 'abc', 'hash': '...'}