# Модуль `Qwen_Qwen_2_5_Max`

## Обзор

Модуль предоставляет класс `Qwen_Qwen_2_5_Max`, который является асинхронным генератором для взаимодействия с моделью Qwen Qwen-2.5-Max через API Hugging Face Space. Класс поддерживает потоковую передачу данных, системные сообщения и предоставляет псевдонимы для моделей.

## Подробней

Этот модуль позволяет взаимодействовать с моделью Qwen Qwen-2.5-Max, размещенной на Hugging Face Space, для генерации текста на основе предоставленных сообщений. Он использует асинхронные запросы для обеспечения неблокирующего взаимодействия. Модуль включает поддержку потоковой передачи, что позволяет получать ответы по частям, а также возможность отправлять системные сообщения для задания контекста модели.

## Классы

### `Qwen_Qwen_2_5_Max`

**Описание**: Класс для взаимодействия с моделью Qwen Qwen-2.5-Max через API Hugging Face Space.

**Наследует**:

- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию.
- `ProviderModelMixin`: Предоставляет общие методы для работы с моделями.

**Атрибуты**:

- `label` (str): Метка провайдера (значение: `"Qwen Qwen-2.5-Max"`).
- `url` (str): URL Hugging Face Space (значение: `"https://qwen-qwen2-5-max-demo.hf.space"`).
- `api_endpoint` (str): URL API для присоединения к очереди запросов (значение: `"https://qwen-qwen2-5-max-demo.hf.space/gradio_api/queue/join?"`).
- `working` (bool): Указывает, работает ли провайдер (значение: `True`).
- `supports_stream` (bool): Указывает, поддерживает ли провайдер потоковую передачу (значение: `True`).
- `supports_system_message` (bool): Указывает, поддерживает ли провайдер системные сообщения (значение: `True`).
- `supports_message_history` (bool): Указывает, поддерживает ли провайдер историю сообщений (значение: `False`).
- `default_model` (str): Модель, используемая по умолчанию (значение: `"qwen-qwen2-5-max"`).
- `model_aliases` (dict): Псевдонимы моделей (значение: `{"qwen-2-5-max": default_model}`).
- `models` (list): Список моделей, поддерживаемых провайдером.

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для взаимодействия с моделью Qwen Qwen-2.5-Max.

    Args:
        model (str): Имя модели для использования.
        messages (Messages): Список сообщений для отправки модели.
        proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.
        **kwargs: Дополнительные параметры.

    Returns:
        AsyncResult: Асинхронный генератор для получения ответов от модели.
    """
```

**Назначение**: Создает асинхронный генератор для взаимодействия с моделью Qwen Qwen-2.5-Max.

**Параметры**:

- `cls`: Ссылка на класс `Qwen_Qwen_2_5_Max`.
- `model` (str): Имя модели для использования.
- `messages` (Messages): Список сообщений для отправки модели.
- `proxy` (str, optional): Прокси-сервер для использования. По умолчанию `None`.
- `**kwargs`: Дополнительные параметры.

**Возвращает**:

- `AsyncResult`: Асинхронный генератор для получения ответов от модели.

**Внутренние функции**:

- `generate_session_hash()`:

    ```python
    def generate_session_hash():
        """Generate a unique session hash."""
        return str(uuid.uuid4()).replace(\'-\', \'\')[:8] + str(uuid.uuid4()).replace(\'-\', \'\')[:4]
    ```

    **Назначение**: Генерирует уникальный хэш сессии.

    **Параметры**: Нет.

    **Возвращает**:

    - `str`: Уникальный хэш сессии.

**Как работает функция**:

1. **Генерация уникального хэша сессии**:
   - Вызывается функция `generate_session_hash()` для генерации уникального идентификатора сессии, который используется для связи с API.

2. **Подготовка заголовков и полезной нагрузки для запроса на присоединение**:
   - Определяются заголовки (`headers_join`) для HTTP-запроса на присоединение к очереди.
   - Извлекается системное сообщение из списка сообщений (`messages`). Если системное сообщение отсутствует, используется сообщение по умолчанию: `"You are a helpful assistant."`.
   - Форматируется запрос (`prompt`) из сообщений пользователя.
   - Подготавливается полезная нагрузка (`payload_join`) для запроса на присоединение, включающая запрос, системное сообщение и хэш сессии.

3. **Отправка запроса на присоединение и получение идентификатора события**:
   - Используется `aiohttp.ClientSession()` для отправки асинхронного POST-запроса к `cls.api_endpoint` с заголовками `headers_join` и полезной нагрузкой `payload_join`.
   - Из полученного JSON-ответа извлекается `event_id`.

4. **Подготовка заголовков и параметров для запроса потока данных**:
   - Определяются URL (`url_data`), заголовки (`headers_data`) и параметры (`params_data`) для запроса потока данных.

5. **Отправка запроса потока данных и обработка ответов**:
   - Используется `aiohttp.ClientSession()` для отправки асинхронного GET-запроса к `url_data` с заголовками `headers_data` и параметрами `params_data`.
   - Читаются строки из ответа (`response.content`) в асинхронном режиме.
   - Если строка начинается с `'data: '`, извлекается JSON-данные из строки.

6. **Обработка JSON-данных**:
   - Если сообщение (`json_data.get('msg')`) равно `'process_generating'`, извлекается фрагмент текста из `json_data['output']['data'][1]` и добавляется к `full_response`.
   - Если сообщение равно `'process_completed'`, извлекается полный ответ из `json_data['output']['data'][1][0][1]`, очищается от дубликатов и добавляется к `full_response`.

7. **Генерация фрагментов текста**:
   - Фрагменты текста (`fragment`) генерируются с использованием `yield`, что позволяет получать ответы по частям.

8. **Обработка ошибок**:
   - В случае ошибки декодирования JSON, информация об ошибке логируется с использованием `debug.log()`.

**Примеры**:

```python
# Пример использования (необходима асинхронная среда выполнения)
import asyncio
from src.endpoints.gpt4free.g4f.Provider.hf_space.Qwen_Qwen_2_5_Max import Qwen_Qwen_2_5_Max

async def main():
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Hello, who are you?"}
    ]
    async for message in Qwen_Qwen_2_5_Max.create_async_generator(model="qwen-2-5-max", messages=messages):
        print(message, end="")

if __name__ == "__main__":
    asyncio.run(main())