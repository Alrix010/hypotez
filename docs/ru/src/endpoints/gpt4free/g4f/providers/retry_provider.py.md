# Модуль `retry_provider`

## Обзор

Модуль `retry_provider` предоставляет классы для повторных попыток использования различных провайдеров для создания завершений (completion) с возможностью стриминга. Он содержит классы `IterListProvider` и `RetryProvider`, которые позволяют организовать перебор и повторные попытки с разными провайдерами, если предыдущие попытки завершились неудачей.

## Подробней

Этот модуль позволяет гибко управлять выбором и повторным использованием провайдеров, что особенно полезно в ситуациях, когда один или несколько провайдеров могут быть недоступны или возвращать ошибки. Классы, определенные в этом модуле, позволяют автоматически переключаться на другие доступные провайдеры и повторять запросы до тех пор, пока не будет получен успешный ответ или не будет достигнуто максимальное количество попыток.

## Классы

### `IterListProvider`

**Описание**:
Класс `IterListProvider` является базовым классом для организации перебора списка провайдеров.

**Принцип работы**:
Класс принимает список провайдеров и флаг `shuffle`, определяющий, нужно ли перемешивать список провайдеров перед использованием. При создании завершения, класс перебирает провайдеров, и пытается получить ответ от каждого из них. Если провайдер возвращает ошибку, класс переходит к следующему провайдеру.

**Атрибуты**:
- `providers` (List[Type[BaseProvider]]): Список провайдеров для использования.
- `shuffle` (bool): Флаг, указывающий, нужно ли перемешивать список провайдеров. По умолчанию `True`.
- `working` (bool): Флаг, указывающий, работает ли провайдер.
- `last_provider` (Type[BaseProvider]): Последний использованный провайдер.

**Методы**:
- `__init__(providers: List[Type[BaseProvider]], shuffle: bool = True) -> None`: Инициализирует класс `IterListProvider`.
- `create_completion(model: str, messages: Messages, stream: bool = False, ignore_stream: bool = False, ignored: list[str] = [], **kwargs) -> CreateResult`: Создает завершение, используя доступных провайдеров, с возможностью стриминга ответа.
- `create_async_generator(model: str, messages: Messages, stream: bool = True, ignore_stream: bool = False, ignored: list[str] = [], **kwargs) -> AsyncResult`: Асинхронно создает завершение, используя доступных провайдеров, с возможностью стриминга ответа.
- `get_create_function() -> callable`: Возвращает функцию для создания завершения.
- `get_async_create_function() -> callable`: Возвращает асинхронную функцию для создания завершения.
- `get_providers(stream: bool, ignored: list[str]) -> list[ProviderType]`: Возвращает список провайдеров, поддерживающих стриминг (если требуется), исключая провайдеров из списка игнорируемых.

### `RetryProvider`

**Описание**:
Класс `RetryProvider` наследуется от `IterListProvider` и добавляет функциональность повторных попыток для одного провайдера.

**Принцип работы**:
Если установлен флаг `single_provider_retry`, класс будет повторять попытки только с первым провайдером из списка до тех пор, пока не будет получен успешный ответ или не будет достигнуто максимальное количество попыток. Если флаг не установлен, класс будет перебирать всех провайдеров, как это делает `IterListProvider`.

**Наследует**:
- `IterListProvider`: Расширяет функциональность класса `IterListProvider`, добавляя повторные попытки.

**Атрибуты**:
- `single_provider_retry` (bool): Флаг, указывающий, нужно ли повторять попытки только с одним провайдером. По умолчанию `False`.
- `max_retries` (int): Максимальное количество повторных попыток для одного провайдера. По умолчанию `3`.

**Методы**:
- `__init__(providers: List[Type[BaseProvider]], shuffle: bool = True, single_provider_retry: bool = False, max_retries: int = 3) -> None`: Инициализирует класс `RetryProvider`.
- `create_completion(model: str, messages: Messages, stream: bool = False, **kwargs) -> CreateResult`: Создает завершение, используя доступных провайдеров, с возможностью стриминга ответа и повторными попытками.
- `create_async_generator(model: str, messages: Messages, stream: bool = True, **kwargs) -> AsyncResult`: Асинхронно создает завершение, используя доступных провайдеров, с возможностью стриминга ответа и повторными попытками.

## Функции

### `raise_exceptions`

```python
def raise_exceptions(exceptions: dict) -> None:
    """
    Raise a combined exception if any occurred during retries.

    Raises:
        RetryProviderError: If any provider encountered an exception.
        RetryNoProviderError: If no provider is found.
    """
    ...
```

**Назначение**:
Функция `raise_exceptions` предназначена для генерации исключения, если во время повторных попыток произошли какие-либо ошибки.

**Параметры**:
- `exceptions` (dict): Словарь, содержащий исключения, возникшие во время повторных попыток.

**Возвращает**:
- `None`: Функция ничего не возвращает, но может вызвать исключение.

**Вызывает исключения**:
- `RetryProviderError`: Если какой-либо провайдер столкнулся с исключением.
- `RetryNoProviderError`: Если не найдено ни одного провайдера.

**Как работает функция**:

1. **Проверка наличия исключений**: Функция проверяет, пуст ли словарь `exceptions`.
2. **Генерация исключения `RetryProviderError`**: Если словарь `exceptions` не пуст, функция генерирует исключение `RetryProviderError` с информацией о каждом провайдере и возникшем исключении.
3. **Генерация исключения `RetryNoProviderError`**: Если словарь `exceptions` пуст, функция генерирует исключение `RetryNoProviderError`, указывающее, что ни один провайдер не был найден.

**ASCII flowchart**:

```
Проверка исключений (exceptions)
|
Нет исключений?
|
Да --------------------->  Вызов RetryNoProviderError
|
Нет <---------------------
|
Создание сообщения об ошибке
|
Вызов RetryProviderError с сообщением
```

**Примеры**:

Пример 1: Вызов функции с пустым словарем исключений.

```python
exceptions = {}
try:
    raise_exceptions(exceptions)
except RetryNoProviderError as ex:
    print(f"Исключение: {ex}")
```

Пример 2: Вызов функции со словарем исключений, содержащим информацию об ошибках.

```python
exceptions = {
    "Provider1": ValueError("Неверное значение"),
    "Provider2": TimeoutError("Превышено время ожидания")
}
try:
    raise_exceptions(exceptions)
except RetryProviderError as ex:
    print(f"Исключение: {ex}")