# Модуль с вспомогательными функциями для работы с текстом
=========================================================

Модуль содержит вспомогательные функции для обработки текста, включая фильтрацию Markdown и JSON, а также поиск стоп-слов.

## Обзор

Этот модуль предоставляет набор инструментов для работы с текстовыми данными, ориентированных на фильтрацию и обработку содержимого, представленного в форматах Markdown и JSON. Он включает функции для извлечения кода из блоков Markdown, фильтрации JSON-подобных структур, поиска стоп-слов и безопасного закрытия асинхронных генераторов. Модуль предназначен для упрощения задач обработки текста и извлечения необходимой информации из различных форматов данных.

## Подробнее

Модуль предназначен для работы с текстом, который может содержать код в формате Markdown или JSON. Он предоставляет функции для извлечения этого кода, а также для поиска и удаления стоп-слов. Кроме того, модуль содержит функцию для безопасного закрытия асинхронных генераторов. Этот модуль может быть полезен в задачах обработки текста, анализа данных и машинного обучения.

## Функции

### `filter_markdown`

```python
def filter_markdown(text: str, allowd_types=None, default=None) -> str:
    """
    Parses code block from a string.

    Args:
        text (str): A string containing a code block.

    Returns:
        dict: A dictionary parsed from the code block.
    """
    ...
```

**Назначение**: Извлекает блок кода из строки, если он соответствует разрешенным типам.

**Параметры**:
- `text` (str): Строка, содержащая блок кода.
- `allowd_types` (list, optional): Список разрешенных типов блоков кода. Если `None`, разрешены все типы. По умолчанию `None`.
- `default` (str, optional): Значение, возвращаемое по умолчанию, если блок кода не найден или не соответствует разрешенным типам. По умолчанию `None`.

**Возвращает**:
- `str`: Извлеченный блок кода, если он найден и соответствует разрешенным типам. В противном случае возвращает значение по умолчанию.

**Как работает функция**:

1.  **Поиск блока кода Markdown**: Функция ищет блок кода Markdown в предоставленной строке `text`, используя регулярное выражение. Блок кода определяется как текст, заключенный между строками, начинающимися с ``` и заканчивающимися ```.
2.  **Проверка типа блока кода**: Если блок кода найден, функция проверяет, соответствует ли тип блока кода разрешенным типам, указанным в `allowd_types`. Если `allowd_types` не указан, то разрешены все типы блоков кода.
3.  **Извлечение кода**: Если тип блока кода соответствует разрешенным типам, функция извлекает код из блока кода и возвращает его.
4.  **Возврат значения по умолчанию**: Если блок кода не найден или не соответствует разрешенным типам, функция возвращает значение по умолчанию, указанное в `default`.

```
    Начало
    │
    └──> Поиск блока кода Markdown (match = re.search(...))
         │
         ├──> Блок кода не найден? (if not match)
         │    └──> Возврат значения по умолчанию (return default)
         │
         └──> Блок кода найден
              │
              └──> Проверка типа блока кода (if allowd_types is None or match.group(1) in allowd_types)
                   │
                   ├──> Тип блока кода не разрешен?
                   │    └──> Возврат значения по умолчанию (return default)
                   │
                   └──> Тип блока кода разрешен
                        │
                        └──> Извлечение кода из блока (match.group("code"))
                             │
                             └──> Возврат извлеченного кода (return match.group("code"))
```

**Примеры**:

```python
text = "```python\nprint('Hello, world!')\n```"
code = filter_markdown(text)
print(code) # Вывод: print('Hello, world!')

text = "```json\n{'key': 'value'}\n```"
code = filter_markdown(text, allowd_types=['python'])
print(code) # Вывод: None

text = "Some text\n```python\nprint('Hello, world!')\n```"
code = filter_markdown(text)
print(code) # Вывод: print('Hello, world!')
```

### `filter_json`

```python
def filter_json(text: str) -> str:
    """
    Parses JSON code block from a string.

    Args:
        text (str): A string containing a JSON code block.

    Returns:
        dict: A dictionary parsed from the JSON code block.
    """
    ...
```

**Назначение**: Извлекает JSON-подобный блок кода из строки.

**Параметры**:
- `text` (str): Строка, содержащая JSON-подобный блок кода.

**Возвращает**:
- `str`: Извлеченный JSON-подобный блок кода, если он найден. В противном случае возвращает исходную строку `text`.

**Как работает функция**:

1.  **Вызов `filter_markdown`**: Функция вызывает функцию `filter_markdown` с параметрами `text`, `allowd_types=['', 'json']` и `default=text.strip("^\\n ")`. Это означает, что функция будет искать блок кода Markdown, который либо не имеет типа, либо имеет тип "json". Если блок кода не найден, функция `filter_markdown` вернет исходную строку `text` без начальных и конечных пробелов и символов новой строки.
2.  **Возврат результата**: Функция `filter_json` возвращает результат, возвращенный функцией `filter_markdown`.

```
Начало
│
└──> Вызов filter_markdown(text, ["", "json"], text.strip("^\\n "))
│
└──> Возврат результата, полученного от filter_markdown
```

**Примеры**:

```python
text = "```json\n{'key': 'value'}\n```"
json_code = filter_json(text)
print(json_code) # Вывод: {'key': 'value'}

text = "{'key': 'value'}"
json_code = filter_json(text)
print(json_code) # Вывод: {'key': 'value'}

text = "Some text\n```python\nprint('Hello, world!')\n```"
json_code = filter_json(text)
print(json_code) # Вывод: Some text
```

### `find_stop`

```python
def find_stop(stop: Optional[list[str]], content: str, chunk: str = None):
    """
    Находит первое вхождение стоп-слова в строке и обрезает строку до этого слова.

    Args:
        stop (Optional[list[str]]): Список стоп-слов.
        content (str): Строка, в которой производится поиск.
        chunk (str, optional): Дополнительная строка, в которой также производится поиск. По умолчанию `None`.

    Returns:
        Tuple[int, str, str]: Кортеж, содержащий индекс первого вхождения стоп-слова, обрезанную строку `content` и обрезанную строку `chunk` (если она была передана).
    """
    ...
```

**Назначение**: Находит первое вхождение одного из стоп-слов в строке и обрезает строку до этого слова.

**Параметры**:
- `stop` (Optional[list[str]]): Список стоп-слов, которые нужно искать в строке. Если `None`, поиск не производится.
- `content` (str): Строка, в которой производится поиск стоп-слов.
- `chunk` (str, optional): Дополнительная строка, которая также обрезается до первого вхождения стоп-слова. По умолчанию `None`.

**Возвращает**:
- `Tuple[int, str, str]`: Кортеж, содержащий:
    - `first` (int): Индекс первого вхождения стоп-слова в строке `content`. Если стоп-слова не найдены, возвращается `-1`.
    - `content` (str): Обрезанная строка `content`, содержащая только текст до первого вхождения стоп-слова. Если стоп-слова не найдены, возвращается исходная строка `content`.
    - `chunk` (str): Обрезанная строка `chunk`, содержащая только текст до первого вхождения стоп-слова. Если `chunk` не был передан, возвращается `None`. Если стоп-слова не найдены, возвращается исходная строка `chunk`.

**Как работает функция**:

1.  **Инициализация**:
    - Устанавливает `first = -1` и `word = None`.
    - Проверяет, является ли `stop` `None`. Если да, то переходит к возврату значений.
2.  **Поиск стоп-слов**:
    - Перебирает каждое `word` в списке `stop`.
    - Ищет первое вхождение `word` в `content` с помощью `content.find(word)`.
    - Если `word` найдено (т.е. `first != -1`):
        - Обрезает `content` до позиции `first` (исключая `word`).
        - Прерывает цикл `for`.
3.  **Обработка `chunk`**:
    - Проверяет, является ли `chunk` `None` и было ли найдено стоп-слово (т.е. `first != -1`).
    - Если оба условия истинны:
        - Ищет `word` в `chunk`.
        - Если `word` найдено в `chunk`:
            - Обрезает `chunk` до позиции `first`.
        - Иначе:
            - Устанавливает `first = 0`.
4.  **Возврат значений**:
    - Возвращает `first`, обрезанный `content` и обрезанный `chunk`.

```
    Начало
    │
    ├──> Инициализация (first = -1, word = None)
    │
    ├──> stop is None? (if stop is not None)
    │    ├──> Да
    │    │   └──> Пропуск цикла поиска
    │    └──> Нет
    │        ├──> Цикл по каждому стоп-слову (for word in list(stop))
    │        │   ├──> Поиск стоп-слова в content (first = content.find(word))
    │        │   ├──> Стоп-слово найдено? (if first != -1)
    │        │   │   ├──> Да
    │        │   │   │   ├──> Обрезка content (content = content[:first])
    │        │   │   │   └──> Выход из цикла (break)
    │        │   │   └──> Нет
    │        │   │       └──> Продолжение цикла
    │        │   └──> Конец цикла
    │        └──> Обработка chunk (if chunk is not None and first != -1)
    │            ├──> chunk is None или стоп-слово не найдено?
    │            │   └──> Пропуск обработки chunk
    │            └──> Стоп-слово найдено в content?
    │                ├──> Да
    │                │   └──> Поиск стоп-слова в chunk (first = chunk.find(word))
    │                ├──> Стоп-слово не найдено в chunk?
    │                │   └──> Обрезка chunk (chunk = chunk[:first])
    │                └──> Нет
    │                    └──> first = 0
    └──> Возврат значений (first, content, chunk)
```

**Примеры**:

```python
stop_words = ["stop", "end"]
content = "This is a test string with stop word."
first, content, chunk = find_stop(stop_words, content)
print(first, content, chunk)  # Вывод: 28 This is a test string with 

content = "This is a test string with stop word."
chunk = "Another string for testing."
first, content, chunk = find_stop(stop_words, content, chunk)
print(first, content, chunk)  # Вывод: 28 This is a test string with  Another string for testing.

stop_words = ["stop", "end"]
content = "This is a test string with end word."
first, content, chunk = find_stop(stop_words, content)
print(first, content, chunk) # Вывод: 28 This is a test string with 
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Фильтрует словарь, удаляя элементы со значением `None`.

    Args:
        **kwargs: Произвольные именованные аргументы.

    Returns:
        dict: Новый словарь, содержащий только элементы с не-`None` значениями.
    """
    ...
```

**Назначение**: Создает новый словарь, содержащий только те элементы из входных именованных аргументов, значения которых не равны `None`.

**Параметры**:
- `**kwargs`: Произвольные именованные аргументы, которые будут преобразованы в словарь.

**Возвращает**:
- `dict`: Новый словарь, содержащий только элементы с не-`None` значениями.

**Как работает функция**:

1.  **Генерация словаря**: Функция создает словарь, используя генератор словаря. Генератор перебирает все пары ключ-значение в `kwargs`.
2.  **Фильтрация `None`**: Для каждой пары ключ-значение генератор проверяет, является ли значение `None`. Если значение не `None`, то пара ключ-значение добавляется в новый словарь.
3.  **Возврат результата**: Функция возвращает новый словарь, содержащий только элементы с не-`None` значениями.

```
    Начало
    │
    ├──> Создание словаря с фильтрацией None (dict comprehension)
    │    └──> Для каждой пары ключ-значение в kwargs:
    │        ├──> Значение равно None?
    │        │   ├──> Да: Пропустить пару
    │        │   └──> Нет: Добавить пару в новый словарь
    │    └──> Конец цикла
    │
    └──> Возврат нового словаря
```

**Примеры**:

```python
filtered_dict = filter_none(a=1, b=None, c='hello')
print(filtered_dict)  # Вывод: {'a': 1, 'c': 'hello'}

filtered_dict = filter_none(a=None, b=None)
print(filtered_dict)  # Вывод: {}

filtered_dict = filter_none(a=1, b=2, c=3)
print(filtered_dict)  # Вывод: {'a': 1, 'b': 2, 'c': 3}
```

### `safe_aclose`

```python
async def safe_aclose(generator: AsyncGenerator) -> None:
    """
    Безопасно закрывает асинхронный генератор.

    Args:
        generator (AsyncGenerator): Асинхронный генератор, который нужно закрыть.
    """
    ...
```

**Назначение**: Безопасно закрывает асинхронный генератор, обрабатывая возможные исключения.

**Параметры**:
- `generator` (AsyncGenerator): Асинхронный генератор, который необходимо закрыть.

**Возвращает**:
- `None`

**Как работает функция**:

1.  **Проверка наличия и активности генератора**: Функция проверяет, что генератор существует (`generator`) и имеет атрибут `aclose` (который является методом для закрытия асинхронного генератора).
2.  **Попытка закрытия генератора**: Функция пытается вызвать метод `aclose` для закрытия генератора.
3.  **Обработка исключений**: Если во время закрытия генератора возникает исключение, функция перехватывает его и логирует предупреждение с информацией об ошибке.

```
    Начало
    │
    ├──> Проверка наличия и активности генератора (if generator and hasattr(generator, 'aclose'))
    │    ├──> Генератор отсутствует или не имеет метода aclose?
    │    │   └──> Завершение функции
    │    └──> Генератор присутствует и имеет метод aclose
    │        ├──> Попытка закрытия генератора (await generator.aclose())
    │        │   ├──> Возникло исключение? (try...except Exception as e)
    │        │   │   └──> Логирование предупреждения об ошибке (logging.warning(f"Error while closing generator: {e}"))
    │        │   └──> Закрытие прошло успешно
    │        └──> Завершение функции
    └──> Завершение функции
```

**Примеры**:

```python
import asyncio
import logging

async def example_generator():
    try:
        for i in range(3):
            yield i
            await asyncio.sleep(0.1)
    finally:
        logging.info("Generator closed")

async def main():
    gen = example_generator()
    async for item in gen:
        print(item)
        if item == 1:
            await safe_aclose(gen)
            break

if __name__ == "__main__":
    asyncio.run(main())