# Модуль для запуска инструментов

## Обзор

Модуль `run_tools.py` содержит классы и функции для обработки различных инструментов, используемых в процессе генерации ответов. Он включает в себя логику для работы с поисковыми инструментами, инструментами продолжения и инструментами для работы с хранилищем данных (bucket). Также модуль управляет авторизацией API-ключей и обработкой промежуточных результатов (thinking chunks).

## Подробнее

Модуль предоставляет функциональность для асинхронного и синхронного запуска инструментов, используемых для расширения возможностей языковой модели. Он включает в себя классы и методы для обработки различных типов инструментов, таких как поиск в интернете, продолжение генерации текста и доступ к хранилищу данных. Также модуль управляет авторизацией API-ключей и обрабатывает промежуточные результаты генерации текста.

## Классы

### `ToolHandler`

**Описание**: Класс `ToolHandler` предназначен для обработки различных типов инструментов.

**Принцип работы**: Класс содержит статические методы для валидации аргументов инструментов, обработки поисковых запросов, запросов на продолжение генерации текста и запросов к хранилищу данных.

#### Методы:

- `validate_arguments(data: dict) -> dict`: Валидирует и преобразует аргументы инструмента из словаря или JSON-строки в словарь.
- `process_search_tool(messages: Messages, tool: dict) -> Messages`: Обрабатывает запросы к поисковому инструменту, выполняет поиск и обновляет сообщения с результатами поиска.
- `process_continue_tool(messages: Messages, tool: dict, provider: Any) -> Tuple[Messages, Dict[str, Any]]`: Обрабатывает запросы к инструменту продолжения генерации текста, добавляет контекст для продолжения или включает нативный режим продолжения для определенных провайдеров.
- `process_bucket_tool(messages: Messages, tool: dict) -> Messages`: Обрабатывает запросы к инструменту для работы с хранилищем данных, заменяет идентификаторы хранилища на содержимое хранилища в сообщениях.
- `process_tools(messages: Messages, tool_calls: List[dict], provider: Any) -> Tuple[Messages, Dict[str, Any]]`: Обрабатывает список вызовов инструментов, выполняет соответствующие действия для каждого инструмента и возвращает обновленные сообщения и дополнительные аргументы.

### `AuthManager`

**Описание**: Класс `AuthManager` предназначен для управления API-ключами.

**Принцип работы**: Класс предоставляет статические методы для получения пути к файлу с API-ключом и загрузки API-ключа из файла конфигурации.

#### Методы:

- `get_api_key_file(cls) -> Path`: Возвращает путь к файлу, в котором хранится API-ключ для указанного провайдера.
- `load_api_key(provider: Any) -> Optional[str]`: Загружает API-ключ из файла конфигурации, если он необходим для указанного провайдера.

### `ThinkingProcessor`

**Описание**: Класс `ThinkingProcessor` предназначен для обработки "размышляющих" чанков.

**Принцип работы**: Класс содержит статические методы для обработки чанков, содержащих теги `<think>` и `</think>`, которые указывают на процесс размышления модели.

#### Методы:

- `process_thinking_chunk(chunk: str, start_time: float = 0) -> Tuple[float, List[Union[str, Reasoning]]]`: Обрабатывает чанк и возвращает время начала размышления и список результатов, содержащих текст, статус и индикаторы начала и окончания размышления.

## Функции

### `perform_web_search`

```python
async def perform_web_search(messages: Messages, web_search_param: Any) -> Tuple[Messages, Optional[Sources]]:
    """Выполняет поиск в интернете и возвращает обновленные сообщения и источники.

    Args:
        messages (Messages): Список сообщений для обработки.
        web_search_param (Any): Параметр для поиска в интернете.

    Returns:
        Tuple[Messages, Optional[Sources]]: Обновленный список сообщений и источники (если есть).
    """
    ...
```

**Назначение**: Выполняет поиск в интернете на основе заданного запроса и обновляет список сообщений с результатами поиска.

**Параметры**:

- `messages` (Messages): Список сообщений, содержащих контекст для поиска.
- `web_search_param` (Any): Параметр для поиска, который может быть строкой запроса или булевым значением.

**Возвращает**:

- `Tuple[Messages, Optional[Sources]]`: Кортеж, содержащий обновленный список сообщений и источники результатов поиска.

**Как работает функция**:

1. Функция проверяет, задан ли параметр `web_search_param`. Если он не задан, функция возвращает исходные сообщения и `None` для источников.
2. Если параметр задан, функция пытается выполнить поиск в интернете, используя функцию `do_search`.
3. В случае успеха функция обновляет содержимое последнего сообщения в списке `messages` результатами поиска и сохраняет источники.
4. Если во время поиска возникает исключение, функция логирует ошибку и возвращает исходные сообщения и `None` для источников.

**Примеры**:

```python
messages = [{"role": "user", "content": "Как погода в Москве?"}]
messages, sources = asyncio.run(perform_web_search(messages, "погода в Москве сегодня"))
print(messages)
# Вывод: [{'role': 'user', 'content': 'Погода в Москве сегодня: ...'}]
print(sources)
# Вывод: {'source_title': '...', 'source_url': '...', 'raw_text': '...'}
```

```python
messages = [{"role": "user", "content": "Расскажи о Python"}]
messages, sources = asyncio.run(perform_web_search(messages, True))
print(messages)
# Вывод: [{'role': 'user', 'content': 'Python - это ...'}]
print(sources)
# Вывод: {'source_title': '...', 'source_url': '...', 'raw_text': '...'}
```

### `async_iter_run_tools`

```python
async def async_iter_run_tools(
    provider: ProviderType, 
    model: str, 
    messages: Messages, 
    tool_calls: Optional[List[dict]] = None, 
    **kwargs
) -> AsyncIterator:
    """Асинхронно запускает инструменты и выдает результаты.

    Args:
        provider (ProviderType): Провайдер модели.
        model (str): Название модели.
        messages (Messages): Список сообщений для обработки.
        tool_calls (Optional[List[dict]], optional): Список вызовов инструментов. По умолчанию None.
        **kwargs: Дополнительные аргументы.

    Returns:
        AsyncIterator: Асинхронный итератор, выдающий результаты.
    """
    ...
```

**Назначение**: Асинхронно запускает инструменты и выдает результаты в виде асинхронного итератора.

**Параметры**:

- `provider` (ProviderType): Провайдер, предоставляющий модель.
- `model` (str): Название используемой модели.
- `messages` (Messages): Список сообщений, содержащих контекст для генерации ответа.
- `tool_calls` (Optional[List[dict]], optional): Список вызовов инструментов, которые необходимо выполнить. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы, передаваемые в функцию создания ответа провайдера.

**Возвращает**:

- `AsyncIterator`: Асинхронный итератор, который выдает чанки сгенерированного ответа и источники, если они доступны.

**Как работает функция**:

1. **Обработка поиска в интернете**: Если в `kwargs` передан параметр `web_search`, функция вызывает `perform_web_search` для выполнения поиска и обновления сообщений.
2. **Загрузка API-ключа**: Если провайдер требует аутентификации и API-ключ не передан в `kwargs`, функция пытается загрузить его с помощью `AuthManager.load_api_key` и добавить в `kwargs`.
3. **Обработка вызовов инструментов**: Если передан список `tool_calls`, функция вызывает `ToolHandler.process_tools` для обработки каждого инструмента и обновления сообщений.
4. **Генерация ответа**: Функция получает функцию создания ответа от провайдера (`provider.get_async_create_function()`) и вызывает ее с необходимыми аргументами. Результат преобразуется в асинхронный итератор с помощью `to_async_iterator`.
5. **Выдача результатов**: Функция асинхронно итерируется по чанкам ответа, полученным из итератора, и выдает их.
6. **Выдача источников**: Если доступны источники (`sources`), функция выдает их после завершения итерации по чанкам ответа.

**ASCII flowchart**:

```
    Начало
     ↓
  Проверка web_search
     ↓
  Загрузка API-ключа (если нужно)
     ↓
  Обработка tool_calls
     ↓
  Генерация ответа (асинхронный итератор)
     ↓
  Выдача чанков ответа
     ↓
  Выдача источников (если есть)
     ↓
    Конец
```

**Примеры**:

```python
# Пример использования с асинхронным провайдером
async def main():
    from ..providers import Koala
    provider = Koala
    model = "koala-v2-13b"
    messages = [{"role": "user", "content": "Что такое Python?"}]
    async for chunk in async_iter_run_tools(provider, model, messages, web_search="Python programming language"):
        print(chunk)

asyncio.run(main())
```

### `iter_run_tools`

```python
def iter_run_tools(
    iter_callback: Callable,
    model: str,
    messages: Messages,
    provider: Optional[str] = None,
    tool_calls: Optional[List[dict]] = None,
    **kwargs
) -> Iterator:
    """Запускает инструменты синхронно и выдает результаты.

    Args:
        iter_callback (Callable): Функция обратного вызова для получения итератора чанков.
        model (str): Название модели.
        messages (Messages): Список сообщений для обработки.
        provider (Optional[str], optional): Провайдер модели. По умолчанию None.
        tool_calls (Optional[List[dict]], optional): Список вызовов инструментов. По умолчанию None.
        **kwargs: Дополнительные аргументы.

    Returns:
        Iterator: Итератор, выдающий результаты.
    """
    ...
```

**Назначение**: Запускает инструменты синхронно и выдает результаты в виде итератора.

**Параметры**:

- `iter_callback` (Callable): Функция обратного вызова, которая возвращает итератор чанков ответа.
- `model` (str): Название используемой модели.
- `messages` (Messages): Список сообщений, содержащих контекст для генерации ответа.
- `provider` (Optional[str], optional): Провайдер, предоставляющий модель. По умолчанию `None`.
- `tool_calls` (Optional[List[dict]], optional): Список вызовов инструментов, которые необходимо выполнить. По умолчанию `None`.
- `**kwargs`: Дополнительные аргументы, передаваемые в функцию обратного вызова.

**Возвращает**:

- `Iterator`: Итератор, который выдает чанки сгенерированного ответа и источники, если они доступны.

**Как работает функция**:

1. **Обработка поиска в интернете**: Если в `kwargs` передан параметр `web_search`, функция вызывает `do_search` для выполнения поиска и обновления сообщений. Используется `asyncio.run` для запуска асинхронной функции в синхронном контексте.
2. **Загрузка API-ключа**: Если провайдер требует аутентификации и API-ключ не передан в `kwargs`, функция пытается загрузить его с помощью `AuthManager.load_api_key` и добавить в `kwargs`.
3. **Обработка вызовов инструментов**: Если передан список `tool_calls`, функция итерируется по нему и выполняет соответствующие действия для каждого инструмента.
    - Для инструмента `SEARCH` функция вызывает `ToolHandler.validate_arguments` и `get_search_message` для подготовки сообщения с результатами поиска.
    - Для инструмента `CONTINUE` функция добавляет контекст для продолжения генерации текста.
    - Для инструмента `BUCKET` функция заменяет идентификаторы хранилища на содержимое хранилища в сообщениях.
4. **Обработка чанков ответа**: Функция вызывает функцию обратного вызова `iter_callback` для получения итератора чанков ответа.
5. **Обработка промежуточных результатов**: Функция использует `ThinkingProcessor` для обработки чанков, содержащих теги `<think>` и `</think>`, и выдает промежуточные результаты.
6. **Выдача результатов**: Функция итерируется по чанкам ответа, полученным из итератора, и выдает их.
7. **Выдача источников**: Если доступны источники (`sources`), функция выдает их после завершения итерации по чанкам ответа.

**ASCII flowchart**:

```
    Начало
     ↓
  Проверка web_search
     ↓
  Загрузка API-ключа (если нужно)
     ↓
  Обработка tool_calls
     ↓
  Вызов iter_callback для получения итератора чанков
     ↓
  Обработка чанков ответа (ThinkingProcessor)
     ↓
  Выдача чанков ответа
     ↓
  Выдача источников (если есть)
     ↓
    Конец
```

**Примеры**:

```python
# Пример использования с синхронным провайдером
def main():
    from ..providers import KoboldAI
    provider = KoboldAI
    model = "default"
    messages = [{"role": "user", "content": "Что такое Python?"}]
    for chunk in iter_run_tools(provider.create_generator, model, messages, provider=provider, web_search="Python programming language"):
        print(chunk)

main()