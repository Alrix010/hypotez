# Модуль для тестирования сценариев рекламы

## Обзор

Модуль содержит тесты для оценки и создания рекламных сценариев, а также для профилирования потребителей. Он использует библиотеку `tinytroupe` для моделирования поведения агентов в различных сценариях.

## Подробней

Этот модуль предназначен для тестирования различных аспектов рекламных кампаний, включая оценку эффективности рекламных объявлений и выявление потребительских предпочтений. Он использует агентов `tinytroupe` для имитации поведения реальных людей в различных сценариях.

## Функции

### `test_ad_evaluation_scenario`

```python
def test_ad_evaluation_scenario(setup):
    """
    Оценивает рекламные объявления на основе поискового запроса пользователя.

    Args:
        setup: Параметры настройки тестовой среды.

    Raises:
        AssertionError: Если результат отсутствует, поле ad_id отсутствует,
                        значение ad_id не соответствует допустимым вариантам,
                        поле ad_title отсутствует или поле justification отсутствует.

    Example:
        >>> test_ad_evaluation_scenario(setup)
    """
```

**Назначение**:
Функция `test_ad_evaluation_scenario` оценивает, насколько эффективны различные рекламные объявления, представленные агентам `tinytroupe`, в контексте заданного поискового запроса. Она создает сценарий, в котором агенты оценивают несколько рекламных объявлений и выбирают наиболее убедительное.

**Параметры**:
- `setup`: Параметры настройки тестовой среды.

**Возвращает**:
- Отсутствует. Функция проверяет утверждения (assert) о корректности результатов, полученных от агентов.

**Вызывает исключения**:
- `AssertionError`: Возникает, если результат отсутствует, поле `ad_id` отсутствует, значение `ad_id` не соответствует допустимым вариантам (1, 2, 3, 4), поле `ad_title` отсутствует или поле `justification` отсутствует.

**Как работает функция**:
1. **Определение рекламных объявлений**: Функция определяет несколько рекламных объявлений (`travel_ad_1`, `travel_ad_2`, `travel_ad_3`, `travel_ad_4`), связанных с туристическими услугами в Европе.
2. **Формирование запроса на оценку**: Функция формирует текстовый запрос (`eval_request_msg`), который содержит описание задачи для агентов: оценить рекламные объявления и выбрать наиболее убедительное, объяснив свой выбор на основе личного опыта и предпочтений.
3. **Определение контекста**: Функция определяет контекст (`situation`), описывающий ситуацию, в которой находится пользователь, ищущий информацию о путешествиях в Европу.
4. **Определение цели извлечения**: Функция определяет цель извлечения (`extraction_objective`), указывающую, какую информацию необходимо извлечь из ответов агентов: номер выбранного рекламного объявления, его заголовок и обоснование выбора.
5. **Создание агентов**: Функция создает двух агентов (`create_oscar_the_architect()`, `create_lisa_the_data_scientist()`), представляющих разных личностей.
6. **Взаимодействие агентов с запросом**: Для каждого агента:
   - Изменяется контекст агента на заданный (`person.change_context(situation)`).
   - Агент слушает и действует, основываясь на запросе (`person.listen_and_act(eval_request_msg)`).
7. **Извлечение результатов**: Функция извлекает результаты из ответов каждого агента с помощью `ResultsExtractor`.
8. **Проверка результатов**: Функция проверяет, что результаты соответствуют ожидаемым критериям:
   - Результат не должен быть `None`.
   - Результат должен содержать поле `ad_id`.
   - Значение поля `ad_id` должно быть одним из допустимых вариантов (1, 2, 3, 4).
   - Результат должен содержать поле `ad_title`.
   - Результат должен содержать поле `justification`.
9. **Проверка количества выборов**: Функция проверяет, что было сделано два выбора (по одному от каждого агента).

**ASCII flowchart функции**:

```
Начало
  ↓
Определение рекламных объявлений (travel_ad_1, travel_ad_2, travel_ad_3, travel_ad_4)
  ↓
Формирование запроса на оценку (eval_request_msg)
  ↓
Определение контекста (situation)
  ↓
Определение цели извлечения (extraction_objective)
  ↓
Создание агентов (oscar, lisa)
  ↓
Для каждого агента:
    ↓
    Изменение контекста агента (person.change_context)
    ↓
    Агент слушает и действует (person.listen_and_act)
    ↓
Извлечение результатов (ResultsExtractor)
  ↓
Проверка результатов (assert)
  ↓
Проверка количества выборов (assert)
  ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции с настроенной тестовой средой
test_ad_evaluation_scenario(setup)
```

### `test_ad_creation_scenario`

```python
def test_ad_creation_scenario(setup, focus_group_world):
    """
    Тестирует сценарий создания рекламы с использованием фокус-группы.

    Args:
        setup: Параметры настройки тестовой среды.
        focus_group_world: Объект мира фокус-группы.

    Raises:
        AssertionError: Если предложение не содержит идей для рекламы квартиры.

    Example:
        >>> test_ad_creation_scenario(setup, focus_group_world)
    """
```

**Назначение**:
Функция `test_ad_creation_scenario` тестирует сценарий создания рекламного объявления для сдачи квартиры в аренду с использованием фокус-группы агентов `tinytroupe`. Она моделирует обсуждение в фокус-группе, чтобы найти наилучший способ рекламировать квартиру.

**Параметры**:
- `setup`: Параметры настройки тестовой среды.
- `focus_group_world`: Объект мира фокус-группы, содержащий агентов, участвующих в обсуждении.

**Возвращает**:
- Отсутствует. Функция проверяет утверждение (assert) о том, что результат содержит идеи для рекламного объявления.

**Вызывает исключения**:
- `AssertionError`: Возникает, если результат, полученный от фокус-группы, не содержит идей для рекламного объявления квартиры.

**Как работает функция**:
1. **Определение контекста**: Функция определяет контекст (`situation`), описывающий сценарий фокус-группы, в которой друзья помогают владельцу квартиры (Paulo) найти наилучший способ рекламировать ее для сдачи в аренду.
2. **Определение описания квартиры**: Функция определяет описание квартиры (`apartment_description`), содержащее подробную информацию о ее характеристиках и преимуществах.
3. **Определение задачи**: Функция определяет задачу (`task`) для фокус-группы: обсудить наилучший способ рекламировать квартиру, чтобы Paulo мог найти хорошего арендатора.
4. **Настройка фокус-группы**: Функция получает объект мира фокус-группы (`focus_group`) из параметров.
5. **Трансляция информации**: Функция транслирует контекст, описание квартиры и задачу всем агентам в фокус-группе (`focus_group.broadcast`).
6. **Запуск симуляции**: Функция запускает симуляцию обсуждения в фокус-группе на 2 шага (`focus_group.run(2)`).
7. **Извлечение результатов**: Функция извлекает результаты из мира фокус-группы с помощью `ResultsExtractor`.
8. **Проверка результатов**: Функция проверяет, что результат содержит идеи для рекламного объявления квартиры с помощью функции `proposition_holds`.

**ASCII flowchart функции**:

```
Начало
  ↓
Определение контекста (situation)
  ↓
Определение описания квартиры (apartment_description)
  ↓
Определение задачи (task)
  ↓
Настройка фокус-группы (focus_group)
  ↓
Трансляция информации (focus_group.broadcast)
  ↓
Запуск симуляции (focus_group.run)
  ↓
Извлечение результатов (ResultsExtractor)
  ↓
Проверка результатов (assert)
  ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции с настроенной тестовой средой и миром фокус-группы
test_ad_creation_scenario(setup, focus_group_world)
```

### `test_consumer_profiling_scenario`

```python
def test_consumer_profiling_scenario(setup):
    """
    Тестирует сценарий профилирования потребителей.

    Args:
        setup: Параметры настройки тестовой среды.

    Raises:
        AssertionError: Если файл кэша не был создан.

    Example:
        >>> test_consumer_profiling_scenario(setup)
    """
```

**Назначение**:
Функция `test_consumer_profiling_scenario` тестирует сценарий профилирования потребителей для исследования рынка. Она генерирует случайных потребителей с подробными предпочтениями и собирает их мнения о конкретном продукте (бутылочный гаспачо).

**Параметры**:
- `setup`: Параметры настройки тестовой среды.

**Возвращает**:
- Отсутствует. Функция проверяет утверждение (assert) о том, что файл кэша был создан.

**Вызывает исключения**:
- `AssertionError`: Возникает, если файл кэша (`test_consumer_profiling_scenario.cache.json`) не был создан.

**Как работает функция**:
1. **Удаление файла кэша**: Функция удаляет файл кэша, если он существует (`remove_file_if_exists("test_consumer_profiling_scenario.cache.json")`).
2. **Начало управления**: Функция начинает управление, указывая имя файла кэша (`control.begin("test_consumer_profiling_scenario.cache.json")`).
3. **Определение общего контекста**: Функция определяет общий контекст (`general_context`), описывающий цель исследования рынка и целевую аудиторию.
4. **Создание фабрики потребителей**: Функция создает фабрику потребителей (`TinyPersonFactory`) с заданным контекстом.
5. **Опрос потребителей**: Функция `interview_consumer_batch` опрашивает заданное количество потребителей:
   - Для каждого потребителя:
     - Генерируется случайный потребитель с подробными предпочтениями (`consumer_factory.generate_person`).
     - Потребителю задаются вопросы о его личности, интересах и отношении к бутылочному гаспачо (`consumer.listen_and_act`).
     - Потребитель добавляется в список (`consumers.append(consumer)`).
     - Создается контрольная точка (`control.checkpoint()`).
6. **Проверка создания файла кэша**: Функция проверяет, что файл кэша был создан (`os.path.exists`).
7. **Завершение управления**: Функция завершает управление (`control.end()`).

**Внутренние функции**:

### `interview_consumer_batch`

```python
def interview_consumer_batch(n):
    """
    Опрашивает пакет потребителей.

    Args:
        n (int): Количество потребителей для опроса.
    """
```

**Назначение**:
Внутренняя функция `interview_consumer_batch` опрашивает заданное количество потребителей и собирает их мнения.

**Параметры**:
- `n` (int): Количество потребителей для опроса.

**Как работает функция**:
1.  **Цикл по количеству потребителей**: Функция выполняет цикл `n` раз, опрашивая каждого потребителя.
2.  **Создание потребителя**: Для каждого потребителя создается новый объект `TinyPerson` с использованием фабрики `consumer_factory`. Этот объект представляет собой случайного человека с детальными предпочтениями.
3.  **Опрос потребителя**: Потребителю задаются вопросы о его личности, интересах и отношении к бутылочному гаспачо с использованием метода `listen_and_act`. Этот метод позволяет агенту взаимодействовать с окружением и выражать свое мнение.
4.  **Добавление потребителя в список**: Опрошенный потребитель добавляется в список `consumers` для дальнейшего анализа.
5.  **Создание контрольной точки**: После опроса каждого потребителя создается контрольная точка с использованием метода `control.checkpoint()`. Это позволяет сохранить состояние симуляции и возобновить ее в случае прерывания.

**ASCII flowchart функции**:

```
Начало
  ↓
Цикл от 1 до n (количество потребителей)
  ↓
Создание потребителя (consumer = consumer_factory.generate_person)
  ↓
Опрос потребителя (consumer.listen_and_act)
  ↓
Добавление потребителя в список (consumers.append(consumer))
  ↓
Создание контрольной точки (control.checkpoint())
  ↓
Конец цикла
  ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции interview_consumer_batch для опроса 15 потребителей
interview_consumer_batch(15)
```

**ASCII flowchart функции**:

```
Начало
  ↓
Определение общего контекста (general_context)
  ↓
Создание фабрики потребителей (TinyPersonFactory)
  ↓
Вызов interview_consumer_batch(15)
  ↓
Проверка создания файла кэша (assert)
  ↓
Завершение управления (control.end())
  ↓
Конец
```

**Примеры**:

```python
# Пример вызова функции с настроенной тестовой средой
test_consumer_profiling_scenario(setup)