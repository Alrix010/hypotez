# Модуль experimentation.py

## Обзор

Модуль `experimentation.py` предназначен для проведения A/B-тестирований и экспериментов в рамках проекта `hypotez`. Он содержит классы для рандомизации выбора между двумя вариантами и применения различных интервенций (воздействий) к агентам и окружению.

## Подробней

Модуль предоставляет класс `ABRandomizer` для случайного выбора между двумя опциями и последующей дерандомизации. Это полезно для проведения A/B-тестов, где необходимо случайным образом назначать пользователям один из двух вариантов, а затем анализировать результаты, учитывая сделанный выбор.

Также в модуле находится класс `Intervention`, который предназначен для применения различных воздействий к агентам и окружению. Этот класс пока находится в разработке, но он позволяет задавать предусловия и эффекты интервенций, что делает его полезным для моделирования различных сценариев и оценки их влияния на систему.

## Классы

### `ABRandomizer`

**Описание**: Класс `ABRandomizer` предоставляет функциональность для рандомизации между двумя опциями и последующей дерандомизации. Он используется для проведения A/B-тестов, где необходимо случайным образом назначать пользователям один из двух вариантов, а затем анализировать результаты, учитывая сделанный выбор.

**Принцип работы**:

Класс `ABRandomizer` инициализируется с указанием реальных и "слепых" имен опций, а также списка имен, которые не нужно рандомизировать. Метод `randomize` случайным образом выбирает между двумя опциями и сохраняет информацию о сделанном выборе. Метод `derandomize` позволяет восстановить исходный порядок опций на основе сохраненной информации. Метод `derandomize_name` позволяет декодировать выбор пользователя, возвращая реальное имя опции на основе "слепого" имени.

**Атрибуты**:

-   `choices` (dict): Словарь, в котором хранятся результаты рандомизации для каждого элемента. Ключом является индекс элемента, значением - кортеж из двух чисел, указывающих, была ли произведена перестановка опций.
-   `real_name_1` (str): Реальное имя первой опции.
-   `real_name_2` (str): Реальное имя второй опции.
-   `blind_name_a` (str): "Слепое" имя первой опции (используется для представления опции пользователю).
-   `blind_name_b` (str): "Слепое" имя второй опции (используется для представления опции пользователю).
-   `passtrough_name` (list): Список имен, которые не нужно рандомизировать.
-   `random_seed` (int): Зерно для генератора случайных чисел.

**Методы**:

-   `__init__(self, real_name_1="control", real_name_2="treatment", blind_name_a="A", blind_name_b="B", passtrough_name=[], random_seed=42)`: Инициализирует объект `ABRandomizer` с указанными параметрами.
-   `randomize(self, i, a, b)`: Случайно меняет местами `a` и `b` и возвращает их. Сохраняет информацию о перестановке для последующей дерандомизации.
-   `derandomize(self, i, a, b)`: Возвращает `a` и `b` в исходном порядке на основе сохраненной информации о рандомизации.
-   `derandomize_name(self, i, blind_name)`: Декодирует выбор пользователя, возвращая реальное имя опции на основе "слепого" имени.

#### `__init__`

```python
def __init__(self, real_name_1="control", real_name_2="treatment",
                       blind_name_a="A", blind_name_b="B",
                       passtrough_name=[],
                       random_seed=42):
```

**Назначение**: Инициализирует экземпляр класса `ABRandomizer`.

**Параметры**:

-   `real_name_1` (str): Реальное имя первой опции. По умолчанию "control".
-   `real_name_2` (str): Реальное имя второй опции. По умолчанию "treatment".
-   `blind_name_a` (str): "Слепое" имя первой опции. По умолчанию "A".
-   `blind_name_b` (str): "Слепое" имя второй опции. По умолчанию "B".
-   `passtrough_name` (list): Список имен, которые не нужно рандомизировать. По умолчанию [].
-   `random_seed` (int): Зерно для генератора случайных чисел. По умолчанию 42.

**Как работает функция**:

1.  Инициализирует словарь `self.choices` для хранения информации о рандомизации.
2.  Сохраняет реальные и "слепые" имена опций в атрибутах экземпляра класса.
3.  Сохраняет список имен, которые не нужно рандомизировать, в атрибуте экземпляра класса.
4.  Сохраняет зерно для генератора случайных чисел в атрибуте экземпляра класса.

```
A (Инициализация атрибутов класса)
|
B (Сохранение параметров в атрибуты экземпляра)
```

**Примеры**:

```python
randomizer = ABRandomizer(real_name_1="control", real_name_2="treatment", blind_name_a="A", blind_name_b="B", passtrough_name=[], random_seed=42)
```

#### `randomize`

```python
def randomize(self, i, a, b):
```

**Назначение**: Случайно меняет местами `a` и `b` и возвращает их. Сохраняет информацию о перестановке для последующей дерандомизации.

**Параметры**:

-   `i` (int): Индекс элемента.
-   `a` (str): Первая опция.
-   `b` (str): Вторая опция.

**Возвращает**:

-   `(str, str)`: Кортеж из двух строк, представляющих опции `a` и `b`, возможно, переставленные местами.

**Как работает функция**:

1.  Инициализирует генератор случайных чисел с использованием зерна `self.random_seed`.
2.  Если случайное число меньше 0.5, сохраняет в `self.choices[i]` кортеж `(0, 1)` и возвращает `a`, `b` без изменений.
3.  Иначе сохраняет в `self.choices[i]` кортеж `(1, 0)` и возвращает `b`, `a` (опции переставлены местами).

```
A (Инициализация генератора случайных чисел)
|
B (Генерация случайного числа)
|
C (Проверка условия: случайное число < 0.5)
|
D (Если условие выполнено: сохранение (0, 1) в self.choices[i] и возврат a, b)
|
E (Если условие не выполнено: сохранение (1, 0) в self.choices[i] и возврат b, a)
```

**Примеры**:

```python
randomizer = ABRandomizer()
a, b = randomizer.randomize(1, "option1", "option2")
print(f"Рандомизированные опции: a={a}, b={b}")
```

#### `derandomize`

```python
def derandomize(self, i, a, b):
```

**Назначение**: Возвращает `a` и `b` в исходном порядке на основе сохраненной информации о рандомизации.

**Параметры**:

-   `i` (int): Индекс элемента.
-   `a` (str): Первая опция.
-   `b` (str): Вторая опция.

**Возвращает**:

-   `(str, str)`: Кортеж из двух строк, представляющих опции `a` и `b` в исходном порядке.

**Вызывает исключения**:

-   `Exception`: Если для элемента `i` не найдена информация о рандомизации.

**Как работает функция**:

1.  Проверяет значение `self.choices[i]`.
2.  Если `self.choices[i]` равно `(0, 1)`, возвращает `a`, `b` без изменений.
3.  Если `self.choices[i]` равно `(1, 0)`, возвращает `b`, `a` (опции переставлены местами).
4.  Если для элемента `i` не найдена информация о рандомизации, выбрасывает исключение `Exception`.

```
A (Проверка наличия информации о рандомизации для элемента i)
|
B (Если self.choices[i] == (0, 1): возврат a, b)
|
C (Если self.choices[i] == (1, 0): возврат b, a)
|
D (Если информация о рандомизации не найдена: выброс исключения)
```

**Примеры**:

```python
randomizer = ABRandomizer()
a, b = randomizer.randomize(1, "option1", "option2")
a, b = randomizer.derandomize(1, a, b)
print(f"Дерандомизированные опции: a={a}, b={b}")
```

#### `derandomize_name`

```python
def derandomize_name(self, i, blind_name):
```

**Назначение**: Декодирует выбор пользователя, возвращая реальное имя опции на основе "слепого" имени.

**Параметры**:

-   `i` (int): Индекс элемента.
-   `blind_name` (str): "Слепое" имя выбранной опции.

**Возвращает**:

-   `str`: Реальное имя выбранной опции.

**Вызывает исключения**:

-   `Exception`: Если для элемента `i` не найдена информация о рандомизации или если "слепое" имя не распознано.

**Как работает функция**:

1.  Проверяет значение `self.choices[i]`.
2.  Если `self.choices[i]` равно `(0, 1)`:
    *   Если `blind_name` равно `self.blind_name_a`, возвращает `self.real_name_1`.
    *   Если `blind_name` равно `self.blind_name_b`, возвращает `self.real_name_2`.
    *   Если `blind_name` присутствует в `self.passtrough_name`, возвращает `blind_name`.
    *   Иначе выбрасывает исключение `Exception`.
3.  Если `self.choices[i]` равно `(1, 0)`:
    *   Если `blind_name` равно `self.blind_name_a`, возвращает `self.real_name_2`.
    *   Если `blind_name` равно `self.blind_name_b`, возвращает `self.real_name_1`.
    *   Если `blind_name` присутствует в `self.passtrough_name`, возвращает `blind_name`.
    *   Иначе выбрасывает исключение `Exception`.
4.  Если для элемента `i` не найдена информация о рандомизации, выбрасывает исключение `Exception`.

```
A (Проверка наличия информации о рандомизации для элемента i)
|
B (Если self.choices[i] == (0, 1):)
|   |
|   C (Проверка blind_name и возврат соответствующего real_name)
|
D (Если self.choices[i] == (1, 0):)
|   |
|   E (Проверка blind_name и возврат соответствующего real_name)
|
F (Если информация о рандомизации не найдена: выброс исключения)
```

**Примеры**:

```python
randomizer = ABRandomizer(real_name_1="control", real_name_2="treatment", blind_name_a="A", blind_name_b="B")
randomizer.randomize(1, "A", "B")
real_name = randomizer.derandomize_name(1, "A")
print(f"Реальное имя выбранной опции: {real_name}")
```

### `Intervention`

**Описание**: Класс `Intervention` предназначен для применения различных воздействий к агентам и окружению. Этот класс пока находится в разработке, но он позволяет задавать предусловия и эффекты интервенций, что делает его полезным для моделирования различных сценариев и оценки их влияния на систему.

**Принцип работы**:

Класс `Intervention` инициализируется с указанием агента(ов) и/или окружения(й), к которым будет применена интервенция. Он позволяет задавать предусловия в виде текста или функции, а также эффект интервенции в виде функции. Метод `check_precondition` проверяет, выполнены ли предусловия для применения интервенции. Метод `apply` применяет эффект интервенции к указанным агентам и/или окружению.

**Атрибуты**:

-   `agents` (list): Список агентов, к которым будет применена интервенция.
-   `environments` (list): Список окружений, к которым будет применена интервенция.
-   `text_precondition` (str): Предусловие в виде текста (для интерпретации языковой моделью).
-   `precondition_func` (function): Предусловие в виде функции (для выполнения кодом).
-   `effect_func` (function): Функция, представляющая эффект интервенции.

**Методы**:

-   `__init__(self, agent=None, agents:list=None, environment=None, environments:list=None)`: Инициализирует объект `Intervention` с указанными параметрами.
-   `check_precondition(self)`: Проверяет, выполнены ли предусловия для применения интервенции.
-   `apply(self)`: Применяет интервенцию.
-   `set_textual_precondition(self, text)`: Устанавливает предусловие в виде текста.
-   `set_functional_precondition(self, func)`: Устанавливает предусловие в виде функции.
-   `set_effect(self, effect_func)`: Устанавливает эффект интервенции.

#### `__init__`

```python
def __init__(self, agent=None, agents:list=None, environment=None, environments:list=None):
```

**Назначение**: Инициализирует экземпляр класса `Intervention`.

**Параметры**:

-   `agent` (TinyPerson, optional): Агент, к которому будет применена интервенция.
-   `agents` (list, optional): Список агентов, к которым будет применена интервенция.
-   `environment` (TinyWorld, optional): Окружение, к которому будет применена интервенция.
-   `environments` (list, optional): Список окружений, к которым будет применена интервенция.

**Вызывает исключения**:

-   `Exception`: Если не указан ни один агент или окружение, или если указан одновременно и агент, и список агентов, или если указано одновременно и окружение, и список окружений.

**Как работает функция**:

1.  Проверяет, что указан хотя бы один параметр (агент или окружение).
2.  Проверяет, что не указаны одновременно агент и список агентов, а также окружение и список окружений.
3.  Инициализирует атрибуты `self.agents` и `self.environments` в зависимости от переданных параметров.

```
A (Проверка наличия хотя бы одного параметра)
|
B (Проверка одновременного указания агента и списка агентов)
|
C (Проверка одновременного указания окружения и списка окружений)
|
D (Инициализация self.agents и self.environments)
```

**Примеры**:

```python
agent = TinyPerson()
intervention = Intervention(agent=agent)

agents = [TinyPerson(), TinyPerson()]
intervention = Intervention(agents=agents)
```

#### `check_precondition`

```python
def check_precondition(self):
```

**Назначение**: Проверяет, выполнены ли предусловия для применения интервенции.

**Вызывает исключения**:

-   `NotImplementedError`: Метод не реализован.

**Как работает функция**:

1.  Выбрасывает исключение `NotImplementedError`, так как метод должен быть реализован в подклассах.

```
A (Выброс исключения NotImplementedError)
```

#### `apply`

```python
def apply(self):
```

**Назначение**: Применяет интервенцию.

**Как работает функция**:

1.  Вызывает функцию `self.effect_func` с аргументами `self.agents` и `self.environments`.

```
A (Вызов self.effect_func)
```

#### `set_textual_precondition`

```python
def set_textual_precondition(self, text):
```

**Назначение**: Устанавливает предусловие в виде текста.

**Параметры**:

-   `text` (str): Текст предусловия.

**Как работает функция**:

1.  Сохраняет текст предусловия в атрибуте `self.text_precondition`.

```
A (Сохранение текста предусловия в self.text_precondition)
```

#### `set_functional_precondition`

```python
def set_functional_precondition(self, func):
```

**Назначение**: Устанавливает предусловие в виде функции.

**Параметры**:

-   `func` (function): Функция предусловия. Функция должна принимать аргументы: agent, agents, environment, environments.

**Как работает функция**:

1.  Сохраняет функцию предусловия в атрибуте `self.precondition_func`.

```
A (Сохранение функции предусловия в self.precondition_func)
```

#### `set_effect`

```python
def set_effect(self, effect_func):
```

**Назначение**: Устанавливает эффект интервенции.

**Параметры**:

-   `effect_func` (function): Функция эффекта интервенции.

**Как работает функция**:

1.  Сохраняет функцию эффекта интервенции в атрибуте `self.effect_func`.

```
A (Сохранение функции эффекта в self.effect_func)
```