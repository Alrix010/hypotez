# Модуль для рендеринга и разметки в Tiny Troupe
=====================================================

Модуль содержит функции и класс для обработки текста, стилизации и рендеринга, используемые в проекте Tiny Troupe.
Этот модуль предоставляет инструменты для инъекции стилей, обрезки текста, форматирования даты и времени, а также работы со стилями текста.

## Обзор

Модуль предоставляет набор утилит для работы с текстом и HTML, включая добавление CSS-стилей, обрезку длинного текста, форматирование даты и времени, удаление отступов и перенос текста. Также включает класс `RichTextStyle` для управления стилями текста.

## Подробней

Этот модуль содержит функции, необходимые для обработки и отображения текстовых данных в приложении Tiny Troupe. Он предоставляет инструменты для форматирования текста, добавления стилей и обрезки длинных строк, что делает его важным компонентом для обеспечения читаемости и удобства использования приложения.

## Функции

### `inject_html_css_style_prefix`

**Назначение**: Вставляет префикс стиля ко всем атрибутам `style` в предоставленной HTML-строке.

**Параметры**:
- `html` (str): HTML-строка, в которой нужно вставить префикс стиля.
- `style_prefix_attributes` (str): Префикс стиля, который нужно вставить.

**Возвращает**:
- `str`: HTML-строка с вставленным префиксом стиля.

**Пример**:

```python
html = '<div style="color: red;">Hello</div>'
style_prefix = 'font-size: 20px;'
result = inject_html_css_style_prefix(html, style_prefix)
print(result)  # Вывод: <div style="font-size: 20px;color: red;">Hello</div>
```
**Как работает функция**:
Функция использует метод `replace` для замены всех вхождений `style="` в HTML-строке на `style="{style_prefix_attributes};`. Это позволяет добавить дополнительные стили к существующим стилям элемента HTML.

### `break_text_at_length`

**Назначение**: Обрезает текст или JSON до указанной длины, вставляя строку `(...)` в точке обрыва.

**Параметры**:
- `text` (Union[str, dict]): Текст или словарь, который нужно обрезать.
- `max_length` (Optional[int], optional): Максимальная длина текста. Если `None`, текст возвращается без изменений. По умолчанию `None`.

**Возвращает**:
- `str`: Обрезанный текст с добавленной строкой `(...)`, если текст превышает максимальную длину.

**Как работает функция**:
1. Если входные данные — словарь, функция преобразует их в JSON-строку с отступами.
2. Проверяет, задана ли максимальная длина и не превышает ли длина текста это значение.
3. Если максимальная длина задана и текст длиннее, функция обрезает текст до указанной длины и добавляет `(...)` в конце.

**Примеры**:

```python
text = "This is a long text that needs to be truncated."
result = break_text_at_length(text, max_length=20)
print(result)  # Вывод: This is a long tex (...)

data = {"key1": "value1", "key2": "value2"}
result = break_text_at_length(data, max_length=30)
print(result)
# Вывод:
# {
#     "key1": "value1",
#     "key2": " (...)
```

### `pretty_datetime`

**Назначение**: Возвращает строковое представление объекта `datetime` в формате `YYYY-MM-DD HH:MM`.

**Параметры**:
- `dt` (datetime): Объект `datetime`, который нужно преобразовать.

**Возвращает**:
- `str`: Строковое представление даты и времени в формате `YYYY-MM-DD HH:MM`.

**Пример**:

```python
now = datetime.now()
result = pretty_datetime(now)
print(result)  # Вывод: 2024-07-03 14:30 (текущая дата и время)
```

**Как работает функция**:
Функция использует метод `strftime` объекта `datetime` для форматирования даты и времени в указанном формате.

### `dedent`

**Назначение**: Удаляет начальные пробелы и отступы из указанного текста.

**Параметры**:
- `text` (str): Текст, из которого нужно удалить отступы.

**Возвращает**:
- `str`: Текст без начальных пробелов и отступов.

**Пример**:

```python
text = "   This is a text with leading spaces."
result = dedent(text)
print(result)  # Вывод: This is a text with leading spaces.
```

**Как работает функция**:
Функция использует `textwrap.dedent` для удаления общих начальных пробелов, а затем `strip` для удаления оставшихся начальных и конечных пробелов.

### `wrap_text`

**Назначение**: Переносит текст на указанную ширину.

**Параметры**:
- `text` (str): Текст, который нужно перенести.
- `width` (int, optional): Ширина, на которую нужно перенести текст. По умолчанию 100.

**Возвращает**:
- `str`: Текст, перенесенный на указанную ширину.

**Пример**:

```python
text = "This is a long text that needs to be wrapped to a specific width."
result = wrap_text(text, width=40)
print(result)
# Вывод:
# This is a long text that needs to be
# wrapped to a specific width.
```

**Как работает функция**:
Функция использует `textwrap.fill` для переноса текста на указанную ширину.

## Классы

### `RichTextStyle`

**Описание**: Класс, содержащий стили для текста, используемые в приложении.

**Атрибуты**:
- `STIMULUS_CONVERSATION_STYLE` (str): Стиль для текста разговора (bold italic cyan1).
- `STIMULUS_THOUGHT_STYLE` (str): Стиль для текста мыслей (dim italic cyan1).
- `STIMULUS_DEFAULT_STYLE` (str): Стиль для текста по умолчанию (italic).
- `ACTION_DONE_STYLE` (str): Стиль для выполненного действия (grey82).
- `ACTION_TALK_STYLE` (str): Стиль для речи (bold green3).
- `ACTION_THINK_STYLE` (str): Стиль для размышлений (green).
- `ACTION_DEFAULT_STYLE` (str): Стиль для действий по умолчанию (purple).
- `INTERVENTION_DEFAULT_STYLE` (str): Стиль для вмешательств по умолчанию (bright_magenta).

**Методы**:
- `get_style_for(kind: str, event_type: str = None) -> str`: Возвращает стиль для указанного типа события и вида контента.

**Принцип работы**:
Класс `RichTextStyle` предоставляет централизованный способ управления стилями текста в приложении. Он содержит предопределенные стили для различных типов контента (стимулы, действия, вмешательства) и событий (разговор, мысли, выполнение). Метод `get_style_for` позволяет получить нужный стиль в зависимости от типа контента и события.

#### `get_style_for`

```python
@classmethod
def get_style_for(cls, kind:str, event_type:str=None):
    """
    Возвращает стиль для указанного типа события и вида контента.

    Args:
        kind (str): Тип контента ("stimulus", "action", "intervention").
        event_type (str, optional): Тип события. По умолчанию None.

    Returns:
        str: Стиль для указанного типа события и вида контента.
    """
    ...
```

**Назначение**: Определяет и возвращает стиль текста на основе типа контента (`kind`) и типа события (`event_type`).

**Параметры**:
- `kind` (str): Тип контента, для которого требуется стиль (например, "stimulus", "action" или "intervention").
- `event_type` (str, optional): Тип события, связанного с контентом (например, "CONVERSATION", "THOUGHT" или "DONE"). По умолчанию `None`.

**Возвращает**:
- `str`: Строка, представляющая стиль текста, соответствующий заданным критериям.

**Как работает функция**:
1. Проверяет значение параметра `kind`, чтобы определить тип контента.
2. В зависимости от типа контента, функция выбирает соответствующий стиль:
   - Если `kind` равен "stimulus" или "stimuli":
     - Если `event_type` равен "CONVERSATION", возвращает стиль `STIMULUS_CONVERSATION_STYLE`.
     - Если `event_type` равен "THOUGHT", возвращает стиль `STIMULUS_THOUGHT_STYLE`.
     - В противном случае возвращает стиль `STIMULUS_DEFAULT_STYLE`.
   - Если `kind` равен "action":
     - Если `event_type` равен "DONE", возвращает стиль `ACTION_DONE_STYLE`.
     - Если `event_type` равен "TALK", возвращает стиль `ACTION_TALK_STYLE`.
     - Если `event_type` равен "THINK", возвращает стиль `ACTION_THINK_STYLE`.
     - В противном случае возвращает стиль `ACTION_DEFAULT_STYLE`.
   - Если `kind` равен "intervention", возвращает стиль `INTERVENTION_DEFAULT_STYLE`.
3. Если ни одно из условий не выполнено, возвращается стиль по умолчанию для соответствующего типа контента.

**Примеры**:

```python
style = RichTextStyle.get_style_for("stimulus", "CONVERSATION")
print(style)  # Вывод: bold italic cyan1

style = RichTextStyle.get_style_for("action", "DONE")
print(style)  # Вывод: grey82

style = RichTextStyle.get_style_for("intervention")
print(style)  # Вывод: bright_magenta
```