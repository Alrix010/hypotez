# Модуль для работы с LLM (Large Language Model)
==================================================

Модуль содержит утилиты для работы с большими языковыми моделями (LLM), включая подготовку входных данных, обработку выходных данных, управление вызовами моделей и прочее.

## Обзор

Этот модуль предоставляет набор функций и декораторов для упрощения взаимодействия с LLM, такими как OpenAI. Он включает в себя функции для составления сообщений для LLM на основе шаблонов, декоратор для преобразования функций в LLM-функции, утилиты для извлечения JSON и кодовых блоков из текста, а также инструменты для управления повторными попытками при возникновении ошибок и добавления переменных шаблонов RAI (Responsible AI).

## Подробней

Модуль предназначен для упрощения процесса интеграции и использования LLM в проекте `hypotez`. Он предоставляет инструменты для подготовки запросов, обработки ответов и управления вызовами моделей, а также обеспечивает возможность повторных попыток при возникновении ошибок.

## Функции

### `compose_initial_LLM_messages_with_templates`

**Назначение**: Составляет начальные сообщения для LLM, используя шаблоны системных и пользовательских сообщений.

**Параметры**:
- `system_template_name` (str): Имя файла шаблона системного сообщения.
- `user_template_name` (str, optional): Имя файла шаблона пользовательского сообщения. По умолчанию `None`.
- `base_module_folder` (str, optional): Базовая папка модуля. По умолчанию `None`.
- `rendering_configs` (dict, optional): Конфигурации для рендеринга шаблонов. По умолчанию `{}`.

**Возвращает**:
- `list`: Список сообщений для LLM, где каждое сообщение представляет собой словарь с ключами `"role"` и `"content"`.

**Как работает функция**:
- Определяет путь к шаблонам системных и пользовательских сообщений.
- Читает содержимое шаблонов и подставляет в них данные из `rendering_configs` с помощью библиотеки `chevron`.
- Формирует список сообщений для LLM, начиная с системного сообщения и добавляя пользовательское сообщение, если оно указано.
- Возвращает список сообщений.

**Примеры**:

```python
messages = compose_initial_LLM_messages_with_templates(
    system_template_name='system_prompt.md',
    user_template_name='user_prompt.md',
    rendering_configs={'task': 'translate to Russian'}
)
print(messages)
```

### `llm`

**Назначение**: Декоратор, который преобразует функцию в LLM-функцию.

**Параметры**:
- `model_overrides` (dict, optional): Переопределения параметров модели.

**Как работает функция**:

Декоратор оборачивает декорируемую функцию, чтобы при вызове этой функции результат или параметры использовались как инструкция для LLM. Ответ LLM приводится к указанному типу возврата функции.

**Внутренние функции**:

#### `decorator`

**Назначение**: Функция-декоратор, которая принимает функцию и возвращает обертку над ней.

**Параметры**:
- `func` (Callable): Декорируемая функция.

**Возвращает**:
- `Callable`: Обернутая функция.

#### `wrapper`

**Назначение**: Функция-обертка, которая выполняет вызов LLM и преобразует результат.

**Параметры**:
- `*args`: Произвольные позиционные аргументы.
- `**kwargs`: Произвольные именованные аргументы.

**Возвращает**:
- `Any`: Результат вызова LLM, приведенный к типу возврата функции.

**Примеры**:

```python
from typing import Optional

@llm(model="gpt-4-0613", temperature=0.5, max_tokens=100)
def joke(topic: str) -> Optional[str]:
    """
    You are a comedian that tells a joke about the topic that is passed in.
    """
    return f"Tell me a joke about {topic}."

result = joke(topic="icecream")
print(result)
```

### `extract_json`

**Назначение**: Извлекает JSON-объект из строки, игнорируя текст до первой открывающей фигурной скобки и Markdown-теги.

**Параметры**:
- `text` (str): Строка, из которой нужно извлечь JSON.

**Возвращает**:
- `dict`: Извлеченный JSON-объект. Возвращает пустой словарь `{}` в случае ошибки.

**Вызывает исключения**:
- `Exception`: Возникает при ошибке парсинга JSON.

**Как работает функция**:

1.  Удаляет любой текст до первой открывающей фигурной или квадратной скобки.
2.  Удаляет любой текст после последней закрывающей фигурной или квадратной скобки.
3.  Удаляет недопустимые escape-последовательности.
4.  Парсит JSON с помощью `json.loads(text, strict=False)`.
5.  Возвращает полученный JSON-объект.

**Примеры**:

```python
json_string = "```json\n{\"name\": \"John\", \"age\": 30}\n```"
data = extract_json(json_string)
print(data)  # Вывод: {'name': 'John', 'age': 30}
```

### `extract_code_block`

**Назначение**: Извлекает кодовый блок из строки, игнорируя текст до первого открытия тройных обратных кавычек и после закрытия.

**Параметры**:
- `text` (str): Строка, из которой нужно извлечь кодовый блок.

**Возвращает**:
- `str`: Извлеченный кодовый блок. Возвращает пустую строку `""` в случае ошибки.

**Как работает функция**:

1.  Удаляет любой текст до первого открытия тройных обратных кавычек.
2.  Удаляет любой текст после последнего закрытия тройных обратных кавычек.
3.  Возвращает извлеченный кодовый блок.

**Примеры**:

```python
code_string = "```python\nprint('Hello, world!')\n```"
code = extract_code_block(code_string)
print(code)  # Вывод: ```python\nprint('Hello, world!')\n```
```

### `repeat_on_error`

**Назначение**: Декоратор, который повторяет вызов функции при возникновении указанных исключений.

**Параметры**:
- `retries` (int): Количество попыток повтора.
- `exceptions` (list): Список классов исключений, которые нужно перехватывать.

**Как работает функция**:

Декоратор оборачивает декорируемую функцию, чтобы при вызове этой функции в случае возникновения одного из указанных исключений вызов повторялся до указанного количества раз. Если количество попыток исчерпано, исключение перебрасывается.

**Внутренние функции**:

#### `decorator`

**Назначение**: Функция-декоратор, которая принимает функцию и возвращает обертку над ней.

**Параметры**:
- `func` (Callable): Декорируемая функция.

**Возвращает**:
- `Callable`: Обернутая функция.

#### `wrapper`

**Назначение**: Функция-обертка, которая выполняет вызов функции и обрабатывает исключения.

**Параметры**:
- `*args`: Произвольные позиционные аргументы.
- `**kwargs`: Произвольные именованные аргументы.

**Возвращает**:
- `Any`: Результат вызова функции.

**Примеры**:

```python
class CustomError(Exception):
    pass

@repeat_on_error(retries=3, exceptions=[CustomError])
def flaky_function():
    """
    This function sometimes raises a CustomError.
    """
    import random
    if random.random() < 0.5:
        raise CustomError("Something went wrong!")
    return "Success!"

result = flaky_function()
print(result)
```

### `add_rai_template_variables_if_enabled`

**Назначение**: Добавляет переменные шаблонов RAI (Responsible AI) в словарь, если соответствующие параметры включены в конфигурации.

**Параметры**:
- `template_variables` (dict): Словарь переменных шаблонов.

**Возвращает**:
- `dict`: Обновленный словарь переменных шаблонов.

**Как работает функция**:

1.  Импортирует модуль `config` для доступа к конфигурационным параметрам.
2.  Проверяет, включены ли параметры `RAI_HARMFUL_CONTENT_PREVENTION` и `RAI_COPYRIGHT_INFRINGEMENT_PREVENTION` в конфигурации.
3.  Читает содержимое файлов `rai_harmful_content_prevention.md` и `rai_copyright_infringement_prevention.md`, если соответствующие параметры включены.
4.  Добавляет переменные `rai_harmful_content_prevention` и `rai_copyright_infringement_prevention` в словарь `template_variables`, устанавливая их значения в содержимое файлов или `None`, в зависимости от конфигурации.
5.  Возвращает обновленный словарь.

**Примеры**:

```python
template_vars = {}
updated_vars = add_rai_template_variables_if_enabled(template_vars)
print(updated_vars)
```

### `truncate_actions_or_stimuli`

**Назначение**: Усекает содержимое действий или стимулов до указанной максимальной длины.

**Параметры**:
- `list_of_actions_or_stimuli` (Collection[dict]): Список действий или стимулов для усечения.
- `max_content_length` (int): Максимальная длина содержимого.

**Возвращает**:
- `Collection[str]`: Усеченный список действий или стимулов.

**Как работает функция**:

1.  Создает глубокую копию исходного списка, чтобы избежать побочных эффектов.
2.  Итерируется по элементам клонированного списка.
3.  Для каждого элемента проверяет наличие ключа `"content"` в словаре.
4.  Если ключ `"content"` присутствует, проверяет наличие ключей `"action"`, `"stimulus"` или `"stimuli"` в содержимом сообщения.
5.  Усекает содержимое действия или стимула до указанной максимальной длины с помощью функции `break_text_at_length`.
6.  Возвращает усеченный список.

**Примеры**:

```python
actions = [{"role": "user", "content": {"action": {"content": "This is a long action."}}}]
truncated_actions = truncate_actions_or_stimuli(actions, 10)
print(truncated_actions)
```