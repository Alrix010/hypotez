# Модуль для работы с базой данных

## Обзор

Модуль определяет базовый класс для моделей данных, использует SQLAlchemy для асинхронного взаимодействия с базой данных и предоставляет удобные методы для работы с данными, такие как преобразование объектов в словари.

## Подробней

Модуль содержит конфигурацию подключения к базе данных, создает движок SQLAlchemy для асинхронной работы, определяет базовый класс `Base` для всех моделей, от которого наследуются остальные классы моделей. Базовый класс содержит общие поля, такие как `id`, `created_at` и `updated_at`, а также метод для преобразования объекта модели в словарь.
Этот модуль позволяет единообразно и эффективно работать с базой данных в асинхронном режиме.

## Классы

### `Base`

**Описание**:
Базовый класс для всех моделей данных. Предоставляет общие атрибуты и функциональность для работы с таблицами базы данных.

**Наследует**:
`AsyncAttrs`, `DeclarativeBase` из SQLAlchemy.

**Атрибуты**:
- `id` (int): Уникальный идентификатор записи, первичный ключ, автоинкремент.
- `created_at` (datetime): Дата и время создания записи, устанавливается автоматически при создании.
- `updated_at` (datetime): Дата и время последнего обновления записи, обновляется автоматически при каждом изменении.

**Методы**:
- `to_dict()`: Преобразует объект модели в словарь, где ключами являются имена столбцов, а значениями - соответствующие значения атрибутов объекта.

**Принцип работы**:
Класс `Base` служит основой для определения всех моделей, представляющих таблицы в базе данных. Он предоставляет общие атрибуты и функциональность, такие как автоматическое ведение времени создания и обновления записей, а также удобный метод для преобразования объектов моделей в словари.
Благодаря наследованию от `AsyncAttrs` и `DeclarativeBase` из SQLAlchemy, класс `Base` обеспечивает асинхронное взаимодействие с базой данных и декларативное описание структуры таблиц.

### `__tablename__`

```python
    @classmethod
    @property
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + 's'
```

**Описание**:
Динамическое определение имени таблицы в базе данных на основе имени класса модели.

**Параметры**:
- `cls` (class): Класс, для которого определяется имя таблицы.

**Возвращает**:
- `str`: Имя таблицы в нижнем регистре с добавлением суффикса "s".

**Как работает функция**:
Метод `__tablename__` автоматически генерирует имя таблицы в базе данных на основе имени класса модели. Он преобразует имя класса в нижний регистр и добавляет суффикс "s", что позволяет автоматически связывать модель с соответствующей таблицей.

**Примеры**:

```python
class User(Base):
    __tablename__ = 'users'  # Имя таблицы будет 'users'
```

### `to_dict`

```python
    def to_dict(self) -> dict:
        # Метод для преобразования объекта в словарь
        return {c.name: getattr(self, c.name) for c in self.__table__.columns}
```

**Описание**:
Преобразует объект модели в словарь, где ключами являются имена столбцов, а значениями - соответствующие значения атрибутов объекта.

**Параметры**:
- `self` (Base): Объект модели, который необходимо преобразовать в словарь.

**Возвращает**:
- `dict`: Словарь, представляющий объект модели.

**Как работает функция**:
Метод `to_dict` использует генератор словаря для перебора всех столбцов в таблице, связанной с моделью, и создает словарь, где ключами являются имена столбцов, а значениями - значения соответствующих атрибутов объекта модели.

**Примеры**:

```python
from datetime import datetime

class User(Base):
    __tablename__ = 'users'
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column()
    email: Mapped[str] = mapped_column()
    created_at: Mapped[datetime] = mapped_column(TIMESTAMP, server_default=func.now())

# Допустим, у нас есть объект user
# user = User(id=1, name='John Doe', email='john.doe@example.com', created_at=datetime.now())
# dictionary = user.to_dict()
# print(dictionary)
# Результат будет: {'id': 1, 'name': 'John Doe', 'email': 'john.doe@example.com', 'created_at': datetime.datetime(2023, 10, 21, 14, 30, 0)}