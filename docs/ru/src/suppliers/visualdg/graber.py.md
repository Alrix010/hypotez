# Модуль `graber.py`

## Обзор

Модуль предназначен для сбора значений полей товаров на сайте `visualdg.co.il`. Он содержит класс `Graber`, который наследует функциональность сбора данных от родительского класса `Graber` (из `src.suppliers.graber`).

## Подробней

Этот модуль специализируется на обработке веб-страниц конкретного поставщика (`visualdg.co.il`). Для каждой страницы товара определены функции обработки полей. В случае, если требуется нестандартная обработка, функции перегружаются в этом классе.

Перед отправкой запроса к веб-драйверу можно выполнять предварительные действия через декоратор. Декоратор по умолчанию находится в родительском классе. Чтобы декоратор сработал, необходимо передать значение в `Context.locator`. Если требуется реализовать свой декоратор, нужно раскомментировать соответствующие строки кода и переопределить его поведение.

## Классы

### `Graber`

**Описание**: Класс `Graber` предназначен для сбора данных о товарах с сайта `visualdg.co.il`.

**Наследует**: `Grbr` из модуля `src.suppliers.graber`.

**Атрибуты**:
- `supplier_prefix` (str): Префикс поставщика, устанавливается как `'visualdg'`.

**Методы**:
- `__init__`: Инициализирует экземпляр класса `Graber`, устанавливает префикс поставщика и вызывает конструктор родительского класса.
- `close_pop_up`: Создает декоратор для закрытия всплывающих окон перед выполнением основной логики функции.

#### `__init__`

```python
def __init__(self, driver: Driver, lang_index):
    """Инициализация класса сбора полей товара."""
```

**Назначение**: Инициализирует экземпляр класса `Graber`, устанавливает префикс поставщика и вызывает конструктор родительского класса.

**Параметры**:
- `driver` (Driver): Экземпляр веб-драйвера, используемый для взаимодействия с веб-страницей.
- `lang_index` (int): Индекс языка, используемый для локализации контента.

**Как работает функция**:
1. Устанавливает атрибут `supplier_prefix` равным `'visualdg'`.
2. Вызывает конструктор родительского класса `Grbr` с переданными параметрами и `supplier_prefix`.
3. Устанавливает `Context.locator_for_decorator` в `None`. Если установить значение, то оно выполнится в декораторе `@close_pop_up`.

**Примеры**:

```python
# Пример создания экземпляра класса Graber
from src.webdriver.driver import Driver
from src.webdriver import Firefox

driver = Driver(Firefox)
graber = Graber(driver=driver, lang_index=0)
```

## Методы класса
### `close_pop_up`

```python
def close_pop_up(value: Any = None):
    """Создает декоратор для закрытия всплывающих окон перед выполнением основной логики функции."""
```

**Назначение**: Создает декоратор для закрытия всплывающих окон перед выполнением основной логики функции.

**Параметры**:
- `value` (Any, optional): Дополнительное значение для декоратора. По умолчанию `None`.

**Возвращает**:
- Callable: Декоратор, оборачивающий функцию.

#### Внутренние функции:
##### `decorator`
```python
def decorator(func: Callable) -> Callable:
        """Декоратор"""
```

**Назначение**:
Декоратор, который оборачивает функцию для выполнения дополнительных действий до и после ее выполнения.

**Параметры**:
- `func` (Callable): Функция, которую необходимо обернуть.

**Возвращает**:
- `Callable`: Обернутая функция.

##### `wrapper`
```python
async def wrapper(*args, **kwargs):
            """Обертка"""
```

**Назначение**:
Обертка для выполнения действий до и после вызова декорируемой функции.

**Параметры**:
- `*args`: Позиционные аргументы, передаваемые в функцию.
- `**kwargs`: Именованные аргументы, передаваемые в функцию.

**Возвращает**:
- `Any`: Результат выполнения обернутой функции.

**Как работает функция**:

1. Пытается выполнить локатор для закрытия всплывающего окна, используя `Context.driver.execute_locator(Context.locator.close_pop_up)`.
2. В случае ошибки выполнения локатора, логирует отладочное сообщение с информацией об ошибке.
3. Вызывает основную функцию `func` с переданными аргументами и возвращает ее результат.

**Примеры**:

```python
# Пример использования декоратора close_pop_up
from typing import Callable, Any

# Предположим, что Context.driver и Context.locator определены где-то в коде

# @close_pop_up()
# async def my_function():
#     print("Выполнение основной логики функции")

# my_function()
```
```python
from src.logger.logger import logger

#
#
#           DECORATOR TEMPLATE. 
#
# def close_pop_up(value: Any = None) -> Callable:
#     """Создает декоратор для закрытия всплывающих окон перед выполнением основной логики функции.
#
#     Args:
#         value (Any): Дополнительное значение для декоратора.
#
#     Returns:
#         Callable: Декоратор, оборачивающий функцию.
#     """
#     def decorator(func: Callable) -> Callable:
#         @wraps(func)
#         async def wrapper(*args, **kwargs):
#             try:
#                 # await Context.driver.execute_locator(Context.locator.close_pop_up)  # Await async pop-up close  
#                 ... 
#             except ExecuteLocatorException as ex:
#                 logger.debug(f'Ошибка выполнения локатора: {ex}')
#             return await func(*args, **kwargs)  # Await the main function
#         return wrapper
#     return decorator
```
```
## Параметры класса

- `driver` (Driver): Экземпляр веб-драйвера, используемый для взаимодействия с веб-страницей.
- `lang_index` (int): Индекс языка, используемый для локализации контента.

## Пример использования

```python
from src.suppliers.visualdg.graber import Graber
from src.webdriver.driver import Driver
from src.webdriver import Firefox

# Создание инстанса драйвера (пример с Chrome)
driver = Driver(Firefox)
# Создание экземпляра класса Graber
graber = Graber(driver=driver, lang_index=0)