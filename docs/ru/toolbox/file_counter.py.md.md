# Модуль для подсчета строк, классов и функций в файлах

## Обзор

Модуль `file_counter.py` предназначен для анализа файлов в проекте `hypotez` и подсчета количества строк кода, классов и функций в них. Он рекурсивно обходит указанную директорию и ее поддиректории, анализируя текстовые файлы и исключая бинарные файлы, файлы `__init__.py` и Jupyter Notebook.

## Подробнее

Этот скрипт является частью утилит для разработчиков и используется для оценки размера, сложности и структуры кодовой базы проекта `hypotez`. Результаты анализа могут быть использованы для принятия решений о рефакторинге, улучшении качества кода и планировании разработки.

## Классы

В данном модуле классы отсутствуют.

## Функции

### `count_lines_in_files`

```python
def count_lines_in_files(directory: str) -> tuple[int, int, int]:
    """
    Рекурсивно подсчитывает количество строк, классов и функций во всех текстовых файлах в указанной директории и её поддиректориях.

    Args:
        directory (str): Путь к директории, в которой необходимо подсчитать строки, классы и функции.

    Returns:
        tuple[int, int, int]: Кортеж, содержащий общее количество строк (`total_lines`), классов (`total_classes`) и функций (`total_functions`).
    """
```

**Назначение**:
Функция `count_lines_in_files` рекурсивно обходит указанную директорию и все её поддиректории, подсчитывая количество строк, классов и функций в каждом текстовом файле. Бинарные файлы, файлы `__init__.py` и файлы Jupyter Notebook (`.ipynb`) исключаются из анализа.

**Параметры**:
- `directory` (str): Путь к директории, которую необходимо проанализировать.

**Возвращает**:
- `tuple[int, int, int]`: Кортеж, содержащий общее количество строк, классов и функций, найденных во всех проанализированных файлах.

**Как работает функция**:
1. Инициализирует счетчики `total_lines`, `total_classes` и `total_functions` для хранения общего количества строк, классов и функций.
2. Получает список файлов и поддиректорий в указанной директории с помощью `os.listdir()`.
3. Перебирает каждый элемент в списке.
4. Для каждого элемента проверяет, является ли он файлом с помощью `os.path.isfile()`.
5. Если элемент является файлом, проверяет, не является ли он бинарным файлом, файлом `__init__.py` или файлом Jupyter Notebook.
6. Если файл является текстовым (не бинарным, не `__init__.py` и не Jupyter Notebook), открывает его для чтения с кодировкой UTF-8 и игнорирует ошибки кодировки.
7. Вызывает функцию `count_lines_classes_functions()` для подсчета количества строк, классов и функций в файле.
8. Увеличивает общие счетчики `total_lines`, `total_classes` и `total_functions` на значения, возвращенные функцией `count_lines_classes_functions()`.
9. Если элемент является директорией, проверяет, не является ли она директорией `__pycache__` или скрытой директорией (начинается с точки).
10. Если директория не является `__pycache__` или скрытой, рекурсивно вызывает функцию `count_lines_in_files()` для этой поддиректории.
11. Увеличивает общие счетчики на значения, возвращенные рекурсивным вызовом.
12. После обработки всех элементов в директории, возвращает кортеж со значениями `total_lines`, `total_classes` и `total_functions`.

**Примеры**:

```python
total_lines, total_classes, total_functions = count_lines_in_files('/path/to/your/directory')
print(f"Total lines: {total_lines}, Total classes: {total_classes}, Total functions: {total_functions}")
```

### `is_binary`

```python
def is_binary(filepath: str) -> bool:
    """
    Определяет, является ли файл бинарным, проверяя наличие нулевых байтов в первых 512 байтах файла.

    Args:
        filepath (str): Путь к файлу, который необходимо проверить на бинарность.

    Returns:
        bool: True, если файл является бинарным, и False в противном случае.
    """
```

**Назначение**:
Функция `is_binary` проверяет, является ли файл бинарным, путем чтения первых 512 байт файла и поиска нулевых байтов.

**Параметры**:
- `filepath` (str): Путь к файлу, который необходимо проверить.

**Возвращает**:
- `bool`: `True`, если файл является бинарным, и `False` в противном случае.

**Как работает функция**:
1. Открывает файл в бинарном режиме (`'rb'`).
2. Читает первые 512 байт файла.
3. Проверяет, содержит ли прочитанный блок нулевые байты (`\0`).
4. Если нулевые байты найдены, возвращает `True`, иначе возвращает `False`.
5. Если во время чтения файла возникает исключение, считает файл бинарным и возвращает `True`.

**Примеры**:

```python
if is_binary('/path/to/your/file.txt'):
    print("The file is binary.")
else:
    print("The file is not binary.")
```

### `count_lines_classes_functions`

```python
def count_lines_classes_functions(file) -> tuple[int, int, int]:
    """
    Подсчитывает количество строк, классов и функций в открытом файле.

    Args:
        file (file object): Объект файла, открытого для чтения.

    Returns:
        tuple[int, int, int]: Кортеж, содержащий количество строк (`lines`), классов (`classes_count`) и функций (`functions_count`) в файле.
    """
```

**Назначение**:
Функция `count_lines_classes_functions` подсчитывает количество строк, классов и функций в открытом файле.

**Параметры**:
- `file` (file object): Объект файла, открытого для чтения.

**Возвращает**:
- `tuple[int, int, int]`: Кортеж, содержащий количество строк, классов и функций в файле.

**Как работает функция**:
1. Инициализирует счетчики `lines`, `classes_count` и `functions_count` для хранения количества строк, классов и функций.
2. Перебирает каждую строку в файле.
3. Увеличивает счетчик `lines` на 1 для каждой строки.
4. Проверяет, начинается ли строка с ключевого слова `class `. Если да, увеличивает счетчик `classes_count` на 1.
5. Проверяет, начинается ли строка с ключевого слова `def `. Если да, увеличивает счетчик `functions_count` на 1.
6. После обработки всех строк в файле, возвращает кортеж со значениями `lines`, `classes_count` и `functions_count`.

**Примеры**:

```python
with open('/path/to/your/file.txt', 'r') as f:
    lines, classes, functions = count_lines_classes_functions(f)
    print(f"Lines: {lines}, Classes: {classes}, Functions: {functions}")
```

## Переменные

- `MODE`: Константа, определяющая режим работы скрипта (в данном случае `'development'`).
- `dir_root`: Определяется как корневая директория проекта (`hypotez`).
- `dir_src`: Определяется как поддиректория `src` внутри корневой директории проекта.

## Потенциальные ошибки и области для улучшения

1. **Обработка исключений**: В функции `is_binary` при возникновении исключения при чтении файла, файл считается бинарным. Это может быть не всегда корректно. Возможно, стоит добавить более детальную обработку исключений.
2. **Улучшение определения бинарных файлов**: Проверка на бинарность только по первым 512 байтам может быть недостаточной. Можно рассмотреть использование более надежных методов определения бинарных файлов.
3. **Кодировка файлов**: Кодировка `'utf-8'` и обработка ошибок `'ignore'` могут приводить к потере данных при чтении файлов с некорректной кодировкой. Можно добавить возможность указания кодировки в качестве параметра.
4. **Комментарии и документация**: Документация модуля и функций неполная. Следует добавить более подробное описание каждой функции, её аргументов и возвращаемых значений.
5. **Анализ кода**: В функции `count_lines_classes_functions` код анализирует только строки, начинающиеся с `class` и `def`. Это может привести к неверному подсчету классов и функций, если они определены в нестандартном стиле.

## Взаимосвязи с другими частями проекта

- Этот скрипт может использоваться для анализа кодовой базы проекта `hypotez`, чтобы оценить её размер, сложность и структуру. Результаты могут быть использованы для принятия решений о рефакторинге, улучшении качества кода и планировании разработки.
- Переменные `dir_root` и `dir_src` явно указывают на то, что скрипт предназначен для работы с проектом `hypotez` и предполагает определенную структуру директорий.