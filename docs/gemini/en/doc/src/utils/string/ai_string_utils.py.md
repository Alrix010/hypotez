# Утилиты для работы со строками в AI

## Обзор

Этот модуль предоставляет функции для обработки и очистки строк, включая:

1.  **Подготовка текстовых данных для обучающих наборов**: экранирование кавычек, удаление лишних пробелов, удаление/замена символов новой строки, табуляции и т.п.
2.  **Нормализация ответов от языковых моделей**: удаление обрамляющих блоков кода.

## Содержание

### Функции

*   [`string_for_train`](#string_for_train)
*   [`normalize_answer`](#normalize_answer)

## Функции

### `string_for_train`

```python
def string_for_train(data: Union[str, List[str]]) -> str:
    """
    Очищает и форматирует данные для обучения.

    Экранирует двойные кавычки (`"`) символом обратной косой черты (`\\`).
    Заменяет все последовательности пробельных символов (включая пробелы,
    табуляцию `\\t`, переводы строки `\\n`, `\\r`, `\\f`, `\\v`) одним пробелом.
    Удаляет начальные и конечные пробелы.

    Args:
        data (Union[str, List[str]]): Входные данные. Могут быть строкой или
                                      списком строк.

    Returns:
        str: Очищенная и объединенная строка (если на входе был список),
             готовая для использования в обучении. Возвращает пустую строку,
             если тип входных данных не строка и не список строк.

    Examples:
        >>> string_for_train('   Это  строка   с "кавычками"\\nи\\tпробелами. ')
        'Это строка с \\"кавычками\\" и пробелами.'
        >>> string_for_train(['Первая строка.', '   Вторая "строка"\\tс\\nпробелами.'])
        'Первая строка. Вторая \\"строка\\" с пробелами.'
        >>> string_for_train('Строка\\nс\\nпереносами\\n')
        'Строка с переносами'
        >>> string_for_train(None)
        ''
        >>> string_for_train(123)
        ''
    """
    cleaned_text: str = ""

    if isinstance(data, str):
        # Экранирование кавычек
        cleaned_text = data.replace('"', '\\"')
        # Замена всех последовательностей пробельных символов (\\s включает \\n, \\t, \\r, \\f, \\v и пробел)
        # одним пробелом и обрезка краев
        cleaned_text = re.sub(r'\s+', ' ', cleaned_text).strip()
        return cleaned_text
    elif isinstance(data, list):
        # Обработка каждого элемента списка
        processed_items = []
        for item in data:
            if isinstance(item, str):
                # Экранирование кавычек
                cleaned_item = item.replace('"', '\\"')
                # НЕ удаляем \\n, \\t и т.д. здесь отдельно,
                # т.к. финальный re.sub обработает всю строку целиком
                processed_items.append(cleaned_item)
            else:
                # Пропустить нестроковые элементы или обработать иначе?
                # В текущей реализации они будут проигнорированы при объединении,
                # но можно добавить логирование или обработку ошибок.
                pass # Явно указываем, что ничего не делаем
        # Объединение элементов списка в одну строку через пробел
        # Пробел между элементами важен, чтобы re.sub корректно их разделил
        full_text = ' '.join(processed_items)
        # Финальное удаление повторяющихся и нежелательных пробельных символов (\\n, \\t и др.),
        # замена их одним пробелом и обрезка краев всей строки
        cleaned_text = re.sub(r'\s+', ' ', full_text).strip()
        return cleaned_text
    else:
        # Возврат пустой строки для некорректного типа данных
        return ""
```

**Описание:**

Функция `string_for_train` очищает и форматирует данные для обучения, подготавливая их к использованию в обучающих наборах.

**Основные действия:**

1.  **Экранирование кавычек**: заменяет все двойные кавычки (`"`) символом обратной косой черты (`\\`).
2.  **Удаление лишних пробелов**: заменяет все последовательности пробельных символов (включая пробелы, табуляцию `\\t`, переводы строки `\\n`, `\\r`, `\\f`, `\\v`) одним пробелом.
3.  **Обрезка краев**: удаляет начальные и конечные пробелы в строке.

**Примеры использования:**

```python
>>> string_for_train('   Это  строка   с "кавычками"   и    пробелами. ')
'Это строка с \\"кавычками\\" и пробелами.'
>>> string_for_train(['Первая строка.', '   Вторая "строка"   с пробелами.'])
'Первая строка. Вторая \\"строка\\" с пробелами.'
>>> string_for_train('Строка\\nс\\nпереносами\\n')
'Строка с переносами'
>>> string_for_train(None)
''
>>> string_for_train(123)
''
```

### `normalize_answer`

```python
def normalize_answer(text: str) -> str:
    """
    Нормализует текстовый ответ, удаляя обрамляющие блоки кода markdown.

    Проверяет, начинается ли строка `text` одним из префиксов из списка
    `_NORMALIZER_PREFIXES` (например, '```html\\n', '```markdown', '```')
    и заканчивается ли она суффиксом `_NORMALIZER_SUFFIX` ('```').
    Если оба условия выполняются, удаляет соответствующий префикс и суффикс.
    В противном случае возвращает исходную строку без изменений.

    Args:
        text (str): Исходная строка текста, потенциально содержащая
                    обрамляющие блоки кода.

    Returns:
        str: Нормализованная строка без начального и конечного блоков кода,
             либо исходная строка, если блоки не найдены.

    Examples:
        >>> normalize_answer("```html\\n<p>Пример</p>\\n```")
        '<p>Пример</p>\\n'
        >>> normalize_answer("```markdown\\n# Заголовок\\nТекст.\\n```")
        '# Заголовок\\nТекст.\\n'
        >>> normalize_answer("```\\nПросто текст\\n```")
        'Просто текст\\n'
        >>> normalize_answer("Обычный текст без блоков.")
        'Обычный текст без блоков.'
        >>> normalize_answer("```Неполный блок")
        '```Неполный блок'
        >>> normalize_answer("Блок в конце```")
        'Блок в конце```'
        >>> normalize_answer("```md Текст```") # Пример с пробелом после md
        'Текст'
    """
    if not isinstance(text, str):
        # Можно добавить обработку ошибок или вернуть пустую строку/None
        return "" # Или return text, если нужно пропустить не-строки

    normalized_text = text # Начинаем с исходного текста

    for prefix in _NORMALIZER_PREFIXES:
        # Проверяем наличие префикса И суффикса
        if normalized_text.startswith(prefix) and normalized_text.endswith(_NORMALIZER_SUFFIX):
            # Удаляем префикс
            normalized_text = normalized_text.removeprefix(prefix)
            # Удаляем суффикс
            normalized_text = normalized_text.removesuffix(_NORMALIZER_SUFFIX)
            # Так как нашли и удалили, можно выходить из цикла
            break # Важно: прекращаем поиск после первого совпадения

    # Можно добавить .strip() для удаления случайных пробелов по краям после удаления блоков
    # return normalized_text.strip()
    # Однако, это может быть нежелательно, если внутри блока важны отступы
    return normalized_text
```

**Описание:**

Функция `normalize_answer` нормализует текстовый ответ, удаляя обрамляющие блоки кода Markdown.

**Основные действия:**

1.  Проверяет, начинается ли строка `text` одним из префиксов из списка `_NORMALIZER_PREFIXES` (например, '```html\\n', '```markdown', '```') и заканчивается ли она суффиксом `_NORMALIZER_SUFFIX` ('```').
2.  Если оба условия выполняются, удаляет соответствующий префикс и суффикс.
3.  В противном случае возвращает исходную строку без изменений.

**Примеры использования:**

```python
>>> normalize_answer("```html\\n<p>Пример</p>\\n```")
'<p>Пример</p>\\n'
>>> normalize_answer("```markdown\\n# Заголовок\\nТекст.\\n```")
'# Заголовок\\nТекст.\\n'
>>> normalize_answer("```\\nПросто текст\\n```")
'Просто текст\\n'
>>> normalize_answer("Обычный текст без блоков.")
'Обычный текст без блоков.'
>>> normalize_answer("```Неполный блок")
'```Неполный блок'
>>> normalize_answer("Блок в конце```")
'Блок в конце```'
>>> normalize_answer("```md Текст```") # Пример с пробелом после md
'Текст'