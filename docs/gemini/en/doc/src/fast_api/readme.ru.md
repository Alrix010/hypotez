# Документация для модуля `fast_api`

## Обзор

В этом файле представлена документация для компонентов, обеспечивающих взаимодействие между клиентской и серверной частями FastAPI-приложения через XML-RPC. Описаны основные классы и их взаимодействие для удаленного управления сервером FastAPI.

## Более детально

Этот код реализует систему управления FastAPI серверами через XML-RPC. `fast_api_rpc.py` предоставляет серверную часть, которая запускает FastAPI сервер и предоставляет интерфейс для удаленного управления им. `main.py` представляет клиентскую часть, которая позволяет пользователю взаимодействовать с сервером через консоль и отправлять команды управления.

## Основные компоненты

### `fast_api_rpc.py` (серверная часть)

#### `FastApiServer`
Этот класс содержит логику для запуска FastAPI-сервера. Он отвечает за создание и настройку веб-сервера, а также за добавление новых маршрутов.

#### `CommandHandler`

**Описание**: Класс, управляющий вызовами функций управления сервером.

**Атрибуты**:
- `rpc_server`: Объект `SimpleXMLRPCServer`, который слушает запросы на порту `9000` (по умолчанию).

**Методы**:
- `__init__(self)`: Конструктор класса. Создает объект `SimpleXMLRPCServer`, который слушает запросы на порту `9000` (по умолчанию).
- `register_instance(self)`: Делает все методы этого класса доступными для удаленного вызова.
- `start_server(self, port: int = 8000, host: str = "0.0.0.0") -> None`: Запускает FastAPI сервер на указанном порту и хосте.
- `stop_server(self, port: int = 8000) -> None`: Останавливает FastAPI сервер на указанном порту.
- `stop_all_servers(self) -> None`: Останавливает все запущенные FastAPI серверы.
- `status_servers(self) -> list`: Возвращает список статусов всех запущенных FastAPI серверов.
- `add_new_route(self, port: int = 8000, path: str = "/", method: str = "GET") -> None`: Добавляет новый маршрут к FastAPI серверу на указанном порту.
- `shutdown(self) -> None`: Останавливает XML-RPC сервер.

### `main.py` (клиентская часть)

**Описание**: Клиентская часть для управления FastAPI сервером.

**Атрибуты**:
- `rpc_client`: Объект `ServerProxy`, используемый для вызова методов XML-RPC сервера.

**Логика работы**:
1. Отображает меню доступных команд.
2. Запрашивает ввод пользователя.
3. Парсит введенную строку, выделяя команду и её аргументы.
4. В зависимости от введенной команды вызывает соответствующий метод RPC-сервера через объект `rpc_client`.

## Функции

### `start_server`

```python
def start_server(port: int = 8000, host: str = "0.0.0.0") -> None:
    """
    Функция запуска FastAPI сервера.

    Args:
        port (int, optional): Порт для запуска сервера. По умолчанию 8000.
        host (str, optional): Хост для запуска сервера. По умолчанию "0.0.0.0".

    Returns:
        None: Функция ничего не возвращает.

    Raises:
        Exception: Если возникает ошибка при запуске сервера.

    Как работает функция:
    - Функция запускает FastAPI сервер на указанном порту и хосте.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

### `stop_server`

```python
def stop_server(port: int = 8000) -> None:
    """
    Функция остановки FastAPI сервера.

    Args:
        port (int, optional): Порт сервера для остановки. По умолчанию 8000.

    Returns:
        None: Функция ничего не возвращает.

    Raises:
        Exception: Если возникает ошибка при остановке сервера.

    Как работает функция:
    - Функция останавливает FastAPI сервер на указанном порту.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

### `stop_all_servers`

```python
def stop_all_servers() -> None:
    """
    Функция остановки всех FastAPI серверов.

    Returns:
        None: Функция ничего не возвращает.

    Raises:
        Exception: Если возникает ошибка при остановке серверов.

    Как работает функция:
    - Функция останавливает все запущенные FastAPI серверы.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

### `status_servers`

```python
def status_servers() -> list:
    """
    Функция получения статуса всех FastAPI серверов.

    Returns:
        list: Список статусов всех запущенных FastAPI серверов.

    Raises:
        Exception: Если возникает ошибка при получении статуса серверов.

    Как работает функция:
    - Функция возвращает список статусов всех запущенных FastAPI серверов.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

### `add_new_route`

```python
def add_new_route(port: int = 8000, path: str = "/", method: str = "GET") -> None:
    """
    Функция добавления нового маршрута к FastAPI серверу.

    Args:
        port (int, optional): Порт сервера для добавления маршрута. По умолчанию 8000.
        path (str, optional): Путь для нового маршрута. По умолчанию "/".
        method (str, optional): HTTP метод для нового маршрута. По умолчанию "GET".

    Returns:
        None: Функция ничего не возвращает.

    Raises:
        Exception: Если возникает ошибка при добавлении маршрута.

    Как работает функция:
    - Функция добавляет новый маршрут к FastAPI серверу на указанном порту.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

### `shutdown`

```python
def shutdown() -> None:
    """
    Функция остановки XML-RPC сервера.

    Returns:
        None: Функция ничего не возвращает.

    Raises:
        Exception: Если возникает ошибка при остановке сервера.

    Как работает функция:
    - Функция останавливает XML-RPC сервер.
    - В случае ошибки выводит сообщение об ошибке в консоль.
    """
    ...
```

## Взаимодействие между компонентами

1.  **Запуск `fast_api_rpc.py`**: При запуске `fast_api_rpc.py` происходит следующее:
    *   Создается экземпляр `CommandHandler`.
    *   В конструкторе `CommandHandler` создается XML-RPC сервер, который начинает слушать порт `9000`.
    *   Запускается FastAPI-сервер(ы) в соответствии с кодом, который мы создали.
2.  **Запуск `main.py`**: При запуске `main.py` происходит следующее:
    *   Создается экземпляр `CommandHandler` (но он не играет роли, поскольку в `main.py` используется только RPC-клиент).
    *   Создается `ServerProxy`, который подключается к XML-RPC серверу по адресу `http://localhost:9000`.
    *   `main.py` начинает показывать меню и ожидать ввода пользователя.
3.  **Ввод команды**: Когда пользователь вводит команду в `main.py`, например `start 8000`:
    *   `main.py` анализирует эту строку, выделяет команду `start` и порт `8000`.
    *   `main.py` вызывает метод `start_server(port=8000, host="0.0.0.0")` у объекта `rpc_client`. Это *не* вызов метода на локальном объекте, а запрос к XML-RPC серверу.
4.  **Обработка запроса на сервере**: XML-RPC клиент `rpc_client` создает XML-сообщение, которое отправляет на сервер `fast_api_rpc.py`.
    *   XML-RPC сервер в `fast_api_rpc.py` получает этот запрос.
    *   Он понимает, что нужно вызвать метод `start_server` у объекта `CommandHandler`.
    *   Вызывается метод `start_server`, который вызывает функцию `start_server` и запускает FastAPI сервер.
5.  **Возврат ответа**: XML-RPC сервер формирует ответ, содержащий результат вызова (в данном случае, это может быть `None`).
    *   Этот ответ отправляется обратно клиенту `main.py`.
    *   Клиент получает ответ.
6.  **Отображение результата**: `main.py` может отобразить результат в консоль (или проигнорировать его, если это None).
7.  **Повторение цикла**: `main.py` возвращается к началу цикла, отображая меню и ожидая ввода следующей команды.

## Ключевые моменты

*   **Разделение ответственности**: `fast_api_rpc.py` отвечает за управление сервером и предоставление интерфейса для управления, `main.py` отвечает за взаимодействие с пользователем и отправку команд.
*   **XML-RPC**: `xmlrpc` используется для организации связи между двумя процессами, что позволяет вызывать методы сервера из клиентской программы.
*   **Потоки**: XML-RPC сервер запущен в отдельном потоке, поэтому он может работать параллельно с остальным кодом.
*   **Удаленный вызов**: `ServerProxy` позволяет вызывать методы, как если бы они были частью локального кода, хотя на самом деле они выполняются на удаленном сервере.

## Преимущества данного подхода

*   **Управление сервером из другой программы**: Мы можем контролировать запущенный сервер через другой процесс или даже с другой машины.
*   **Разделение кода**: Логика управления сервером и пользовательский интерфейс разделены, что делает код более модульным и легким в обслуживании.
*   **Гибкость**: Мы можем добавить новые методы управления сервером, просто добавив их в `CommandHandler`, и они автоматически станут доступны через RPC.