# Модуль helper

## Обзор

Модуль `helper` содержит набор вспомогательных функций, используемых для форматирования и обработки текстовых сообщений, генерации случайных строк и выполнения других операций, связанных с обработкой данных в проекте `hypotez`. Он предоставляет инструменты для подготовки запросов к моделям машинного обучения и обработки ответов от них.

## Подробнее

Этот модуль предоставляет набор полезных функций для подготовки и обработки текстовых данных, используемых в различных частях проекта `hypotez`. Он включает в себя функции для форматирования текстовых сообщений, получения системных подсказок, обработки изображений и генерации случайных строк. Эти функции помогают стандартизировать и упростить работу с текстовыми данными в проекте.

## Функции

### `to_string`

```python
def to_string(value) -> str:
    """Преобразует значение в строку.

    Args:
        value: Значение для преобразования.

    Returns:
        str: Строковое представление значения.
    """
```

**Назначение**: Преобразует различные типы данных в строковый формат.

**Параметры**:
- `value`: Значение, которое нужно преобразовать в строку. Может быть строкой, словарем или списком.

**Возвращает**:
- `str`: Строковое представление значения. Если значение является словарем, содержащим ключ "name", возвращает пустую строку. Если значение является словарем, содержащим ключ "bucket_id", считывает содержимое bucket и возвращает его. Если значение имеет тип "text", возвращает его текстовое содержимое. Если значение является списком, объединяет строковые представления элементов списка. В противном случае возвращает строковое представление значения.

**Как работает**:
- Функция проверяет тип входного значения. Если это строка, она возвращает её без изменений. Если это словарь, функция проверяет наличие определенных ключей ("name", "bucket_id", "type") и возвращает соответствующие значения. Если это список, функция рекурсивно преобразует каждый элемент списка в строку и объединяет их. В противном случае функция преобразует значение в строку с помощью `str(value)`.

### `format_prompt`

```python
def format_prompt(messages: Messages, add_special_tokens: bool = False, do_continue: bool = False, include_system: bool = True) -> str:
    """Форматирует список сообщений в строку.

    Args:
        messages (Messages): Список сообщений, каждое из которых содержит 'role' и 'content'.
        add_special_tokens (bool): Флаг, указывающий, добавлять ли специальные токены форматирования.
        do_continue (bool): Флаг, указывающий, нужно ли продолжать форматирование.
        include_system (bool): Флаг, указывающий, включать ли системные сообщения.

    Returns:
        str: Отформатированная строка, содержащая все сообщения.
    """
```

**Назначение**: Форматирует список сообщений в единую строку, опционально добавляя специальные токены.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь содержит ключи 'role' (роль) и 'content' (содержимое) сообщения.
- `add_special_tokens` (bool): Определяет, добавлять ли специальные токены форматирования. По умолчанию `False`.
- `do_continue` (bool): Если `True`, форматирование выполняется для продолжения предыдущего сообщения. По умолчанию `False`.
- `include_system` (bool): Если `True`, в форматирование включаются системные сообщения. По умолчанию `True`.

**Возвращает**:
- `str`: Отформатированная строка, содержащая все сообщения.

**Как работает**:
- Функция преобразует список сообщений в строку, форматируя каждое сообщение в виде "Role: Content". Если `add_special_tokens` имеет значение `False` и количество сообщений меньше или равно 1, функция возвращает содержимое первого сообщения. Если `do_continue` имеет значение `True`, функция возвращает отформатированную строку без добавления "Assistant:".

**Примеры**:

```python
messages = [{"role": "user", "content": "Привет"}, {"role": "assistant", "content": "Здравствуйте"}]
formatted_prompt = format_prompt(messages, add_special_tokens=True)
print(formatted_prompt)  # Вывод: User: Привет\nAssistant: Здравствуйте\nAssistant:
```

### `get_system_prompt`

```python
def get_system_prompt(messages: Messages) -> str:
    """Извлекает системные сообщения из списка сообщений.

    Args:
        messages (Messages): Список сообщений, каждое из которых содержит 'role' и 'content'.

    Returns:
        str: Объединенная строка, содержащая все системные сообщения.
    """
```

**Назначение**: Извлекает все системные сообщения из списка сообщений и объединяет их в одну строку.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь содержит ключи 'role' (роль) и 'content' (содержимое) сообщения.

**Возвращает**:
- `str`: Строка, содержащая объединенные системные сообщения.

**Как работает**:
- Функция проходит по списку сообщений и извлекает все сообщения, у которых роль равна "system". Затем она объединяет содержимое этих сообщений в одну строку, разделяя их символом новой строки.

**Примеры**:

```python
messages = [{"role": "system", "content": "Ты - полезный ассистент"}, {"role": "user", "content": "Привет"}]
system_prompt = get_system_prompt(messages)
print(system_prompt)  # Вывод: Ты - полезный ассистент
```

### `get_last_user_message`

```python
def get_last_user_message(messages: Messages) -> str:
    """Получает последнее сообщение от пользователя из списка сообщений.

    Args:
        messages (Messages): Список сообщений, каждое из которых содержит 'role' и 'content'.

    Returns:
        str: Последнее сообщение от пользователя.
    """
```

**Назначение**: Извлекает последнее сообщение от пользователя из списка сообщений.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь содержит ключи 'role' (роль) и 'content' (содержимое) сообщения.

**Возвращает**:
- `str`: Последнее сообщение от пользователя. Если сообщений от пользователя нет, возвращает пустую строку.

**Как работает**:
- Функция проходит по списку сообщений в обратном порядке и ищет последнее сообщение, у которого роль равна "user". Если такое сообщение найдено, функция возвращает его содержимое. Если сообщений от пользователя нет, функция возвращает пустую строку.

**Примеры**:

```python
messages = [{"role": "user", "content": "Привет"}, {"role": "assistant", "content": "Здравствуйте"}, {"role": "user", "content": "Как дела?"}]
last_user_message = get_last_user_message(messages)
print(last_user_message)  # Вывод: Как дела?
```

### `format_image_prompt`

```python
def format_image_prompt(messages, prompt: str = None) -> str:
    """Форматирует подсказку для генерации изображений.

    Args:
        messages: Список сообщений.
        prompt (str, optional): Подсказка для генерации изображения.

    Returns:
        str: Отформатированная подсказка для генерации изображения.
    """
```

**Назначение**: Форматирует подсказку для генерации изображений. Если подсказка не предоставлена, используется последнее сообщение от пользователя.

**Параметры**:
- `messages`: Список сообщений.
- `prompt` (str, optional): Подсказка для генерации изображения. По умолчанию `None`.

**Возвращает**:
- `str`: Отформатированная подсказка для генерации изображения.

**Как работает**:
- Если параметр `prompt` не указан, функция вызывает `get_last_user_message` для получения последнего сообщения от пользователя. В противном случае функция возвращает предоставленную подсказку.

**Примеры**:

```python
messages = [{"role": "user", "content": "Нарисуй кота"}]
image_prompt = format_image_prompt(messages)
print(image_prompt)  # Вывод: Нарисуй кота

image_prompt = format_image_prompt(messages, prompt="Кот в шляпе")
print(image_prompt)  # Вывод: Кот в шляпе
```

### `format_prompt_max_length`

```python
def format_prompt_max_length(messages: Messages, max_lenght: int) -> str:
    """Форматирует подсказку, обрезая её до максимальной длины.

    Args:
        messages (Messages): Список сообщений.
        max_lenght (int): Максимальная длина подсказки.

    Returns:
        str: Отформатированная и обрезанная подсказка.
    """
```

**Назначение**: Форматирует подсказку и обрезает ее до максимальной длины, если она превышает заданную.

**Параметры**:
- `messages` (Messages): Список словарей, где каждый словарь содержит ключи 'role' (роль) и 'content' (содержимое) сообщения.
- `max_lenght` (int): Максимальная длина подсказки.

**Возвращает**:
- `str`: Отформатированная и, возможно, обрезанная подсказка.

**Как работает**:
- Функция сначала форматирует подсказку с помощью `format_prompt`. Если длина полученной подсказки превышает `max_lenght`, функция пытается обрезать ее, оставляя только последние сообщения от пользователя и системные сообщения. Если и это не помогает, функция возвращает только последнее сообщение от пользователя.

**Примеры**:

```python
messages = [{"role": "user", "content": "Очень длинный запрос..."}]
max_length = 100
formatted_prompt = format_prompt_max_length(messages, max_length)
print(formatted_prompt)
```

### `get_random_string`

```python
def get_random_string(length: int = 10) -> str:
    """Генерирует случайную строку.

    Args:
        length (int, optional): Длина случайной строки.

    Returns:
        str: Случайная строка.
    """
```

**Назначение**: Генерирует случайную строку указанной длины, состоящую из строчных букв и цифр.

**Параметры**:
- `length` (int, optional): Длина генерируемой строки. По умолчанию 10.

**Возвращает**:
- `str`: Случайная строка указанной длины.

**Как работает**:
- Функция использует модуль `random` для выбора случайных символов из набора строчных букв и цифр. Затем она объединяет выбранные символы в строку указанной длины.

**Примеры**:

```python
random_string = get_random_string(length=20)
print(random_string)  # Вывод: случайная строка длиной 20 символов
```

### `get_random_hex`

```python
def get_random_hex(length: int = 32) -> str:
    """Генерирует случайную шестнадцатеричную строку.

    Args:
        length (int, optional): Длина шестнадцатеричной строки.

    Returns:
        str: Случайная шестнадцатеричная строка.
    """
```

**Назначение**: Генерирует случайную шестнадцатеричную строку указанной длины.

**Параметры**:
- `length` (int, optional): Длина генерируемой строки. По умолчанию 32.

**Возвращает**:
- `str`: Случайная шестнадцатеричная строка указанной длины.

**Как работает**:
- Функция использует модуль `random` для выбора случайных символов из шестнадцатеричного набора (a-f и цифры). Затем она объединяет выбранные символы в строку указанной длины.

**Примеры**:

```python
random_hex = get_random_hex(length=40)
print(random_hex)  # Вывод: случайная шестнадцатеричная строка длиной 40 символов
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """Фильтрует словарь, удаляя элементы со значением None.

    Args:
        **kwargs: Произвольные ключевые аргументы.

    Returns:
        dict: Отфильтрованный словарь.
    """
```

**Назначение**: Фильтрует словарь, удаляя элементы, значения которых равны `None`.

**Параметры**:
- `**kwargs`: Произвольные ключевые аргументы, представляющие словарь.

**Возвращает**:
- `dict`: Новый словарь, содержащий только элементы, значения которых не равны `None`.

**Как работает**:
- Функция создает новый словарь, включая в него только те элементы из входного словаря, значения которых не равны `None`.

**Примеры**:

```python
filtered_dict = filter_none(a=1, b=None, c=3)
print(filtered_dict)  # Вывод: {'a': 1, 'c': 3}
```

### `async_concat_chunks`

```python
async def async_concat_chunks(chunks: AsyncIterator) -> str:
    """Асинхронно объединяет асинхронные чанки в строку.

    Args:
        chunks (AsyncIterator): Асинхронный итератор чанков.

    Returns:
        str: Объединенная строка.
    """
```

**Назначение**: Асинхронно объединяет чанки из асинхронного итератора в одну строку.

**Параметры**:
- `chunks` (AsyncIterator): Асинхронный итератор, предоставляющий чанки данных.

**Возвращает**:
- `str`: Строка, полученная путем объединения всех чанков из итератора.

**Как работает**:
- Функция асинхронно перебирает чанки, предоставляемые асинхронным итератором, и объединяет их в одну строку.

**Примеры**:

```python
async def generate_chunks():
    yield "Hello"
    yield " "
    yield "World"

chunks = generate_chunks()
result = await async_concat_chunks(chunks)
print(result)  # Вывод: Hello World
```

### `concat_chunks`

```python
def concat_chunks(chunks: Iterator) -> str:
    """Объединяет чанки в строку.

    Args:
        chunks (Iterator): Итератор чанков.

    Returns:
        str: Объединенная строка.
    """
```

**Назначение**: Объединяет чанки из итератора в одну строку.

**Параметры**:
- `chunks` (Iterator): Итератор, предоставляющий чанки данных.

**Возвращает**:
- `str`: Строка, полученная путем объединения всех чанков из итератора.

**Как работает**:
- Функция перебирает чанки, предоставляемые итератором, и объединяет их в одну строку.

**Примеры**:

```python
chunks = ["Hello", " ", "World"]
result = concat_chunks(chunks)
print(result)  # Вывод: Hello World
```

### `format_cookies`

```python
def format_cookies(cookies: Cookies) -> str:
    """Форматирует куки в строку.

    Args:
        cookies (Cookies): Словарь с куками.

    Returns:
        str: Отформатированная строка с куками.
    """
```

**Назначение**: Форматирует словарь куки в строку, пригодную для использования в HTTP-запросах.

**Параметры**:
- `cookies` (Cookies): Словарь, где ключи - имена куки, а значения - их значения.

**Возвращает**:
- `str`: Строка, содержащая отформатированные куки в виде "name=value; name=value; ...".

**Как работает**:
- Функция перебирает элементы словаря `cookies` и форматирует каждую пару ключ-значение в виде "name=value". Затем она объединяет все отформатированные пары в одну строку, разделяя их символом "; ".

**Примеры**:

```python
cookies = {"name": "John", "age": "30"}
formatted_cookies = format_cookies(cookies)
print(formatted_cookies)  # Вывод: name=John; age=30