# Модуль `helper.py`

## Обзор

Модуль `helper.py` содержит вспомогательные функции для обработки текста, включая фильтрацию блоков кода и JSON из строк, поиск стоп-слов, фильтрацию `None` значений из словарей и безопасное закрытие асинхронных генераторов.

## Более подробно

Этот модуль предоставляет набор утилит, которые помогают в обработке текстовых данных, особенно при работе с кодом и JSON. Он используется для извлечения полезной информации из текста и для обеспечения безопасной работы с асинхронными генераторами.

## Функции

### `filter_markdown`

```python
def filter_markdown(text: str, allowd_types=None, default=None) -> str:
    """
    Извлекает блок кода из строки.

    Args:
        text (str): Строка, содержащая блок кода.
        allowd_types (list, optional): Список допустимых типов блоков кода. По умолчанию `None`.
        default (str, optional): Значение, возвращаемое, если блок кода не найден. По умолчанию `None`.

    Returns:
        str: Блок кода, извлеченный из строки.
    """
```

**Назначение**:
Функция `filter_markdown` предназначена для извлечения блока кода из входной строки. Она ищет блок кода, заключенный между маркерами ```. Если указан `allowd_types`, функция проверяет, соответствует ли тип блока кода одному из разрешенных типов.

**Параметры**:
- `text` (str): Входная строка, содержащая блок кода.
- `allowd_types` (list, optional): Список допустимых типов блоков кода. Если `None`, все типы блоков кода разрешены. По умолчанию `None`.
- `default` (str, optional): Значение, которое возвращается, если блок кода не найден или его тип не разрешен. По умолчанию `None`.

**Возвращает**:
- `str`: Если блок кода найден и его тип разрешен, функция возвращает содержимое блока кода. В противном случае возвращается значение `default`.

**Принцип работы**:
1. Функция использует регулярное выражение для поиска блока кода, заключенного между маркерами ```.
2. Если блок кода найден, функция проверяет, указан ли параметр `allowd_types`.
3. Если `allowd_types` указан, функция проверяет, соответствует ли тип блока кода одному из разрешенных типов.
4. Если тип блока кода разрешен или `allowd_types` не указан, функция возвращает содержимое блока кода.
5. Если блок кода не найден или его тип не разрешен, функция возвращает значение `default`.

**Примеры**:

```python
text = "```python\nprint('Hello, world!')\n```"
code = filter_markdown(text)
print(code)  # Вывод: print('Hello, world!')

text = "```json\n{\"key\": \"value\"}\n```"
code = filter_markdown(text, allowd_types=['python'])
print(code)  # Вывод: None

text = "```json\n{\"key\": \"value\"}\n```"
code = filter_markdown(text, allowd_types=['json'])
print(code)  # Вывод: {"key": "value"}
```

### `filter_json`

```python
def filter_json(text: str) -> str:
    """
    Извлекает JSON блок кода из строки.

    Args:
        text (str): Строка, содержащая JSON блок кода.

    Returns:
        dict: Словарь, полученный из JSON блока кода.
    """
```

**Назначение**:
Функция `filter_json` извлекает JSON блок кода из входной строки. Она использует функцию `filter_markdown` с предопределенными параметрами для поиска и извлечения JSON блока.

**Параметры**:
- `text` (str): Входная строка, содержащая JSON блок кода.

**Возвращает**:
- `str`: JSON блок кода, извлеченный из строки.

**Принцип работы**:
1. Функция вызывает функцию `filter_markdown` с параметрами `text`, `allowd_types=['', 'json']` и `default=text.strip('^\n ')`.
2. Функция `filter_markdown` ищет блок кода, заключенный между маркерами ```, и проверяет, является ли его тип JSON.
3. Если JSON блок кода найден, функция возвращает его содержимое.
4. Если JSON блок кода не найден, функция возвращает исходную строку с удаленными начальными и конечными пробелами и символами новой строки.

**Примеры**:

```python
text = "```json\n{\"key\": \"value\"}\n```"
json_code = filter_json(text)
print(json_code)  # Вывод: {"key": "value"}

text = "```python\nprint('Hello, world!')\n```"
json_code = filter_json(text)
print(json_code)  # Вывод: ```python\nprint('Hello, world!')\n```
```

### `find_stop`

```python
def find_stop(stop: Optional[list[str]], content: str, chunk: str = None):
    """
    Находит первое вхождение стоп-слова в содержимом.

    Args:
        stop (Optional[list[str]]): Список стоп-слов для поиска.
        content (str): Строка, в которой производится поиск.
        chunk (str, optional): Дополнительная строка для поиска. По умолчанию `None`.

    Returns:
        tuple: Кортеж, содержащий индекс первого вхождения, усеченное содержимое и усеченный фрагмент.
    """
```

**Назначение**:
Функция `find_stop` ищет первое вхождение одного из стоп-слов в заданном содержимом. Если стоп-слово найдено, функция возвращает индекс его первого вхождения и усекает содержимое до этого места.

**Параметры**:
- `stop` (Optional[list[str]]): Список стоп-слов для поиска. Если `None`, функция ничего не делает и возвращает исходные значения.
- `content` (str): Строка, в которой производится поиск стоп-слов.
- `chunk` (str, optional): Дополнительная строка, которая также усекается, если стоп-слово найдено. По умолчанию `None`.

**Возвращает**:
- `tuple`: Кортеж, содержащий:
  - `first` (int): Индекс первого вхождения стоп-слова в содержимом. Если стоп-слово не найдено, возвращается -1.
  - `content` (str): Усеченное содержимое до первого вхождения стоп-слова.
  - `chunk` (str): Усеченный фрагмент до первого вхождения стоп-слова (если `chunk` не `None`).

**Принцип работы**:
1. Функция перебирает список стоп-слов и ищет первое вхождение каждого стоп-слова в содержимом.
2. Если стоп-слово найдено, функция усекает содержимое и фрагмент (если он есть) до этого места и возвращает индекс первого вхождения, усеченное содержимое и усеченный фрагмент.
3. Если ни одно из стоп-слов не найдено, функция возвращает -1, исходное содержимое и исходный фрагмент.

**Примеры**:

```python
stop_words = ['stop', 'end']
content = 'This is a stop word example.'
chunk = 'This is a chunk example.'
first, content, chunk = find_stop(stop_words, content, chunk)
print(first, content, chunk)  # Вывод: 10 This is a   This is a chunk example.

stop_words = ['stop', 'end']
content = 'This is a test example.'
chunk = 'This is a chunk example.'
first, content, chunk = find_stop(stop_words, content, chunk)
print(first, content, chunk)  # Вывод: -1 This is a test example. This is a chunk example.
```

### `filter_none`

```python
def filter_none(**kwargs) -> dict:
    """
    Удаляет элементы со значением `None` из словаря.

    Args:
        **kwargs: Произвольные именованные аргументы.

    Returns:
        dict: Новый словарь, содержащий только элементы, значения которых не равны `None`.
    """
```

**Назначение**:
Функция `filter_none` создает новый словарь, содержащий только те элементы из входного словаря, значения которых не равны `None`.

**Параметры**:
- `**kwargs`: Произвольные именованные аргументы, представляющие элементы словаря.

**Возвращает**:
- `dict`: Новый словарь, содержащий только элементы, значения которых не равны `None`.

**Принцип работы**:
1. Функция перебирает все элементы входного словаря.
2. Для каждого элемента функция проверяет, равно ли его значение `None`.
3. Если значение элемента не равно `None`, функция добавляет этот элемент в новый словарь.
4. После перебора всех элементов функция возвращает новый словарь.

**Примеры**:

```python
filtered_dict = filter_none(a=1, b=None, c=3)
print(filtered_dict)  # Вывод: {'a': 1, 'c': 3}

filtered_dict = filter_none(a=None, b=None, c=None)
print(filtered_dict)  # Вывод: {}
```

### `safe_aclose`

```python
async def safe_aclose(generator: AsyncGenerator) -> None:
    """
    Безопасно закрывает асинхронный генератор.

    Args:
        generator (AsyncGenerator): Асинхронный генератор для закрытия.

    Returns:
        None
    """
```

**Назначение**:
Функция `safe_aclose` безопасно закрывает асинхронный генератор, обрабатывая возможные исключения, которые могут возникнуть при закрытии генератора.

**Параметры**:
- `generator` (AsyncGenerator): Асинхронный генератор, который необходимо закрыть.

**Возвращает**:
- `None`

**Принцип работы**:
1. Функция проверяет, является ли `generator` асинхронным генератором и имеет ли он метод `aclose`.
2. Если `generator` является асинхронным генератором и имеет метод `aclose`, функция пытается закрыть генератор, вызвав метод `aclose`.
3. Если при закрытии генератора возникает исключение, функция перехватывает исключение и записывает предупреждающее сообщение в журнал.

**Примеры**:

```python
import asyncio
async def async_generator():
    try:
        for i in range(3):
            yield i
            await asyncio.sleep(0.1)
    finally:
        print("Generator closed")

async def main():
    gen = async_generator()
    async for i in gen:
        print(i)
        if i == 1:
            await safe_aclose(gen)
            break

asyncio.run(main())