# Модуль для объединения текстовых файлов для ChatGPT

## Обзор

Модуль предоставляет функции для рекурсивного чтения текстовых файлов в указанном каталоге и объединения их содержимого в один или несколько файлов. Также включает функциональность для удаления HTML-тегов и docstring'ов из содержимого файлов. Предназначен для подготовки данных для использования в ChatGPT.

## Подробнее

Этот модуль предназначен для автоматизации процесса сбора и подготовки текстовых данных из различных файлов в каталоге. Он позволяет рекурсивно обходить директории, читать содержимое файлов Python, удалять из них HTML-теги и docstring'и, а затем объединять все содержимое в один или несколько выходных файлов. Модуль также предоставляет возможность исключать определенные директории и расширения файлов из обработки.

## Функции

### `clean_html`

**Назначение**: Удаляет HTML-теги из содержимого.

```python
def clean_html(content: str) -> str:
    """ Удаляет HTML-теги из содержимого.

    Args:
        content (str): HTML-содержимое для очистки.

    Returns:
        str: Содержимое без HTML-тегов.

    Пример:
        >>> clean_html('<p>Hello, World!</p>')
        'Hello, World!'
    """
    ...
```

**Параметры**:
- `content` (str): HTML-содержимое для очистки.

**Возвращает**:
- `str`: Содержимое без HTML-тегов.

**Как работает функция**:
1.  Функция принимает строку `content`, содержащую HTML-код.
2.  Использует библиотеку `BeautifulSoup` для парсинга HTML-кода.
3.  Извлекает текст из HTML-кода, удаляя все теги.
4.  Возвращает очищенный текст.

### `remove_docstrings`

**Назначение**: Удаляет все блоки с тройными кавычками `"""` и `'''` из текста.

```python
def remove_docstrings(content: str) -> str:
    """ Удаляет все блоки с тройными кавычками `\\"""` и `\\\'\'\'` из текста.

    Args:
        content (str): Текстовое содержимое, из которого нужно удалить блоки с тройными кавычками.

    Returns:
        str: Текст без блоков с тройными кавычками.

    Пример:
        >>> remove_docstrings('\'\'\'def foo():\\n    \\"""This is a docstring\\"""\\\\n    pass\'\'\')
        'def foo():\\\\n    pass'
    """
    ...
```

**Параметры**:
- `content` (str): Текстовое содержимое, из которого нужно удалить docstring'и.

**Возвращает**:
- `str`: Текст без docstring'ов.

**Как работает функция**:
1.  Функция принимает строку `content`, содержащую текст.
2.  Использует регулярные выражения (`re.sub`) для поиска и удаления многострочных docstring'ов, заключенных в тройные двойные кавычки (`"""`).
3.  Использует регулярные выражения (`re.sub`) для поиска и удаления многострочных docstring'ов, заключенных в тройные одинарные кавычки (`'''`).
4.  Возвращает текст без docstring'ов.

### `delete_directory_contents`

**Назначение**: Рекурсивно удаляет все содержимое указанной директории.

```python
def delete_directory_contents(directory: Path) -> None:
    """ Рекурсивно удаляет все содержимое указанной директории.

    Args:
        directory (Path): Путь к директории, содержимое которой нужно удалить.

    Returns:
        None

    Пример:
        >>> delete_directory_contents(Path('../tmp/chat_gpt/aliexpress'))
    """
    ...
```

**Параметры**:
- `directory` (Path): Путь к директории, содержимое которой нужно удалить.

**Возвращает**:
- `None`

**Как работает функция**:
1.  Функция принимает объект `Path`, представляющий директорию.
2.  Итерируется по всем элементам (файлам и поддиректориям) в указанной директории.
3.  Если элемент является директорией, рекурсивно вызывает `delete_directory_contents` для этой директории, а затем пытается удалить саму директорию.
4.  Если элемент является файлом, пытается удалить файл.
5.  Логирует информацию об удаленных файлах и директориях, а также об ошибках при удалении.

### `read_text_files`

**Назначение**: Читает все указанные Python файлы в каталоге и сохраняет объединенный текст в несколько файлов, если размер содержимого превышает заданное количество символов.

```python
def read_text_files(
    directory: str, output_file: str, remove_docs: bool = False, max_chars: int = 2000
) -> None:
    """ Читает все указанные Python файлы в каталоге и сохраняет объединенный текст в несколько файлов,
    если размер содержания превышает 2000 символов.

    Args:
        directory (str): Каталог для поиска файлов.
        output_file (str): Базовое имя файла для сохранения объединенного текста.
        remove_docs (bool): Если `True`, удаляет блоки с тройными кавычками из текста. По умолчанию `False`.
        max_chars (int): Максимальное количество символов для каждого файла. По умолчанию 2000.

    Returns:
        None

    Пример:
        >>> read_text_files('src', 'output.txt', remove_docs=True)
    """
    ...
```

**Параметры**:
- `directory` (str): Каталог для поиска файлов.
- `output_file` (str): Базовое имя файла для сохранения объединенного текста.
- `remove_docs` (bool): Если `True`, удаляет docstring'и из текста. По умолчанию `False`.
- `max_chars` (int): Максимальное количество символов для каждого файла. По умолчанию 2000.

**Возвращает**:
- `None`

**Как работает функция**:
1.  Функция принимает путь к директории, имя выходного файла, флаг для удаления docstring'ов и максимальное количество символов на файл.
2.  Создает директорию для выходных файлов, если она не существует.
3.  Рекурсивно обходит указанную директорию.
4.  Для каждого файла Python:
    - Читает содержимое файла.
    - Если файл пустой, пропускает его.
    - Если `remove_docs` равен `True`, удаляет docstring'и из содержимого.
    - Если текущий размер содержимого в выходном файле плюс размер текущего файла превышает `max_chars`, создает новый выходной файл.
    - Записывает содержимое файла в текущий выходной файл, предваряя его именем файла.
5.  Логирует информацию об обрабатываемых файлах и ошибках.

## Примеры

### Пример использования `read_text_files`

```python
from pathlib import Path
from dev_utils.code2file_for_chat_gpt import read_text_files

# Указываем каталог для поиска и файл для сохранения вывода
directory_to_search = "../data/chat_gpt/code2file"
output_file_path = Path("../data/chat_gpt/code2file/code2file.txt")

# Создаем директорию, если она не существует
output_file_path.parent.mkdir(parents=True, exist_ok=True)

# Создаем файл, если его не существует
output_file_path.touch(exist_ok=True)

read_text_files(directory_to_search, output_file_path, remove_docs=True)