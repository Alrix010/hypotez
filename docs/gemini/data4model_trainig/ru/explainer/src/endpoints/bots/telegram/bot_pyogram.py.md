### **Системные инструкции для обработки кода проекта `hypotez`**

=========================================================================================

Описание функциональности и правил для генерации, анализа и улучшения кода. Направлено на обеспечение последовательного и читаемого стиля кодирования, соответствующего требованиям.

---

### **Основные принципы**

#### **1. Общие указания**:
- Соблюдай четкий и понятный стиль кодирования.
- Все изменения должны быть обоснованы и соответствовать установленным требованиям.

#### **2. Комментарии**:
- Используй `#` для внутренних комментариев.
- Документация всех функций, методов и классов должна следовать такому формату: 
    ```python
        def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:
            """ 
            Args:
                param (str): Описание параметра `param`.
                param1 (Optional[str | dict | str], optional): Описание параметра `param1`. По умолчанию `None`.
    
            Returns:
                dict | None: Описание возвращаемого значения. Возвращает словарь или `None`.
    
            Raises:
                SomeError: Описание ситуации, в которой возникает исключение `SomeError`.

            Ехаmple:
                >>> function('param', 'param1')
                {'param': 'param1'}
            """
    ```
- Комментарии и документация должны быть четкими, лаконичными и точными.

#### **3. Форматирование кода**:
- Используй одинарные кавычки. `a:str = 'value'`, `print('Hello World!')`;
- Добавляй пробелы вокруг операторов. Например, `x = 5`;
- Все параметры должны быть аннотированы типами. `def function(param: str, param1: Optional[str | dict | str] = None) -> dict | None:`;
- Не используй `Union`. Вместо этого используй `|`.

#### **4. Логирование**:
- Для логгирования Всегда Используй модуль `logger` из `src.logger.logger`.
- Ошибки должны логироваться с использованием `logger.error`.
Пример:
    ```python
        try:
            ...
        except Exception as ex:
            logger.error('Error while processing data', ех, exc_info=True)
    ```
#### **5 Не используй `Union[]` в коде. Вместо него используй `|`
Например:
```python
x: str | int ...
```




---

### **Основные требования**:

#### **1. Формат ответов в Markdown**:
- Все ответы должны быть выполнены в формате **Markdown**.

#### **2. Формат комментариев**:
- Используй указанный стиль для комментариев и документации в коде.
- Пример:

```python
from typing import Generator, Optional, List
from pathlib import Path


def read_text_file(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[List[str]] = None,
    chunk_size: int = 8192,
) -> Generator[str, None, None] | str | None:
    """
    Считывает содержимое файла (или файлов из каталога) с использованием генератора для экономии памяти.

    Args:
        file_path (str | Path): Путь к файлу или каталогу.
        as_list (bool): Если `True`, возвращает генератор строк.
        extensions (Optional[List[str]]): Список расширений файлов для чтения из каталога.
        chunk_size (int): Размер чанков для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или `None` в случае ошибки.

    Raises:
        Exception: Если возникает ошибка при чтении файла.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> content = read_text_file(file_path)
        >>> if content:
        ...    print(f'File content: {content[:100]}...')
        File content: Example text...
    """
    ...
```
- Всегда делай подробные объяснения в комментариях. Избегай расплывчатых терминов, 
- таких как *«получить»* или *«делать»*. Вместо этого используйте точные термины, такие как *«извлечь»*, *«проверить»*, *«выполнить»*.
- Вместо: *«получаем»*, *«возвращаем»*, *«преобразовываем»* используй имя объекта *«функция получае»*, *«переменная возвращает»*, *«код преобразовывает»* 
- Комментарии должны непосредственно предшествовать описываемому блоку кода и объяснять его назначение.

#### **3. Пробелы вокруг операторов присваивания**:
- Всегда добавляйте пробелы вокруг оператора `=`, чтобы повысить читаемость.
- Примеры:
  - **Неправильно**: `x=5`
  - **Правильно**: `x = 5`

#### **4. Использование `j_loads` или `j_loads_ns`**:
- Для чтения JSON или конфигурационных файлов замените стандартное использование `open` и `json.load` на `j_loads` или `j_loads_ns`.
- Пример:

```python
# Неправильно:
with open('config.json', 'r', encoding='utf-8') as f:
    data = json.load(f)

# Правильно:
data = j_loads('config.json')
```

#### **5. Сохранение комментариев**:
- Все существующие комментарии, начинающиеся с `#`, должны быть сохранены без изменений в разделе «Улучшенный код».
- Если комментарий кажется устаревшим или неясным, не изменяйте его. Вместо этого отметьте его в разделе «Изменения».

#### **6. Обработка `...` в коде**:
- Оставляйте `...` как указатели в коде без изменений.
- Не документируйте строки с `...`.
```

#### **7. Аннотации**
Для всех переменных должны быть определены аннотации типа. 
Для всех функций все входные и выходные параметры аннотириваны
Для все параметров должны быть аннотации типа.


### **8. webdriver**
В коде используется webdriver. Он импртируется из модуля `webdriver` проекта `hypotez`
```python
from src.webdirver import Driver, Chrome, Firefox, Playwright, ...
driver = Driver(Firefox)

Пoсле чего может использоваться как

close_banner = {
  "attribute": null,
  "by": "XPATH",
  "selector": "//button[@id = 'closeXButton']",
  "if_list": "first",
  "use_mouse": false,
  "mandatory": false,
  "timeout": 0,
  "timeout_for_event": "presence_of_element_located",
  "event": "click()",
  "locator_description": "Закрываю pop-up окно, если оно не появилось - не страшно (`mandatory`:`false`)"
}

result = driver.execute_locator(close_banner)
```

## Анализ кода `hypotez/src/endpoints/bots/telegram/bot_pyogram.py`

### 1. Блок-схема
```mermaid
graph TD
    A[Начало] --> B{Чтение переменных окружения: API_ID, API_HASH, BOT_TOKEN};
    B -- Успешно --> C[Создание экземпляра клиента Pyrogram];
    C --> D{Регистрация обработчика команды /start};
    D --> E{Регистрация обработчика текстовых сообщений};
    E --> F[Запуск бота];
    B -- Ошибка --> G[Завершение с ошибкой];
    D -- Ошибка --> G;
    E -- Ошибка --> G;
    F --> H[Бот работает];
    style G fill:#f9f,stroke:#333,stroke-width:2px

    subgraph Пример блока B
    B1[Чтение TELEGRAM_API_ID из os.environ];
    B2[Чтение TELEGRAM_API_HASH из os.environ];
    B3[Чтение TELEGRAM_TOKEN из os.environ];
    B --> B1;
    B1 --> B2;
    B2 --> B3;
    B3 --> C;
    end

    subgraph Пример блока D
    D1[Регистрация функции start_command на команду /start];
    D2[Функция start_command отправляет приветственное сообщение];
    D --> D1;
    D1 --> D2;
    D2 --> E;
    end

    subgraph Пример блока E
    E1[Регистрация функции echo_message на текстовые сообщения];
    E2[Функция echo_message повторяет текст сообщения];
    E --> E1;
    E1 --> E2;
    E2 --> F;
    end
```

### 2. Диаграмма
```mermaid
flowchart TD
    A[<code>bot_pyogram.py</code>] --> B(pyrogram);
    A --> C(os);

    B --> B1[Client];
    B --> B2[filters];

    C --> C1[environ];
    style A fill:#f9f,stroke:#333,stroke-width:2px
```

**Объяснение зависимостей:**

-   `pyrogram`:  Основная библиотека для работы с Telegram API.

    *   `Client`: Класс для создания и управления Telegram ботом.
    *   `filters`: Модуль, содержащий функции для фильтрации входящих сообщений.
-   `os`: Модуль для взаимодействия с операционной системой, используется для получения переменных окружения.

    *   `environ`:  Словарь, содержащий переменные окружения.

### 3. Объяснение
Файл `hypotez/src/endpoints/bots/telegram/bot_pyogram.py` представляет собой простой Telegram-бот, созданный с использованием библиотеки `pyrogram`.

#### Импорты:

-   `from pyrogram import Client, filters`:
    *   `Client`: Класс, который предоставляет интерфейс для взаимодействия с Telegram API. Он используется для создания экземпляра бота и управления им.
    *   `filters`: Модуль, содержащий различные фильтры для обработки входящих сообщений. Фильтры позволяют определить, какие сообщения должен обрабатывать конкретный обработчик.
-   `import os`:
    *   `os`: Модуль, предоставляющий функции для взаимодействия с операционной системой. В данном случае используется для получения значений переменных окружения, таких как `API_ID`, `API_HASH` и `BOT_TOKEN`.

#### Переменные:

-   `API_ID: int`: Идентификатор приложения Telegram, необходимый для аутентификации. Получается из переменной окружения `TELEGRAM_API_ID`.
-   `API_HASH: str`:  Секретный ключ приложения Telegram, также необходимый для аутентификации. Получается из переменной окружения `TELEGRAM_API_HASH`.
-   `BOT_TOKEN: str`: Токен бота, полученный от BotFather в Telegram. Используется для аутентификации бота. Получается из переменной окружения `TELEGRAM_TOKEN`.
- `app: Client`:  Экземпляр класса `Client` из библиотеки `pyrogram`. Этот объект представляет собой Telegram-бота и используется для взаимодействия с Telegram API.

#### Функции:

-   `start_command(client: Client, message)`:
    *   Аргументы:
        *   `client`: Экземпляр класса `Client`, представляющий бота.
        *   `message`: Объект, представляющий входящее сообщение.
    *   Назначение: Обработчик команды `/start`. Отправляет приветственное сообщение пользователю в ответ на команду `/start`.
    *   Пример: Если пользователь отправляет боту сообщение "/start", бот отвечает сообщением "Привет! Я простой бот на Pyrogram.".
-   `echo_message(client: Client, message)`:
    *   Аргументы:
        *   `client`: Экземпляр класса `Client`, представляющий бота.
        *   `message`: Объект, представляющий входящее сообщение.
    *   Назначение: Обработчик всех текстовых сообщений, не являющихся командами. Бот повторяет текст сообщения, отправленного пользователем.
    *   Пример: Если пользователь отправляет боту сообщение "Привет", бот отвечает сообщением "Привет".

#### Классы:

-   `Client`:
    *   Роль: Предоставляет интерфейс для взаимодействия с Telegram API.
    *   Атрибуты: Содержит информацию о боте, такую как API ID, API Hash и токен бота.
    *   Методы: Предоставляет методы для отправки сообщений, обработки входящих сообщений и выполнения других действий с Telegram API.

#### Потенциальные ошибки и области для улучшения:

-   **Обработка ошибок**: В коде отсутствует обработка ошибок при получении переменных окружения. Если какая-либо из переменных окружения не задана, бот не запустится. Следует добавить обработку исключений `KeyError` при чтении переменных окружения и предусмотреть логирование ошибок.
-   **Логирование**: Отсутствует логирование работы бота. Следует добавить логирование для отслеживания ошибок и событий.
-   **Конфигурация**:  Значения `API_ID`, `API_HASH` и `BOT_TOKEN` хранятся в переменных окружения, что является хорошей практикой.  Однако, можно добавить возможность чтения этих значений из конфигурационного файла для удобства развертывания и управления.

#### Цепочка взаимосвязей с другими частями проекта:

Данный файл является частью подсистемы Telegram-ботов проекта `hypotez`. Он может быть связан с другими модулями, отвечающими за:

-   Управление ботами (запуск, остановка, перезапуск).
-   Хранение и управление конфигурацией ботов.
-   Логирование работы ботов.
-   Мониторинг состояния ботов.