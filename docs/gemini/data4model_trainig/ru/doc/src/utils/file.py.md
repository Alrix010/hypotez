# Модуль для работы с файлами `file.py`

## Обзор

Модуль `file.py` предоставляет набор утилит для выполнения операций с файлами, таких как сохранение, чтение и получение списков файлов. Он поддерживает обработку больших файлов с использованием генераторов для экономии памяти.

## Подробнее

Модуль содержит функции для сохранения данных в текстовые файлы, чтения содержимого файлов (с поддержкой генераторов для больших файлов), получения списка имен файлов и директорий, а также удаления BOM (Byte Order Mark) из файлов.

## Функции

### `save_text_file`

```python
def save_text_file(file_path: str | Path, data: str | list[str] | dict, mode: str = 'w') -> bool:
    """
    Сохраняет данные в текстовый файл.

    Args:
        file_path (str | Path): Путь к файлу для сохранения.
        data (str | list[str] | dict): Данные для записи. Могут быть строкой, списком строк или словарем.
        mode (str, optional): Режим записи файла ('w' для записи, 'a' для добавления).

    Returns:
        bool: `True`, если файл успешно сохранен, `False` в противном случае.

    Raises:
        Exception: При возникновении ошибки при записи в файл.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> data = 'Пример текста'
        >>> result = save_text_file(file_path, data)
        >>> print(result)
        True
    """
```

**Назначение**: Сохраняет переданные данные в текстовый файл. Данные могут быть строкой, списком строк или словарем.

**Параметры**:
- `file_path` (str | Path): Путь к файлу, в который нужно сохранить данные.
- `data` (str | list[str] | dict): Данные для сохранения. Если это список, каждая строка будет записана в новой строке файла. Если это словарь, он будет сохранен в формате JSON.
- `mode` (str, optional): Режим открытия файла. `'w'` - для записи (перезаписи), `'a'` - для добавления в конец файла. По умолчанию `'w'`.

**Возвращает**:
- `bool`: `True`, если файл успешно сохранен, `False` в противном случае.

**Вызывает исключения**:
- `Exception`: Возникает при ошибке записи в файл.

**Как работает функция**:
1. Функция принимает путь к файлу, данные для записи и режим записи.
2. Создается объект `Path` из `file_path`.
3. Создаются все необходимые родительские директории для файла, если они не существуют.
4. Открывается файл в указанном режиме и кодировке UTF-8.
5. В зависимости от типа данных, выполняется запись:
   - Если данные - список, каждая строка записывается в файл с новой строки.
   - Если данные - словарь, они записываются в файл в формате JSON.
   - Если данные - строка, они записываются в файл как есть.
6. Если во время записи возникает ошибка, она логируется, и функция возвращает `False`.

**Примеры**:

```python
from pathlib import Path
file_path = Path('example.txt')

# Сохранение строки
data = 'Пример текста'
result = save_text_file(file_path, data)
print(result)  # Вывод: True

# Сохранение списка строк
data = ['Строка 1', 'Строка 2', 'Строка 3']
result = save_text_file(file_path, data)
print(result)  # Вывод: True

# Сохранение словаря в формате JSON
data = {'ключ1': 'значение1', 'ключ2': 'значение2'}
result = save_text_file(file_path, data)
print(result)  # Вывод: True
```

### `read_text_file_generator`

```python
def read_text_file_generator(
    file_path: str | Path,
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    chunk_size: int = 8192,
    recursive: bool = False,
    patterns: Optional[str | list[str]] = None,
) -> Generator[str, None, None] | str | list[str] | None:
    """
    Читает содержимое файла(ов) или директории.

        Args:
            file_path (str | Path): Путь к файлу или директории.
            as_list (bool, optional): Если `True`, то возвращает генератор строк или список строк, в зависимости от типа вывода.
            extensions (list[str], optional): Список расширений файлов для включения при чтении директории.
            chunk_size (int, optional): Размер чанка для чтения файла в байтах.
            recursive (bool, optional): Если `True`, то поиск файлов выполняется рекурсивно.
            patterns (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске.

        Returns:
            Generator[str, None, None] | str | list[str] | None:
            - Если `as_list` is True и `file_path` является файлом, возвращает генератор строк.
            - Если `as_list` is True и `file_path` является директорией и `recursive` is True, возвращает список строк.
            - Если `as_list` is False и `file_path` является файлом, возвращает строку.
            - Если `as_list` is False и `file_path` является директорией, возвращает объединенную строку.
            - Возвращает `None` в случае ошибки.
        Raises:
            Exception: При возникновении ошибки при чтении файла.

        Example:
            >>> from pathlib import Path
            >>> file_path = Path('example.txt')
            >>> content = read_text_file(file_path)
            >>> if content:
            ...    print(f'File content: {content[:100]}...')
            File content: Пример текста...
    Функция read_text_file может возвращать несколько разных типов данных в зависимости от входных параметров:

    Возвращаемые значения:
    ----------------------

    - Generator[str, None, None] (Генератор строк):
        Генератор при итерации выдаёт строки из файла(ов) по одной. Эффективно для работы с большими файлами, так как они не загружаются полностью в память.
        - Когда:
            file_path – это файл и as_list равен True.
            file_path – это директория, recursive равен True и as_list равен True. При этом в генератор попадают строки из всех найденных файлов.
            file_path – это директория, recursive равен False и as_list равен True. При этом в генератор попадают строки из всех найденных файлов в текущей директории.
        
    - str (Строка):
        Содержимое файла или объединенное содержимое всех файлов в виде одной строки.
        - Когда:
            file_path – это файл и as_list равен False.
            file_path – это директория, recursive равен False и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории, разделенных символами новой строки (\\n).
            file_path – это директория, recursive равен True и as_list равен False. При этом возвращается объединенная строка, состоящая из содержимого всех файлов в директории и её поддиректориях, разделенных символами новой строки (\\n).
 
    - list[str] (Список строк):
        Этот тип явно не возвращается функцией, однако когда file_path – это директория, recursive равен True и as_list равен True - функция возвращает генератор, который можно преобразовать в список при помощи list()
        - Когда:
            file_path – не является ни файлом, ни директорией.
            Произошла ошибка при чтении файла или директории (например, файл не найден, ошибка доступа и т.п.).


    Note:
        Если вы хотите прочитать содержимое файла построчно (особенно для больших файлов) используйте as_list = True. В этом случае вы получите генератор строк.\n
        Если вы хотите получить всё содержимое файла в виде одной строки используйте as_list = False.\n
        Если вы работаете с директорией, recursive = True будет обходить все поддиректории.\n
        extensions и patterns позволят вам фильтровать файлы при работе с директорией.\n
        chunk_size позволяет оптимизировать работу с большими файлами при чтении их по частям.\n
        None будет возвращён в случае ошибок.\n

    Важно помнить:
        В случае чтения директории, если as_list=False, функция объединяет все содержимое найденных файлов в одну строку. Это может потребовать много памяти, если файлов много или они большие.\n
        Функция полагается на другие функции-помощники (_read_file_lines_generator, _read_file_content, recursively_get_file_path, yield_text_from_files), которые здесь не определены и их поведение влияет на результат read_text_file.\n


    """
```

**Назначение**: Читает содержимое одного или нескольких файлов, или директории. Поддерживает рекурсивное чтение директорий и фильтрацию файлов по расширению и шаблону.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк или список строк, в зависимости от контекста. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах. По умолчанию `8192`.
- `recursive` (bool, optional): Если `True`, выполняет рекурсивный поиск файлов в директории. По умолчанию `False`.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов при рекурсивном поиске. По умолчанию `None`.

**Возвращает**:
- `Generator[str, None, None] | str | list[str] | None`:
    - Если `as_list` is `True` и `file_path` является файлом, возвращает генератор строк.
    - Если `as_list` is `True` и `file_path` является директорией и `recursive` is `True`, возвращает генератор строк.
    - Если `as_list` is `False` и `file_path` является файлом, возвращает строку.
    - Если `as_list` is `False` и `file_path` является директорией, возвращает объединенную строку.
    - Возвращает `None` в случае ошибки.

**Вызывает исключения**:
- `Exception`: При возникновении ошибки при чтении файла.

**Как работает функция**:
1. Функция принимает путь к файлу или директории и параметры для чтения.
2. Определяется, является ли `file_path` файлом или директорией.
3. Если это файл:
   - Если `as_list` is `True`, функция возвращает генератор строк, читающий файл по частям.
   - Если `as_list` is `False`, функция возвращает содержимое файла как строку.
4. Если это директория:
   - Если `recursive` is `True`, функция рекурсивно обходит все поддиректории и читает файлы, соответствующие указанным расширениям и шаблонам.
   - Если `recursive` is `False`, функция читает только файлы в текущей директории, соответствующие указанным расширениям.
   - Если `as_list` is `True`, функция возвращает генератор строк.
   - Если `as_list` is `False`, функция возвращает объединенную строку, состоящую из содержимого всех файлов, разделенных символами новой строки.
5. Если `file_path` не является ни файлом, ни директорией, функция логирует ошибку и возвращает `None`.
6. Если во время чтения возникает ошибка, она логируется, и функция возвращает `None`.

**Примеры**:

```python
from pathlib import Path

# Чтение содержимого файла как строки
file_path = Path('example.txt')
content = read_text_file_generator(file_path)
if content:
    print(f'File content: {content[:100]}...')

# Чтение содержимого файла как генератора строк
file_path = Path('example.txt')
for line in read_text_file_generator(file_path, as_list=True):
    print(line)

# Рекурсивное чтение файлов из директории
dir_path = Path('.')
for line in read_text_file_generator(dir_path, as_list=True, recursive=True, extensions=['.txt']):
    print(line)
```

### `read_text_file`

```python
def read_text_file(
    file_path: Union[str, Path],
    as_list: bool = False,
    extensions: Optional[list[str]] = None,
    exc_info: bool = True,
) -> str | list[str] | None:
    """
    Read the contents of a file.

    Args:
        file_path (str | Path): Path to the file or directory.
        as_list (bool, optional): If True, returns content as list of lines. Defaults to False.
        extensions (list[str], optional): List of file extensions to include if reading a directory. Defaults to None.
        exc_info (bool, optional): If True, logs traceback on error. Defaults to True.

    Returns:
        str | list[str] | None: File content as a string or list of lines, or None if an error occurs.
    """
```

**Назначение**: Читает содержимое файла или директории.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает содержимое файла как список строк. По умолчанию `False`.
- `extensions` (list[str], optional): Список расширений файлов для включения при чтении директории. По умолчанию `None`.
- `exc_info` (bool, optional): Если `True`, логирует трассировку ошибки. По умолчанию `True`.

**Возвращает**:
- `str | list[str] | None`: Содержимое файла в виде строки или списка строк, или `None`, если произошла ошибка.

**Как работает функция**:
1. Функция принимает путь к файлу или директории и параметры для чтения.
2. Определяется, является ли `file_path` файлом или директорией.
3. Если это файл:
   - Открывается файл в режиме чтения с кодировкой UTF-8.
   - Если `as_list` is `True`, функция возвращает содержимое файла как список строк.
   - Если `as_list` is `False`, функция возвращает содержимое файла как строку.
4. Если это директория:
   - Функция рекурсивно обходит все поддиректории и читает файлы, соответствующие указанным расширениям.
   - Если `as_list` is `True`, функция возвращает список списков строк, где каждый подсписок соответствует содержимому одного файла.
   - Если `as_list` is `False`, функция возвращает объединенную строку, состоящую из содержимого всех файлов, разделенных символами новой строки.
5. Если `file_path` не является ни файлом, ни директорией, функция логирует предупреждение и ничего не возвращает.
6. Если во время чтения возникает ошибка, она логируется, и функция возвращает `None`.

**Примеры**:

```python
from pathlib import Path

# Чтение содержимого файла как строки
file_path = Path('example.txt')
content = read_text_file(file_path)
if content:
    print(f'File content: {content[:100]}...')

# Чтение содержимого файла как списка строк
file_path = Path('example.txt')
content = read_text_file(file_path, as_list=True)
if content:
    for line in content:
        print(line)

# Рекурсивное чтение файлов из директории
dir_path = Path('.')
content = read_text_file(dir_path, as_list=True, extensions=['.txt'])
if content:
    for line in content:
        print(line)
```

### `yield_text_from_files`

```python
def yield_text_from_files(
    file_path: str | Path,
    as_list: bool = False,
    chunk_size: int = 8192
) -> Generator[str, None, None] | str | None:
    """
    Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

    Args:
        file_path (str | Path): Путь к файлу.
        as_list (bool, optional): Если True, возвращает генератор строк. По умолчанию False.
        chunk_size (int, optional): Размер чанка для чтения файла в байтах.

    Returns:
        Generator[str, None, None] | str | None: Генератор строк, объединенная строка или None в случае ошибки.

    Yields:
       str: Строки из файла, если as_list is True.

    Example:
        >>> from pathlib import Path
        >>> file_path = Path('example.txt')
        >>> for line in yield_text_from_files(file_path, as_list=True):\
        ...     print(line)
        Первая строка файла
        Вторая строка файла
    """
```

**Назначение**: Читает содержимое файла и возвращает его в виде генератора строк или одной строки.

**Параметры**:
- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. По умолчанию `False`.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах.

**Возвращает**:
- `Generator[str, None, None] | str | None`: Генератор строк, объединенная строка или `None` в случае ошибки.

**Yields**:
- `str`: Строки из файла, если `as_list` is `True`.

**Как работает функция**:
1. Функция принимает путь к файлу и параметры для чтения.
2. Определяется, является ли `file_path` файлом.
3. Если это файл:
   - Если `as_list` is `True`, функция возвращает генератор строк, читающий файл по частям.
   - Если `as_list` is `False`, функция возвращает содержимое файла как строку.
4. Если `file_path` не является файлом, функция логирует ошибку и возвращает `None`.
5. Если во время чтения возникает ошибка, она логируется, и функция возвращает `None`.

**Примеры**:

```python
from pathlib import Path

# Чтение содержимого файла как генератора строк
file_path = Path('example.txt')
for line in yield_text_from_files(file_path, as_list=True):
    print(line)

# Чтение содержимого файла как строки
file_path = Path('example.txt')
content = yield_text_from_files(file_path)
if content:
    print(f'File content: {content[:100]}...')
```

### `_read_file_content`

```python
def _read_file_content(file_path: Path, chunk_size: int) -> str:
    """
    Читает содержимое файла по чанкам и возвращает как строку.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Returns:
        str: Содержимое файла в виде строки.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает содержимое файла по частям (чанкам) и возвращает его в виде одной строки.

**Параметры**:
- `file_path` (Path): Путь к файлу, который необходимо прочитать.
- `chunk_size` (int): Размер каждого чанка, который считывается из файла за одну операцию.

**Возвращает**:
- `str`: Полное содержимое файла в виде строки.

**Вызывает исключения**:
- `Exception`: Если во время чтения файла возникает ошибка.

**Как работает функция**:
1. Функция открывает файл, указанный в `file_path`, в режиме чтения с кодировкой UTF-8.
2. Инициализируется пустая строка `content`.
3. В цикле `while` считываются данные из файла по частям, размером `chunk_size` за раз.
4. Каждый считанный чанк добавляется к переменной `content`.
5. Цикл продолжается до тех пор, пока не будет достигнут конец файла.
6. Функция возвращает строку `content`, содержащую полное содержимое файла.

**Примеры**:

```python
from pathlib import Path

# Пример использования функции
file_path = Path('example.txt')
chunk_size = 4096  # Размер чанка в байтах

try:
    file_content = _read_file_content(file_path, chunk_size)
    print(f"Содержимое файла: {file_content[:100]}...")  # Вывод первых 100 символов
except Exception as e:
    print(f"Произошла ошибка при чтении файла: {e}")
```

### `_read_file_lines_generator`

```python
def _read_file_lines_generator(file_path: Path, chunk_size: int) -> Generator[str, None, None]:
    """
    Читает файл по строкам с помощью генератора.

    Args:
        file_path (Path): Путь к файлу для чтения.
        chunk_size (int): Размер чанка для чтения файла в байтах.
    Yields:
        str: Строки из файла.
    Raises:
        Exception: При возникновении ошибки при чтении файла.
    """
```

**Назначение**: Читает файл по частям (чанкам) и возвращает строки с использованием генератора.

**Параметры**:
- `file_path` (Path): Путь к файлу, который необходимо прочитать.
- `chunk_size` (int): Размер каждого чанка, который считывается из файла за одну операцию.

**Возвращает**:
- `Generator[str, None, None]`: Генератор строк, представляющих собой строки файла.

**Yields**:
- `str`: Строки из файла.

**Вызывает исключения**:
- `Exception`: Если во время чтения файла возникает ошибка.

**Как работает функция**:
1. Функция открывает файл, указанный в `file_path`, в режиме чтения с кодировкой UTF-8.
2. В цикле `while` считываются данные из файла по частям, размером `chunk_size` за раз.
3. Каждый считанный чанк разбивается на строки с помощью `splitlines()`.
4. Если чанк не заканчивается полной строкой, то последняя строка добавляется к следующему чанку.
5. Функция `yield` возвращает каждую строку из файла.

**Примеры**:

```python
from pathlib import Path

# Пример использования функции
file_path = Path('example.txt')
chunk_size = 4096  # Размер чанка в байтах

try:
    for line in _read_file_lines_generator(file_path, chunk_size):
        print(line)  # Вывод каждой строки файла
except Exception as e:
    print(f"Произошла ошибка при чтении файла: {e}")
```

### `get_filenames_from_directory`

```python
def get_filenames_from_directory(
    directory: str | Path, ext: str | list[str] = '*'
) -> list[str]:
    """
    Возвращает список имен файлов в директории, опционально отфильтрованных по расширению.

    Args:
        directory (str | Path): Путь к директории для поиска.
        ext (str | list[str], optional): Расширения для фильтрации.
            По умолчанию '*'.

    Returns:
        list[str]: Список имен файлов, найденных в директории.

    Example:
        >>> from pathlib import Path
        >>> directory = Path('.')
        >>> get_filenames_from_directory(directory, ['.txt', '.md'])
        ['example.txt', 'readme.md']
    """
```

**Назначение**: Возвращает список имен файлов в указанной директории, с возможностью фильтрации по расширению.

**Параметры**:
- `directory` (str | Path): Путь к директории, в которой нужно искать файлы.
- `ext` (str | list[str], optional): Расширения файлов для фильтрации. Если указано `'*'`, то возвращаются все файлы. По умолчанию `'*'`.

**Возвращает**:
- `list[str]`: Список имен файлов, найденных в директории и соответствующих заданным расширениям.

**Как работает функция**:
1. Функция проверяет, является ли указанный путь директорией. Если нет, то логируется ошибка и возвращается пустой список.
2. Если `ext` является строкой, то она преобразуется в список, если она не равна `'*'`.
3. К каждому расширению добавляется точка, если её нет.
4. Функция итерируется по содержимому директории и добавляет имена файлов в список, если они соответствуют заданным расширениям.

**Примеры**:

```python
from pathlib import Path

# Пример 1: Получение списка всех файлов в директории
directory = Path('.')
filenames = get_filenames_from_directory(directory)
print(filenames)  # ['file1.txt', 'file2.py', 'file3.md']

# Пример 2: Получение списка файлов с расширением .txt и .md
directory = Path('.')
filenames = get_filenames_from_directory(directory, ['.txt', '.md'])
print(filenames)  # ['file1.txt', 'file3.md']
```

### `recursively_yield_file_path`

```python
def recursively_yield_file_path(
    root_dir: str | Path, patterns: str | list[str] = '*'
) -> Generator[Path, None, None]:
    """
    Рекурсивно возвращает пути ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая директория для поиска.
        patterns (str | list[str]): Шаблоны для фильтрации файлов.

    Yields:
        Path: Путь к файлу, соответствующему шаблону.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
        ...    print(path)
        ./example.txt
        ./readme.md
    """
```

**Назначение**: Рекурсивно обходит указанную директорию и возвращает пути ко всем файлам, которые соответствуют заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория, с которой начинается поиск файлов.
- `patterns` (str | list[str], optional): Шаблон(ы) для фильтрации файлов. Может быть как строкой с одним шаблоном, так и списком шаблонов. По умолчанию `'*'`, что означает все файлы.

**Yields**:
- `Path`: Путь к файлу, который соответствует заданному шаблону.

**Как работает функция**:
1. Функция принимает корневую директорию и шаблон(ы) для поиска файлов.
2. Преобразует шаблон в список, если он представлен строкой.
3. Для каждого шаблона используется `rglob` для рекурсивного поиска файлов, соответствующих шаблону.
4. Функция возвращает путь к каждому найденному файлу с использованием `yield`, что позволяет итерироваться по результатам поиска без загрузки всех путей в память.

**Примеры**:

```python
from pathlib import Path

# Пример 1: Рекурсивный поиск всех файлов с расширением .txt в текущей директории и её поддиректориях
root_dir = Path('.')
for path in recursively_yield_file_path(root_dir, '*.txt'):
    print(path)

# Пример 2: Рекурсивный поиск файлов с расширением .txt и .md
root_dir = Path('.')
for path in recursively_yield_file_path(root_dir, ['*.txt', '*.md']):
    print(path)
```

### `recursively_get_file_path`

```python
def recursively_get_file_path(
    root_dir: str | Path,
    patterns: str | list[str] = '*'
) -> list[Path]:
    """
    Рекурсивно возвращает список путей ко всем файлам, соответствующим заданным шаблонам, в указанной директории.

    Args:
        root_dir (str | Path): Корневая директория для поиска.
        patterns (str | list[str]): Шаблоны для фильтрации файлов.

    Returns:
        list[Path]: Список путей к файлам, соответствующим шаблонам.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
        >>> print(paths)
        [Path('./example.txt'), Path('./readme.md')]
    """
```

**Назначение**: Рекурсивно обходит указанную директорию и возвращает список путей ко всем файлам, которые соответствуют заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория, с которой начинается поиск файлов.
- `patterns` (str | list[str], optional): Шаблон(ы) для фильтрации файлов. Может быть как строкой с одним шаблоном, так и списком шаблонов. По умолчанию `'*'`, что означает все файлы.

**Возвращает**:
- `list[Path]`: Список путей к файлам, которые соответствуют заданному шаблону.

**Как работает функция**:
1. Функция принимает корневую директорию и шаблон(ы) для поиска файлов.
2. Преобразует шаблон в список, если он представлен строкой.
3. Для каждого шаблона используется `rglob` для рекурсивного поиска файлов, соответствующих шаблону.
4. Функция добавляет пути к найденным файлам в список `file_paths`.
5. Возвращает список `file_paths`, содержащий все найденные пути.

**Примеры**:

```python
from pathlib import Path

# Пример 1: Рекурсивный поиск всех файлов с расширением .txt в текущей директории и её поддиректориях
root_dir = Path('.')
paths = recursively_get_file_path(root_dir, '*.txt')
print(paths)

# Пример 2: Рекурсивный поиск файлов с расширением .txt и .md
root_dir = Path('.')
paths = recursively_get_file_path(root_dir, ['*.txt', '*.md'])
print(paths)
```

### `recursively_read_text_files`

```python
def recursively_read_text_files(
    root_dir: str | Path,
    patterns: str | list[str],
    as_list: bool = False
) -> list[str]:
    """
    Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.

    Args:
        root_dir (str | Path): Путь к корневой директории для поиска.
        patterns (str | list[str]): Шаблон(ы) имени файла для фильтрации.
             Может быть как одиночным шаблоном (например, '*.txt'), так и списком.
        as_list (bool, optional): Если True, то возвращает содержимое файла как список строк.
             По умолчанию `False`.

    Returns:
        list[str]: Список содержимого файлов (или список строк, если `as_list=True`),
         соответствующих заданным шаблонам.

    Example:
        >>> from pathlib import Path
        >>> root_dir = Path('.')
        >>> contents = recursively_read_text_files(root_dir, ['*.txt', '*.md'], as_list=True)
        >>> for line in contents:
        ...     print(line)
        Содержимое example.txt
        Первая строка readme.md
        Вторая строка readme.md
    """
```

**Назначение**: Рекурсивно читает текстовые файлы из указанной корневой директории, соответствующие заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Путь к корневой директории для поиска.
- `patterns` (str | list[str]): Шаблон(ы) имени файла для фильтрации.
- `as_list` (bool, optional): Если `True`, возвращает содержимое файла как список строк. По умолчанию `False`.

**Возвращает**:
- `list[str]`: Список содержимого файлов (или список строк, если `as_list=True`), соответствующих заданным шаблонам.

**Как работает функция**:
1. Проверяет, является ли `root_dir` директорией. Если нет, логирует ошибку и возвращает пустой список.
2. Преобразует `patterns` в список, если это строка.
3. Рекурсивно обходит все файлы в `root_dir` и её поддиректориях с помощью `os.walk`.
4. Для каждого файла проверяет, соответствует ли его имя одному из шаблонов в `patterns`.
5. Если файл соответствует шаблону, открывает его и читает содержимое.
6. Если `as_list` is `True`, добавляет строки из файла в `matches`. Иначе добавляет всё содержимое файла как одну строку.
7. Возвращает список `matches`.

**Примеры**:

```python
from pathlib import Path

# Пример 1: Рекурсивное чтение всех файлов .txt и .md в текущей директории и её поддиректориях
root_dir = Path('.')
contents = recursively_read_text_files(root_dir, ['*.txt', '*.md'])
for content in contents:
    print(content)

# Пример 2: Рекурсивное чтение файлов .txt и .md и возврат содержимого в виде списка строк