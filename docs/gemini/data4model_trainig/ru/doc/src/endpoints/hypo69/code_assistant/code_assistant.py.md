# Модуль code_assistant.py: Ассистент программиста для обработки кода с использованием моделей ИИ
## Обзор

Модуль предназначен для автоматизации задач, связанных с анализом, документированием и улучшением кодовой базы проектов. Он включает в себя класс `CodeAssistant`, который взаимодействует с различными AI-моделями (в частности, Google Gemini и OpenAI) для обработки файлов с кодом, создания документации, примеров кода и тестов. Результаты работы сохраняются в указанной директории в зависимости от выбранной роли ассистента.

## Подробнее

Модуль `code_assistant.py` предоставляет функциональность для автоматической обработки кодовой базы проекта с использованием моделей искусственного интеллекта. Он позволяет генерировать документацию, примеры кода и тесты, а также проверять качество кода.

### Классы

#### `Config`

**Описание**: Класс `Config` содержит конфигурационные параметры для работы `CodeAssistant`.

**Атрибуты**:
- `base_path` (Path): Базовый путь к каталогу `code_assistant`.
- `config` (SimpleNamespace): Объект, содержащий конфигурацию из файла `code_assistant.json`.
- `roles_list` (list): Список доступных ролей для ассистента.
- `languages_list` (list): Список поддерживаемых языков.
- `role` (str): Текущая роль ассистента (по умолчанию `'doc_writer_md'`).
- `lang` (str): Текущий язык ассистента (по умолчанию `'ru'`).
- `process_dirs` (list[Path]): Список директорий для обработки.
- `exclude_dirs` (list[Path]): Список директорий, исключенных из обработки.
- `exclude_files_patterns` (list[Path]): Список шаблонов файлов, исключенных из обработки.
- `include_files_patterns` (list[Path]): Список шаблонов файлов, включенных в обработку.
- `exclude_files` (list[Path]): Список файлов, исключенных из обработки.
- `response_mime_type` (str): Mime-тип ответа (по умолчанию из конфига).
- `output_directory_patterns` (list): Паттерны для директорий вывода.
- `code_instruction` (str): Инструкция для кода, читаемая из файла.
- `system_instruction` (str): Инструкция для модели, читаемая из файла.
- `gemini` (SimpleNamespace): Конфигурация для модели Gemini, включающая имя модели, API-ключ и тип ответа.

**Методы**:
- `code_instruction()`: Возвращает инструкцию для кода, читая её из файла. Обеспечивает возможность обновления инструкций "на лету".
- `system_instruction()`: Возвращает инструкцию для модели, читая её из файла. Обеспечивает возможность обновления инструкций "на лету".

#### `CodeAssistant`

**Описание**: Класс `CodeAssistant` предназначен для взаимодействия с моделями ИИ и выполнения задач по обработке кода.

**Атрибуты**:
- `role` (str): Роль, определяющая задачи, выполняемые ассистентом.
- `lang` (str): Язык, на котором ассистент выполняет задачи.
- `gemini` (GoogleGenerativeAI): Экземпляр класса `GoogleGenerativeAI` для взаимодействия с моделью Gemini.
- `openai` (OpenAIModel): Экземпляр класса `OpenAIModel` для взаимодействия с моделью OpenAI.

**Методы**:

### `__init__`
```python
def __init__(
    self,
    role: Optional[str] = 'doc_writer_md',
    lang: Optional[str] = 'en',
    models_list: Optional[list[str, str] | str] = ['gemini'],
    system_instruction: Optional[str | Path] = None,
    **kwards,
) -> None:
    """
    Инициализация ассистента с заданными параметрами.

    Args:
        role (str): Роль для выполнения задачи.
        lang (str): Язык выполнения.
        models_list (list[str]): Список моделей для инициализации.
        system_instruction (str|Path): Общая инструкция для модели. 
        **kwards: Дополнительные аргументы для инициализации моделей.
    """
```
**Назначение**: Инициализирует экземпляр класса `CodeAssistant` с заданными параметрами роли, языка, списка моделей и системных инструкций. Обновляет атрибуты класса `Config` на основе переданных аргументов.

**Параметры**:
- `role` (Optional[str]): Роль ассистента. По умолчанию `'doc_writer_md'`.
- `lang` (Optional[str]): Язык ассистента. По умолчанию `'en'`.
- `models_list` (Optional[list[str] | str]): Список моделей для инициализации. По умолчанию `['gemini']`.
- `system_instruction` (Optional[str | Path]): Путь к файлу с системной инструкцией для модели. По умолчанию `None`.
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Как работает функция**:
- Обновляет параметры конфигурации `Config.role`, `Config.lang` и `Config.system_instruction`, если переданы соответствующие аргументы.
- Вызывает метод `_initialize_models` для инициализации указанных моделей ИИ.

**Примеры**:
```python
assistant = CodeAssistant(role='code_checker', lang='ru', models_list=['gemini'])
assistant = CodeAssistant(role='doc_writer_md', lang='en', models_list=['openai'], system_instruction='path/to/instruction.md')
```

### `_initialize_models`
```python
def _initialize_models(self, models_list: list, response_mime_type: Optional[str] = '', **kwards) -> bool:
    """
    Инициализация моделей на основе заданных параметров.

    Args:
        models_list (list[str]): Список моделей для инициализации.
        **kwards: Дополнительные аргументы для инициализации моделей.

    Returns:
        bool: Успешность инициализации моделей.

    Raises:
        Exception: Если произошла ошибка при инициализации моделей.
    """
```
**Назначение**: Инициализирует указанные модели искусственного интеллекта (в данный момент поддерживается только Gemini).

**Параметры**:
- `models_list` (list[str]): Список моделей для инициализации.
- `response_mime_type` (Optional[str]): MIME-тип ответа. По умолчанию ''.
- `**kwards`: Дополнительные аргументы для инициализации моделей.

**Возвращает**:
- `bool`: `True`, если инициализация прошла успешно, `False` в противном случае.

**Как работает функция**:
- Проверяет, есть ли `'gemini'` в списке моделей.
- Если есть, пытается создать экземпляр класса `GoogleGenerativeAI` с использованием параметров из `kwards` и `Config.gemini`.
- Логирует ошибки, если инициализация не удалась.

**Примеры**:
```python
assistant._initialize_models(['gemini'], model_name='gemini-pro', api_key='your_api_key')
```

### `send_file`
```python
def send_file(self, file_path: Path) -> Optional[str | None]:
    """
    Отправка файла в модель.

    Args:
        file_path (Path): Абсолютный путь к файлу, который нужно отправить.
        file_name (Optional[str]): Имя файла для отправки. Если не указано и 'src' отсутствует, используется имя файла без изменений.

    Returns:
        Optional[str | None]: URL файла, если успешно отправлен, иначе None.
    """
```

**Назначение**: Отправляет указанный файл в модель Gemini для обработки.

**Параметры**:
- `file_path` (Path): Абсолютный путь к файлу, который необходимо отправить.

**Возвращает**:
- `Optional[str | None]`: URL файла, если отправка прошла успешно, `None` в противном случае.

**Как работает функция**:
- Пытается отправить файл в модель Gemini, используя метод `upload_file`.
- Возвращает URL файла, если получен ответ с атрибутом `url`.
- Логирует ошибки, если отправка не удалась.

**Примеры**:
```python
file_url = assistant.send_file(Path('example.py'))
```

### `process_files`
```python
async def process_files(
    self, process_dirs: Optional[str | Path | list[str | Path]] = None, start_from_file: Optional[int] = 1
) -> bool:
    """компиляция, отправка запроса и сохранение результата."""
```
**Назначение**: Компилирует, отправляет запросы в модель Gemini и сохраняет результаты обработки файлов.

**Параметры**:
- `process_dirs` (Optional[str | Path | list[str | Path]]): Список директорий для обработки. Если `None`, используется `Config.process_dirs`.
- `start_from_file` (Optional[int]): Номер файла, с которого начинается обработка. По умолчанию 1.

**Возвращает**:
- `bool`: `True`, если обработка завершена успешно, `False` в противном случае.

**Как работает функция**:
- Обновляет `Config.process_dirs`, если передан аргумент `process_dirs`.
- Итерируется по списку директорий для обработки.
- Для каждой директории проверяет её существование и тип (должна быть директорией).
- Итерируется по файлам в директории, используя `_yield_files_content`.
- Для каждого файла создает запрос, используя `_create_request`, отправляет его в модель Gemini, используя `gemini.ask_async`.
- Сохраняет ответ, используя `_save_response`.
- Логирует ошибки при чтении файлов, составлении запросов, получении ответов и сохранении результатов.
- Использует `asyncio.sleep` для ограничения нагрузки на модель.

**Примеры**:
```python
await assistant.process_files(process_dirs=['src', 'tests'], start_from_file=5)
```

### `_create_request`
```python
def _create_request(self, file_path: str, content: str) -> str:
    """Создание запроса с учетом роли и языка."""
```

**Назначение**: Создает запрос к модели на основе содержимого файла, роли и языка.

**Параметры**:
- `file_path` (str): Путь к файлу.
- `content` (str): Содержимое файла.

**Возвращает**:
- `str`: Строковое представление запроса.

**Как работает функция**:
- Создает словарь `content_request`, содержащий роль, язык, путь к файлу и инструкцию для модели.
- Преобразует содержимое файла в строку и добавляет в запрос.
- Логирует ошибки, если не удалось составить запрос.

**Примеры**:
```python
request = assistant._create_request('example.py', 'def hello(): print("Hello")')
```

### `_yield_files_content`
```python
def _yield_files_content(
    self,
    process_directory: str | Path,
) -> Iterator[tuple[Path, str]]:
    """
    Генерирует пути файлов и их содержимое по указанным шаблонам.

    Args:
        process_directory (Path | str): Абсолютный путь к стартовой директории

    Returns:
        bool: Iterator
    """
```
**Назначение**: Генерирует пути к файлам и их содержимое в заданной директории.

**Параметры**:
- `process_directory` (str | Path): Путь к директории, в которой нужно искать файлы.

**Возвращает**:
- `Iterator[tuple[Path, str]]`: Итератор, возвращающий кортежи, содержащие путь к файлу и его содержимое.

**Как работает функция**:
- Компилирует шаблоны исключенных файлов.
- Итерируется по всем файлам в директории, используя `rglob`.
- Проверяет каждый файл на соответствие шаблонам включения и исключения.
- Читает содержимое файла и возвращает путь к файлу и его содержимое.
- Логирует ошибки при чтении файлов.

**Примеры**:
```python
for file_path, content in assistant._yield_files_content('src'):
    print(f"File: {file_path}, Content: {content[:100]}...")
```

### `_save_response`
```python
async def _save_response(self, file_path: Path, response: str, model_name: str) -> bool:
    """
    Сохранение ответа модели в файл с добавлением суффикса.

    Метод сохраняет ответ модели в файл, добавляя к текущему расширению файла
    дополнительный суффикс, определяемый ролью.

    Args:
        file_path (Path): Исходный путь к файлу, в который будет записан ответ.
        response (str): Ответ модели, который необходимо сохранить.
        model_name (str): Имя модели, использованной для генерации ответа.

    Raises:
        OSError: Если не удаётся создать директорию или записать в файл.
    """
```
**Назначение**: Сохраняет ответ модели в файл с добавлением суффикса, зависящего от роли.

**Параметры**:
- `file_path` (Path): Путь к исходному файлу.
- `response` (str): Ответ модели.
- `model_name` (str): Имя модели.

**Возвращает**:
- `bool`: `True`, если сохранение прошло успешно, `False` в противном случае.

**Как работает функция**:
- Определяет директорию для вывода на основе роли и имени модели.
- Формирует имя файла с суффиксом, зависящим от роли.
- Создает директорию, если она не существует.
- Записывает ответ в файл.
- Логирует ошибки, если не удалось сохранить файл.

**Примеры**:
```python
await assistant._save_response(Path('example.py'), 'Generated documentation', 'gemini')
```

### `_remove_outer_quotes`
```python
def _remove_outer_quotes(self, response: str) -> str:
    """
    Удаляет внешние кавычки в начале и в конце строки, если они присутствуют.

    Args:
        response (str): Ответ модели, который необходимо обработать.

    Returns:
        str: Очищенный контент как строка.

    Example:
        >>> _remove_outer_quotes('```md some content ```')
        'some content'
        >>> _remove_outer_quotes('some content')
        'some content'
        >>> _remove_outer_quotes('```python def hello(): print("Hello") ```')
        '```python def hello(): print("Hello") ```'
    """
```
**Назначение**: Удаляет внешние кавычки из ответа модели, если они присутствуют.

**Параметры**:
- `response` (str): Ответ модели.

**Возвращает**:
- `str`: Очищенный от кавычек контент.

**Как работает функция**:
- Удаляет пробельные символы в начале и конце строки.
- Если строка начинается с '```python' или '```mermaid', возвращает её без изменений.
- Удаляет префиксы и суффиксы "```", если они есть в конфигурации.

**Примеры**:
```python
cleaned_response = assistant._remove_outer_quotes('```md some content ```')
```

### `run`
```python
def run(self, start_from_file: int = 1) -> None:
    """Запуск процесса обработки файлов."""
```
**Назначение**: Запускает процесс обработки файлов.

**Параметры**:
- `start_from_file` (int): Номер файла, с которого начать обработку.

**Как работает функция**:
- Устанавливает обработчик сигнала `SIGINT` для прерывания выполнения.
- Запускает асинхронную обработку файлов, используя `process_files`.

**Примеры**:
```python
assistant.run(start_from_file=10)
```

### `_signal_handler`
```python
def _signal_handler(self, signal, frame) -> None:
    """Обработка прерывания выполнения."""
```
**Назначение**: Обрабатывает прерывание выполнения (например, при нажатии Ctrl+C).

**Параметры**:
- `signal`: Сигнал.
- `frame`: Фрейм стека.

**Как работает функция**:
- Логирует сообщение о прерывании процесса.
- Завершает выполнение программы.

**Примеры**:
```python
# Внутри класса CodeAssistant
signal.signal(signal.SIGINT, self._signal_handler)
```

### Функции

#### `parse_args`
```python
def parse_args() -> dict:
    """Разбор аргументов командной строки."""
```

**Назначение**: Разбирает аргументы командной строки.

**Возвращает**:
- `dict`: Словарь с аргументами командной строки.

**Как работает функция**:
- Использует `argparse` для определения аргументов командной строки.
- Возвращает словарь с значениями аргументов.

**Примеры**:
```python
args = parse_args()
role = args['role']
```

#### `main`
```python
def main() -> None:
    """
    Функция запускает бесконечный цикл, в котором выполняется обработка файлов с учетом ролей и языков, указанных в конфигурации.
    Конфигурация обновляется в каждом цикле, что позволяет динамически изменять настройки в файле `code_assistant.json` во время работы программы.
    Для каждой комбинации языка и роли создается экземпляр класса :class:`CodeAssistant`, который обрабатывает файлы, используя заданную модель ИИ.
    """
```
**Назначение**: Запускает основной процесс обработки файлов в бесконечном цикле.

**Как работает функция**:
- В бесконечном цикле итерируется по списку языков и ролей из конфигурации.
- Для каждой комбинации создает экземпляр `CodeAssistant` и запускает обработку файлов.

**Примеры**:
```python
if __name__ == '__main__':
    main()
```