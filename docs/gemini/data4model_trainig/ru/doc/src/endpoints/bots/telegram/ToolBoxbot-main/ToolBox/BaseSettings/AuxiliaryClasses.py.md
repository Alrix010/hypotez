# Модуль AuxiliaryClasses.py

## Обзор

Модуль `AuxiliaryClasses.py` содержит вспомогательные классы `keyboards` и `PromptsCompressor`, предназначенные для работы с Telegram ботом. Класс `keyboards` предоставляет методы для создания различных типов клавиатур для бота, а класс `PromptsCompressor` используется для сжатия и обработки текстовых запросов (промтов), используемых в ответах бота.

## Подробней

Этот модуль предоставляет инструменты для упрощения создания интерактивных элементов (клавиатур) и обработки текстовых запросов, что способствует улучшению взаимодействия пользователя с ботом. Он содержит методы для генерации клавиатур с различными конфигурациями и для сжатия промтов, что делает код более читаемым и удобным в поддержке. Расположение файла в структуре проекта указывает на то, что он является частью логики Telegram-бота и отвечает за обработку и отправку сообщений пользователю.

## Классы

### `keyboards`

**Описание**: Класс `keyboards` предназначен для создания различных типов клавиатур, используемых в Telegram-боте.

**Атрибуты**: Нет явно заданных атрибутов класса.

**Методы**:

- `_keyboard_two_blank(self, data: list[str], name: list[str]) -> types.InlineKeyboardMarkup`
- `_reply_keyboard(self, name: list[str])`

### `PromptsCompressor`

**Описание**: Класс `PromptsCompressor` предназначен для сжатия и обработки текстовых запросов (промтов), используемых в ответах бота.

**Атрибуты**:

- `commands_size (list[list[str]])`: Список, определяющий структуру команд и ожидаемые параметры для каждого типа запроса.

**Методы**:

- `__init__(self)`: Инициализирует экземпляр класса `PromptsCompressor` и определяет структуру команд.
- `get_prompt(self, info: list[str], ind: int) -> str`: Получает и форматирует запрос на основе предоставленной информации и индекса.
- `html_tags_insert(response: str) -> str`: Статический метод для вставки HTML-тегов в текстовый ответ.

## Методы класса `keyboards`

### `_keyboard_two_blank`

```python
def _keyboard_two_blank(self, data: list[str], name: list[str]) -> types.InlineKeyboardMarkup:
    """
    Создает встроенную клавиатуру с двумя кнопками в строке.

    Args:
        data (list[str]): Список данных, которые будут переданы в callback_data для каждой кнопки.
        name (list[str]): Список отображаемых имен кнопок.

    Returns:
        types.InlineKeyboardMarkup: Объект встроенной клавиатуры.

    """
    ...
```

**Назначение**:
Метод создает встроенную клавиатуру Telegram с кнопками, расположенными по две в ряд. Данные для каждой кнопки берутся из списков `data` и `name`.

**Параметры**:
- `data` (list[str]): Список строк, используемых в качестве callback_data для каждой кнопки.
- `name` (list[str]): Список строк, представляющих текст, отображаемый на каждой кнопке.

**Возвращает**:
- `types.InlineKeyboardMarkup`: Объект встроенной клавиатуры, готовый для отправки с сообщением.

**Как работает функция**:
1. Инициализируется объект встроенной клавиатуры `types.InlineKeyboardMarkup`.
2. Создается список кнопок `types.InlineKeyboardButton`, используя предоставленные списки `data` и `name`.
3. Если количество кнопок четное, они добавляются на клавиатуру попарно.
4. Если количество кнопок нечетное, все кнопки, кроме последней, добавляются попарно, а последняя кнопка добавляется отдельно.
5. Возвращается созданная клавиатура.

**Примеры**:

```python
from telebot import types
# Пример создания экземпляра класса keyboards
kb = keyboards()

# Пример данных для кнопок
button_data = ['1', '2', '3', '4']
button_names = ['Кнопка 1', 'Кнопка 2', 'Кнопка 3', 'Кнопка 4']

# Создание клавиатуры
keyboard = kb._keyboard_two_blank(button_data, button_names)

# Теперь клавиатуру можно добавить к сообщению и отправить пользователю
# (предполагается, что bot - это экземпляр TeleBot)
# bot.send_message(chat_id=chat_id, text='Выберите опцию:', reply_markup=keyboard)
```

### `_reply_keyboard`

```python
def _reply_keyboard(self, name: list[str]):
    """
    Создает клавиатуру ответа с кнопками.

    Args:
        name (list[str]): Список отображаемых имен кнопок.

    Returns:
        types.ReplyKeyboardMarkup: Объект клавиатуры ответа.

    """
    ...
```

**Назначение**:
Метод создает клавиатуру ответа (ReplyKeyboardMarkup) с кнопками, текст которых берется из списка `name`.

**Параметры**:
- `name` (list[str]): Список строк, представляющих текст, отображаемый на каждой кнопке.

**Возвращает**:
- `types.ReplyKeyboardMarkup`: Объект клавиатуры ответа, готовый для отправки с сообщением.

**Как работает функция**:
1. Инициализируется объект клавиатуры ответа `types.ReplyKeyboardMarkup` с включенной возможностью изменения размера (`resize_keyboard=True`).
2. Создается список кнопок `types.KeyboardButton`, используя предоставленный список `name`.
3. Каждая кнопка добавляется на клавиатуру.
4. Возвращается созданная клавиатура.

**Примеры**:

```python
from telebot import types
# Пример создания экземпляра класса keyboards
kb = keyboards()

# Пример данных для кнопок
button_names = ['Кнопка A', 'Кнопка B', 'Кнопка C']

# Создание клавиатуры
keyboard = kb._reply_keyboard(button_names)

# Теперь клавиатуру можно добавить к сообщению и отправить пользователю
# (предполагается, что bot - это экземпляр TeleBot)
# bot.send_message(chat_id=chat_id, text='Выберите опцию:', reply_markup=keyboard)
```

## Методы класса `PromptsCompressor`

### `__init__`

```python
def __init__(self):
    """
    Инициализирует класс PromptsCompressor, задавая размеры команд.
    """
    ...
```

**Назначение**:
Метод инициализирует класс `PromptsCompressor` и определяет структуру команд, используемых для обработки текстовых запросов.

**Как работает функция**:
1. Определяется атрибут `commands_size`, который представляет собой список списков строк. Каждый внутренний список определяет ожидаемые параметры для определенного типа запроса.

**Примеры**:

```python
# Пример создания экземпляра класса PromptsCompressor
compressor = PromptsCompressor()

# Теперь можно использовать методы класса для обработки запросов
```

### `get_prompt`

```python
def get_prompt(self, info: list[str], ind: int) -> str:
    """
    Получает и форматирует текстовый запрос на основе предоставленной информации и индекса.

    Args:
        info (list[str]): Список строк, содержащих информацию для вставки в запрос.
        ind (int): Индекс, указывающий на тип запроса.

    Returns:
        str: Сформированный текстовый запрос.

    Raises:
        FileNotFoundError: Если файл 'ToolBox/BaseSettings/prompts.json' не найден.
        json.JSONDecodeError: Если содержимое файла 'ToolBox/BaseSettings/prompts.json' не является корректным JSON.
        KeyError: Если в JSON-файле отсутствует ключ 'commands'.

    """
    ...
```

**Назначение**:
Метод извлекает текстовый запрос из файла `prompts.json` и форматирует его, заменяя placeholder-ы на предоставленную информацию.

**Параметры**:
- `info` (list[str]): Список строк, содержащих информацию для вставки в запрос.
- `ind` (int): Индекс, указывающий на тип запроса.

**Возвращает**:
- `str`: Сформированный текстовый запрос.

**Как работает функция**:
1. Открывается файл `ToolBox/BaseSettings/prompts.json` для чтения.
2. Загружается содержимое файла в формате JSON.
3. Извлекается шаблон запроса из JSON-файла по индексу `ind`.
4. Происходит замена placeholder-ов в шаблоне запроса на значения из списка `info`.
5. Возвращается отформатированный текстовый запрос.

**Примеры**:

```python
# Пример создания экземпляра класса PromptsCompressor
compressor = PromptsCompressor()

# Пример данных для вставки в запрос
prompt_info = ['Тема', 'Целевая аудитория', 'Длина текста']

# Пример получения запроса по индексу
prompt = compressor.get_prompt(prompt_info, 0)

# Теперь можно использовать полученный запрос
# print(prompt)
```

### `html_tags_insert`

```python
@staticmethod
def html_tags_insert(response: str) -> str:
    """
    Вставляет HTML-теги в текстовый ответ для форматирования.

    Args:
        response (str): Текстовый ответ для форматирования.

    Returns:
        str: Отформатированный текстовый ответ с HTML-тегами.
    """
    ...
```

**Назначение**:
Статический метод, который вставляет HTML-теги в текстовый ответ для форматирования текста.

**Параметры**:
- `response` (str): Текстовый ответ, в который необходимо вставить HTML-теги.

**Возвращает**:
- `str`: Отформатированный текстовый ответ с HTML-тегами.

**Как работает функция**:
1. Определяется список шаблонов (`patterns`), содержащий регулярные выражения для поиска и замены определенных участков текста на HTML-теги.
2. Проходится по каждому шаблону в списке.
3. Используется функция `re.sub` для замены соответствующих участков текста на HTML-теги.
4. Возвращается отформатированный текстовый ответ.

**Примеры**:

```python
# Пример использования статического метода html_tags_insert
formatted_text = PromptsCompressor.html_tags_insert("#### Заголовок\nТекст **жирным шрифтом**")

# Теперь можно использовать отформатированный текст
# print(formatted_text)