# Модуль `Qwen_Qwen_2_5M`

## Обзор

Модуль `Qwen_Qwen_2_5M` предоставляет асинхронный генератор для взаимодействия с моделью Qwen Qwen-2.5M через API сервиса Hugging Face Space. Он поддерживает потоковую передачу данных и системные сообщения, но не поддерживает историю сообщений.

## Подробней

Этот модуль позволяет отправлять запросы к модели Qwen Qwen-2.5M, размещенной на Hugging Face Space, и получать ответы в асинхронном режиме. Он использует `aiohttp` для выполнения асинхронных HTTP-запросов и предоставляет возможность получать данные в потоковом режиме. Модуль также включает поддержку системных сообщений, что позволяет задавать контекст для модели.

## Классы

### `Qwen_Qwen_2_5M`

**Описание**: Класс `Qwen_Qwen_2_5M` является асинхронным провайдером генерации текста, использующим модель Qwen Qwen-2.5M.

**Наследует**:
- `AsyncGeneratorProvider`: Обеспечивает асинхронную генерацию данных.
- `ProviderModelMixin`: Предоставляет функциональность для работы с моделями провайдера.

**Атрибуты**:
- `label` (str): Метка провайдера, `"Qwen Qwen-2.5M"`.
- `url` (str): URL сервиса Hugging Face Space, `"https://qwen-qwen2-5-1m-demo.hf.space"`.
- `api_endpoint` (str): URL API для запросов, формируется из `url`.
- `working` (bool): Указывает, работает ли провайдер, `True`.
- `supports_stream` (bool): Поддержка потоковой передачи, `True`.
- `supports_system_message` (bool): Поддержка системных сообщений, `True`.
- `supports_message_history` (bool): Поддержка истории сообщений, `False`.
- `default_model` (str): Модель по умолчанию, `"qwen-2.5-1m-demo"`.
- `model_aliases` (dict): Псевдонимы моделей, `{"qwen-2.5-1m": default_model}`.
- `models` (list): Список поддерживаемых моделей, формируется из ключей `model_aliases`.

**Принцип работы**:
Класс `Qwen_Qwen_2_5M` использует асинхронные запросы к Hugging Face Space для генерации текста на основе модели Qwen Qwen-2.5M. Он реализует метод `create_async_generator`, который отправляет запросы к API и обрабатывает ответы в потоковом режиме.

## Методы класса

### `create_async_generator`

```python
@classmethod
async def create_async_generator(
    cls,
    model: str,
    messages: Messages,
    proxy: str = None,
    return_conversation: bool = False,
    conversation: JsonConversation = None,
    **kwargs
) -> AsyncResult:
    """Создает асинхронный генератор для взаимодействия с моделью Qwen Qwen-2.5M.

    Args:
        model (str): Название используемой модели.
        messages (Messages): Список сообщений для отправки.
        proxy (str, optional): Прокси-сервер для использования. По умолчанию `None`.
        return_conversation (bool, optional): Флаг, указывающий, нужно ли возвращать объект `JsonConversation`. По умолчанию `False`.
        conversation (JsonConversation, optional): Объект `JsonConversation` для поддержания состояния разговора. По умолчанию `None`.
        **kwargs: Дополнительные аргументы.

    Returns:
        AsyncResult: Асинхронный генератор, выдающий результаты генерации текста.

    Raises:
        Exception: Если возникает ошибка при выполнении запроса.
    """
```

**Параметры**:
- `cls`: Ссылка на класс `Qwen_Qwen_2_5M`.
- `model` (str): Имя модели для использования.
- `messages` (Messages): Список сообщений, представляющих контекст и запрос.
- `proxy` (str, optional): URL прокси-сервера, если необходимо. По умолчанию `None`.
- `return_conversation` (bool, optional): Флаг, указывающий, следует ли возвращать объект `JsonConversation`, содержащий информацию о сессии. По умолчанию `False`.
- `conversation` (JsonConversation, optional): Объект `JsonConversation`, содержащий информацию о текущей сессии. По умолчанию `None`.
- `**kwargs`: Дополнительные параметры, которые могут быть переданы.

**Как работает функция**:

1. **Генерация уникального идентификатора сессии**:
   - Если `conversation` равен `None`, генерируется уникальный идентификатор сессии `session_hash`. В противном случае используется существующий `session_hash` из объекта `conversation`.

2. **Возврат объекта `JsonConversation` (если требуется)**:
   - Если `return_conversation` равен `True`, функция возвращает объект `JsonConversation` с идентификатором сессии.

3. **Форматирование запроса**:
   - Если `conversation` равен `None`, формируется полный запрос `prompt` из списка сообщений `messages` с использованием функции `format_prompt`. В противном случае извлекается последнее сообщение пользователя из `messages` с использованием функции `get_last_user_message`.

4. **Подготовка HTTP-заголовков**:
   - Определяются необходимые HTTP-заголовки для запросов к API, включая `accept`, `content-type`, `origin`, `referer` и `user-agent`.

5. **Подготовка полезной нагрузки (payload) для запроса `predict`**:
   - Формируется JSON-полезная нагрузка `payload_predict` для запроса к API, содержащая текст запроса (`prompt`), идентификатор сессии (`session_hash`) и другие необходимые параметры.

6. **Отправка запроса `predict`**:
   - Отправляется POST-запрос к API (`cls.api_endpoint`) с использованием `aiohttp.ClientSession`.
   - Полученный ответ преобразуется в JSON и извлекаются данные.

7. **Подготовка данных для запроса `join`**:
   - Формируются данные `join_data` для запроса на присоединение к очереди обработки запросов.

8. **Отправка запроса `join`**:
   - Отправляется POST-запрос к URL `join_url` с данными `join_data`.
   - Из полученного ответа извлекается идентификатор события `event_id`.

9. **Подготовка к потоковой передаче данных**:
   - Формируется URL `url_data` для получения данных в потоковом режиме, включающий идентификатор сессии.
   - Определяются заголовки `headers_data` для запроса потоковых данных.

10. **Отправка запроса потоковых данных**:
    - Отправляется GET-запрос к `url_data` с заголовками `headers_data`.
    - В цикле построчно читается ответ от сервера:
        - Каждая строка декодируется из UTF-8.
        - Если строка начинается с `data: `, происходит попытка декодирования JSON-данных из этой строки.
        - Если декодирование успешно:
            - Проверяется наличие сообщения `msg` со значением `process_generating`, что указывает на стадию генерации.
            - Если сообщение присутствует и содержит данные `output`, извлекается сгенерированный текст.
            - Если текст начинается с `"Qwen is thinking..."`, возвращается объект `Reasoning` с этим текстом.
            - Иначе возвращается сгенерированный текст.
            - Обновляются переменные `yield_response_len` и `yield_response` для отслеживания уже выданной части текста.
            - Проверяется наличие сообщения `msg` со значением `process_completed`, что указывает на завершение генерации.
            - Если сообщение присутствует и содержит данные `output`, извлекается полный сгенерированный текст и возвращается.
        - Если декодирование JSON не удалось, в журнал (`debug.log`) записывается сообщение об ошибке.

**Внутренние функции**:

#### `generate_session_hash`

```python
def generate_session_hash():
    """Generate a unique session hash."""
    return str(uuid.uuid4()).replace('-', '')[:12]
```

**Описание**:
Внутренняя функция для генерации уникального идентификатора сессии.

**Как работает функция**:
1. Генерирует UUID (Universally Unique Identifier) с помощью `uuid.uuid4()`.
2. Преобразует UUID в строку.
3. Удаляет все символы `-` из строки.
4. Возвращает первые 12 символов полученной строки.

**Примеры**:

```python
session_hash = generate_session_hash()
print(session_hash)  # Пример: 1a2b3c4d5e6f