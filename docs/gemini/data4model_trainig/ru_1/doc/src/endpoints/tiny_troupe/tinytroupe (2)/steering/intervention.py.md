# Модуль `intervention.py`

## Обзор

Модуль `intervention.py` определяет класс `Intervention`, который предназначен для моделирования и выполнения вмешательств в симуляциях с использованием агентов (`TinyPerson`) и окружений (`TinyWorld`). Он позволяет задавать условия (preconditions) и эффекты (effects) для вмешательств, а также проверять, выполняются ли условия перед применением эффектов.

## Подробней

Этот модуль является частью системы, предназначенной для моделирования социального взаимодействия и влияния. Он предоставляет механизм для внесения изменений в поведение агентов или состояние окружения на основе определенных условий. `Intervention` может использоваться для моделирования различных сценариев, таких как образовательные вмешательства, социальные кампании или изменения в политике.

## Классы

### `Intervention`

**Описание**: Класс `Intervention` представляет собой вмешательство, которое может быть применено к целевым объектам (`TinyPerson`, `TinyWorld` или их списки) при выполнении заданных условий.

**Атрибуты**:
- `targets` (Union[TinyPerson, TinyWorld, List[TinyPerson], List[TinyWorld]]): Целевые объекты для вмешательства.
- `first_n` (int, optional): Количество первых взаимодействий, учитываемых в контексте. По умолчанию `None`.
- `last_n` (int, optional): Количество последних взаимодействий (самых недавних), учитываемых в контексте. По умолчанию `5`.
- `name` (str, optional): Имя вмешательства. Если не указано, генерируется автоматически.
- `text_precondition` (str, optional): Текстовое условие для вмешательства, интерпретируемое языковой моделью. По умолчанию `None`.
- `precondition_func` (function, optional): Функция-условие для вмешательства, оцениваемая кодом. Должна принимать целевые объекты в качестве аргумента и возвращать булево значение. По умолчанию `None`.
- `effect_func` (function, optional): Функция, определяющая эффект вмешательства. Должна принимать целевые объекты в качестве аргумента. По умолчанию `None`.
- `_last_text_precondition_proposition` (Proposition, optional): Последнее текстовое условие, проверенное с использованием `Proposition`. По умолчанию `None`.
- `_last_functional_precondition_check` (bool, optional): Результат последней проверки функционального условия. По умолчанию `None`.

**Методы**:
- `__init__(self, targets, first_n=None, last_n=5, name=None)`: Инициализирует объект вмешательства.
- `__call__(self)`: Вызывает метод `execute` для выполнения вмешательства.
- `execute(self)`: Выполняет вмешательство, проверяя условие и применяя эффект при его выполнении.
- `check_precondition(self)`: Проверяет, выполняется ли условие для вмешательства.
- `apply_effect(self)`: Применяет эффект вмешательства.
- `set_textual_precondition(self, text)`: Устанавливает текстовое условие для вмешательства.
- `set_functional_precondition(self, func)`: Устанавливает функциональное условие для вмешательства.
- `set_effect(self, effect_func)`: Устанавливает эффект вмешательства.
- `precondition_justification(self)`: Возвращает обоснование для выполнения условия вмешательства.

## Методы класса

### `__init__`

```python
def __init__(self, targets: Union[TinyPerson, TinyWorld, List[TinyPerson], List[TinyWorld]], 
                 first_n:int=None, last_n:int=5,
                 name: str = None):
```

**Назначение**: Инициализирует объект класса `Intervention`.

**Параметры**:
- `targets` (Union[TinyPerson, TinyWorld, List[TinyPerson], List[TinyWorld]]): Целевые объекты для вмешательства. Это может быть один агент, одно окружение или список агентов/окружений.
- `first_n` (int, optional): Количество первых взаимодействий, учитываемых в контексте. По умолчанию `None`.
- `last_n` (int, optional): Количество последних взаимодействий (самых недавних), учитываемых в контексте. По умолчанию `5`.
- `name` (str, optional): Имя вмешательства. Если не указано, генерируется автоматически.

**Как работает функция**:
- Функция инициализирует объект `Intervention`, сохраняя переданные целевые объекты, условия и эффекты.
- Она также инициализирует атрибуты для хранения текстовых и функциональных условий, а также эффекта вмешательства.
- Если имя не указано, генерируется уникальное имя с использованием `utils.fresh_id()`.

### `__call__`

```python
def __call__(self):
```

**Назначение**: Позволяет вызывать объект `Intervention` как функцию.

**Как работает функция**:
- При вызове объекта `Intervention` как функции, вызывается метод `execute`, который выполняет вмешательство.

### `execute`

```python
def execute(self):
```

**Назначение**: Выполняет вмешательство, проверяя условие и применяя эффект при его выполнении.

**Возвращает**:
- `bool`: `True`, если эффект вмешательства был применен, и `False` в противном случае.

**Как работает функция**:
- Сначала логируется отладочное сообщение о начале выполнения вмешательства.
- Затем вызывается метод `check_precondition` для проверки условия.
- Если условие выполняется, вызывается метод `apply_effect` для применения эффекта вмешательства.
- Логируется отладочное сообщение об успешном применении эффекта.
- Если условие не выполняется, логируется отладочное сообщение о том, что эффект не был применен.

### `check_precondition`

```python
def check_precondition(self):
```

**Назначение**: Проверяет, выполняется ли условие для вмешательства.

**Возвращает**:
- `bool`: `True`, если условие выполняется, и `False` в противном случае.

**Как работает функция**:
- Создается объект `Proposition` для проверки текстового условия с использованием языковой модели.
- Если задана функциональная проверка, вызывается функция `self.precondition_func` с целевыми объектами в качестве аргумента.
- Результаты проверки текстового и функционального условий объединяются логическим `and`.
- Сохраняются результаты последней проверки текстового и функционального условий.

### `apply_effect`

```python
def apply_effect(self):
```

**Назначение**: Применяет эффект вмешательства.

**Как работает функция**:
- Вызывает функцию `self.effect_func` с целевыми объектами в качестве аргумента.
- **Примечание**: Этот метод не проверяет условие, поэтому его следует вызывать только после успешной проверки условия с помощью `check_precondition`.

### `set_textual_precondition`

```python
def set_textual_precondition(self, text):
```

**Назначение**: Устанавливает текстовое условие для вмешательства.

**Параметры**:
- `text` (str): Текст условия, который будет интерпретироваться языковой моделью.

**Возвращает**:
- `self`: Объект `Intervention` для возможности chaining.

**Как работает функция**:
- Устанавливает атрибут `text_precondition` равным переданному тексту.

### `set_functional_precondition`

```python
def set_functional_precondition(self, func):
```

**Назначение**: Устанавливает функциональное условие для вмешательства.

**Параметры**:
- `func` (function): Функция, которая будет вызываться для проверки условия. Должна принимать целевые объекты в качестве аргумента и возвращать булево значение.

**Возвращает**:
- `self`: Объект `Intervention` для возможности chaining.

**Как работает функция**:
- Устанавливает атрибут `precondition_func` равным переданной функции.

### `set_effect`

```python
def set_effect(self, effect_func):
```

**Назначение**: Устанавливает эффект вмешательства.

**Параметры**:
- `effect_func` (function): Функция, которая будет вызываться для применения эффекта. Должна принимать целевые объекты в качестве аргумента.

**Возвращает**:
- `self`: Объект `Intervention` для возможности chaining.

**Как работает функция**:
- Устанавливает атрибут `effect_func` равным переданной функции.

### `precondition_justification`

```python
def precondition_justification(self):
```

**Назначение**: Возвращает обоснование для выполнения условия вмешательства.

**Возвращает**:
- `str`: Текстовое обоснование выполнения условия.

**Как работает функция**:
- Если было проверено текстовое условие, возвращает обоснование из объекта `Proposition`.
- Если было проверено функциональное условие и оно выполнилось, возвращает сообщение об этом.
- В противном случае возвращает сообщение о том, что условия не выполнены.

## Примеры

```python
from tinytroupe.agent import TinyPerson
from tinytroupe.environment import TinyWorld
from tinytroupe.steering.intervention import Intervention

# Создание агента и окружения
agent = TinyPerson(name="Alice")
world = TinyWorld(name="MyWorld")

# Пример 1: Вмешательство с текстовым условием и эффектом
def change_agent_name(targets):
    for target in targets:
        if isinstance(target, TinyPerson):
            target.name = "Bob"

intervention1 = Intervention(targets=[agent], last_n=10, name="ChangeNameIntervention")
intervention1.set_textual_precondition("The agent is named Alice").set_effect(change_agent_name)

# Выполнение вмешательства
intervention1.execute()
print(agent.name)  # Вывод: Bob

# Пример 2: Вмешательство с функциональным условием
def is_agent_named_alice(targets):
    for target in targets:
        if isinstance(target, TinyPerson):
            return target.name == "Alice"
    return False

intervention2 = Intervention(targets=[agent], name="CheckNameIntervention")
intervention2.set_functional_precondition(is_agent_named_alice).set_effect(lambda x: None)

# Проверка условия
condition_met = intervention2.check_precondition()
print(condition_met)  # Вывод: False