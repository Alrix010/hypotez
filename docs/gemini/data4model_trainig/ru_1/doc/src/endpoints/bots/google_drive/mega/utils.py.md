# Модуль утилит для работы с Mega API в Google Drive
## Обзор

Модуль содержит набор функций для шифрования, дешифрования, кодирования и декодирования данных, используемых при взаимодействии с API Mega в Google Drive.
Этот модуль предоставляет утилиты для преобразования данных между различными форматами, такими как целые числа, строки, массивы 32-битных целых чисел и base64url. 
Также содержит функции для шифрования и дешифрования данных с использованием алгоритма AES в режиме CBC.
Модуль включает в себя функции для работы с чанками (chunks) данных, что необходимо при передаче больших файлов.

## Подробней

Модуль предназначен для облегчения работы с API Mega, предоставляя удобные функции для преобразования данных и шифрования/дешифрования.
Он используется для подготовки данных перед отправкой на сервер Mega и обработки данных, полученных от сервера.

## Функции

### `a32_to_str`

```python
def a32_to_str(a) -> str:
    """Преобразует массив 32-битных целых чисел в строку байтов.

    Args:
        a (list[int]): Массив 32-битных целых чисел.

    Returns:
        str: Строка байтов, полученная из массива целых чисел.

    Примеры:
        >>> a32_to_str([1, 2, 3])
        b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03'
    """
```
**Назначение**: Функция преобразует массив 32-битных целых чисел в строку байтов, используя структуру данных `struct`.

**Параметры**:
- `a` (list[int]): Массив 32-битных целых чисел, который необходимо преобразовать в строку.

**Возвращает**:
- `str`: Строка байтов, полученная из массива целых чисел.

**Как работает функция**:
- Функция использует модуль `struct` для упаковки каждого 32-битного целого числа из входного массива `a` в строку байтов.
- Формат `>%dI` указывает, что каждое число должно быть упаковано как 32-битное целое число в сетевом порядке байтов (big-endian).
- Функция возвращает строку байтов, полученную в результате упаковки всех чисел из массива.

### `aes_cbc_encrypt`

```python
def aes_cbc_encrypt(data, key) -> bytes:
    """Шифрует данные с использованием алгоритма AES в режиме CBC.

    Args:
        data (bytes): Данные для шифрования.
        key (bytes): Ключ шифрования.

    Returns:
        bytes: Зашифрованные данные.

    Примеры:
        >>> key = b'\\x00' * 16
        >>> data = b'test data 1234'
        >>> encrypted_data = aes_cbc_encrypt(data, key)
    """
```

**Назначение**: Функция шифрует данные с использованием алгоритма AES (Advanced Encryption Standard) в режиме CBC (Cipher Block Chaining).

**Параметры**:
- `data` (bytes): Данные, которые необходимо зашифровать.
- `key` (bytes): Ключ шифрования, который должен быть длиной 16, 24 или 32 байта (для AES-128, AES-192 или AES-256 соответственно).

**Возвращает**:
- `bytes`: Зашифрованные данные.

**Как работает функция**:
- Функция создает объект шифрования AES с использованием предоставленного ключа и режима CBC.
- Начальный вектор (IV) устанавливается как 16 нулевых байтов.
- Функция шифрует входные данные и возвращает зашифрованные данные.

### `aes_cbc_encrypt_a32`

```python
def aes_cbc_encrypt_a32(data, key) -> list[int]:
    """Шифрует данные (представленные в виде массива 32-битных целых чисел) с использованием AES в режиме CBC.

    Args:
        data (list[int]): Данные для шифрования в виде массива 32-битных целых чисел.
        key (list[int]): Ключ шифрования в виде массива 32-битных целых чисел.

    Returns:
        list[int]: Зашифрованные данные в виде массива 32-битных целых чисел.

    Примеры:
        >>> key = [0] * 4
        >>> data = [1, 2, 3]
        >>> encrypted_data = aes_cbc_encrypt_a32(data, key)
    """
```

**Назначение**: Функция шифрует данные, представленные в виде массива 32-битных целых чисел, используя алгоритм AES в режиме CBC.

**Параметры**:
- `data` (list[int]): Данные для шифрования в виде массива 32-битных целых чисел.
- `key` (list[int]): Ключ шифрования в виде массива 32-битных целых чисел.

**Возвращает**:
- `list[int]`: Зашифрованные данные в виде массива 32-битных целых чисел.

**Как работает функция**:
- Функция сначала преобразует входные массивы `data` и `key` из массивов 32-битных целых чисел в строки байтов с помощью функции `a32_to_str`.
- Затем она шифрует полученную строку байтов с помощью функции `aes_cbc_encrypt`, используя ключ, также преобразованный в строку байтов.
- После этого зашифрованные данные (в виде строки байтов) преобразуются обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.
- Функция возвращает зашифрованные данные в виде массива 32-битных целых чисел.

### `str_to_a32`

```python
def str_to_a32(b) -> tuple[int]:
    """Преобразует строку байтов в массив 32-битных целых чисел.

    Args:
        b (bytes): Строка байтов для преобразования.

    Returns:
        tuple[int]: Массив 32-битных целых чисел, полученный из строки байтов.

    Примеры:
        >>> str_to_a32(b'\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02')
        (1, 2)
    """
```

**Назначение**: Функция преобразует строку байтов в массив 32-битных целых чисел.

**Параметры**:
- `b` (bytes): Строка байтов, которую необходимо преобразовать в массив целых чисел.

**Возвращает**:
- `tuple[int]`: Массив 32-битных целых чисел, полученный из строки байтов.

**Как работает функция**:
- Функция сначала проверяет, является ли длина входной строки `b` кратной 4. Если нет, она добавляет необходимое количество нулевых байтов для дополнения строки до длины, кратной 4.
- Затем, если входные данные являются строкой (str), они преобразуются в байты с использованием кодировки UTF-8.
- Функция использует модуль `struct` для распаковки строки байтов в массив 32-битных целых чисел.
- Формат `>%dI` указывает, что каждый набор из 4 байтов должен быть распакован как 32-битное целое число в сетевом порядке байтов (big-endian).
- Функция возвращает массив целых чисел, полученный в результате распаковки строки байтов.

### `mpi2int`

```python
def mpi2int(s) -> int:
    """Преобразует строку, представляющую целое число в формате MPI (Multi-Precision Integer), в целое число Python.

    Args:
        s (bytes): Строка в формате MPI.

    Returns:
        int: Целое число, полученное из строки MPI.

    Примеры:
        >>> mpi2int(b'\\x00\\x02\\x12\\x34')
        4660
    """
```

**Назначение**: Функция преобразует строку, представляющую целое число в формате MPI (Multi-Precision Integer), в целое число Python.

**Параметры**:
- `s` (bytes): Строка в формате MPI.

**Возвращает**:
- `int`: Целое число, полученное из строки MPI.

**Как работает функция**:
- Функция извлекает данные, начиная с третьего байта строки `s` (индекс 2), и преобразует их в шестнадцатеричный вид с помощью `binascii.hexlify`.
- Затем она преобразует полученную шестнадцатеричную строку в целое число с основанием 16.
- Функция возвращает полученное целое число.

### `aes_cbc_decrypt`

```python
def aes_cbc_decrypt(data, key) -> bytes:
    """Расшифровывает данные, зашифрованные алгоритмом AES в режиме CBC.

    Args:
        data (bytes): Зашифрованные данные.
        key (bytes): Ключ шифрования.

    Returns:
        bytes: Расшифрованные данные.

    Примеры:
        >>> key = b'\\x00' * 16
        >>> data = b'test data 1234'
        >>> encrypted_data = aes_cbc_encrypt(data, key)
        >>> decrypted_data = aes_cbc_decrypt(encrypted_data, key)
        >>> decrypted_data == data
        True
    """
```

**Назначение**: Функция расшифровывает данные, зашифрованные с использованием алгоритма AES в режиме CBC (Cipher Block Chaining).

**Параметры**:
- `data` (bytes): Зашифрованные данные, которые необходимо расшифровать.
- `key` (bytes): Ключ шифрования, который должен быть длиной 16, 24 или 32 байта (для AES-128, AES-192 или AES-256 соответственно).

**Возвращает**:
- `bytes`: Расшифрованные данные.

**Как работает функция**:
- Функция создает объект дешифрования AES с использованием предоставленного ключа и режима CBC.
- Начальный вектор (IV) устанавливается как 16 нулевых байтов.
- Функция расшифровывает входные данные и возвращает расшифрованные данные.

### `aes_cbc_decrypt_a32`

```python
def aes_cbc_decrypt_a32(data, key) -> list[int]:
    """Расшифровывает данные (представленные в виде массива 32-битных целых чисел), зашифрованные алгоритмом AES в режиме CBC.

    Args:
        data (list[int]): Зашифрованные данные в виде массива 32-битных целых чисел.
        key (list[int]): Ключ шифрования в виде массива 32-битных целых чисел.

    Returns:
        list[int]: Расшифрованные данные в виде массива 32-битных целых чисел.

    Примеры:
        >>> key = [0] * 4
        >>> data = [1, 2, 3]
        >>> encrypted_data = aes_cbc_encrypt_a32(data, key)
        >>> decrypted_data = aes_cbc_decrypt_a32(encrypted_data, key)
    """
```

**Назначение**: Функция расшифровывает данные, представленные в виде массива 32-битных целых чисел, используя алгоритм AES в режиме CBC.

**Параметры**:
- `data` (list[int]): Зашифрованные данные в виде массива 32-битных целых чисел.
- `key` (list[int]): Ключ шифрования в виде массива 32-битных целых чисел.

**Возвращает**:
- `list[int]`: Расшифрованные данные в виде массива 32-битных целых чисел.

**Как работает функция**:
- Функция сначала преобразует входные массивы `data` и `key` из массивов 32-битных целых чисел в строки байтов с помощью функции `a32_to_str`.
- Затем она расшифровывает полученную строку байтов с помощью функции `aes_cbc_decrypt`, используя ключ, также преобразованный в строку байтов.
- После этого расшифрованные данные (в виде строки байтов) преобразуются обратно в массив 32-битных целых чисел с помощью функции `str_to_a32`.
- Функция возвращает расшифрованные данные в виде массива 32-битных целых чисел.

### `base64urldecode`

```python
def base64urldecode(data) -> bytes:
    """Декодирует строку в кодировке base64url.

    Args:
        data (str): Строка в кодировке base64url.

    Returns:
        bytes: Декодированная строка.

    Примеры:
        >>> base64urldecode('AQAB')
        b'\\x01\\x00\\x01'
    """
```

**Назначение**: Функция декодирует строку, закодированную в формате Base64 URL.

**Параметры**:
- `data` (str): Строка, закодированная в формате Base64 URL.

**Возвращает**:
- `bytes`: Декодированная строка в виде байтов.

**Как работает функция**:
1. Добавляет символы '==' для приведения длины строки к кратной 4, если это необходимо для корректной работы стандартного декодировщика Base64.
2. Заменяет символы '-', '_' и ',' на '+', '/' и '' соответственно, чтобы преобразовать строку из формата Base64 URL в стандартный формат Base64.
3. Декодирует полученную строку Base64 с помощью `base64.b64decode` и возвращает результат в виде байтов.

### `base64_to_a32`

```python
def base64_to_a32(s) -> tuple[int]:
    """Декодирует строку base64url и преобразует результат в массив 32-битных целых чисел.

    Args:
        s (str): Строка в кодировке base64url.

    Returns:
        tuple[int]: Массив 32-битных целых чисел, полученный из декодированной строки.

    Примеры:
        >>> base64_to_a32('AQAB')
        (16777217,)
    """
```

**Назначение**: Функция декодирует строку, закодированную в формате Base64 URL, и преобразует результат в массив 32-битных целых чисел.

**Параметры**:
- `s` (str): Строка, закодированная в формате Base64 URL.

**Возвращает**:
- `tuple[int]`: Массив 32-битных целых чисел, полученный из декодированной строки.

**Как работает функция**:
1. Декодирует входную строку `s` из формата Base64 URL в строку байтов с помощью функции `base64urldecode`.
2. Преобразует полученную строку байтов в массив 32-битных целых чисел с помощью функции `str_to_a32`.
3. Возвращает полученный массив целых чисел.

### `base64urlencode`

```python
def base64urlencode(data) -> str:
    """Кодирует строку байтов в base64url.

    Args:
        data (bytes): Строка байтов для кодирования.

    Returns:
        str: Строка в кодировке base64url.

    Примеры:
        >>> base64urlencode(b'\\x01\\x00\\x01')
        'AQAB'
    """
```

**Назначение**: Функция кодирует строку байтов в формат Base64 URL.

**Параметры**:
- `data` (bytes): Строка байтов, которую необходимо закодировать.

**Возвращает**:
- `str`: Строка, закодированная в формате Base64 URL.

**Как работает функция**:
1. Кодирует входную строку байтов `data` в формат Base64 с помощью `base64.b64encode` и декодирует результат в строку UTF-8.
2. Заменяет символы '+', '/' и '=' на '-', '_' и '' соответственно, чтобы преобразовать строку из стандартного формата Base64 в формат Base64 URL.
3. Возвращает полученную строку в формате Base64 URL.

### `a32_to_base64`

```python
def a32_to_base64(a) -> str:
    """Преобразует массив 32-битных целых чисел в строку base64url.

    Args:
        a (list[int]): Массив 32-битных целых чисел.

    Returns:
        str: Строка в кодировке base64url, полученная из массива целых чисел.

    Примеры:
        >>> a32_to_base64([1])
        'AAAAAQ'
    """
```

**Назначение**: Функция преобразует массив 32-битных целых чисел в строку, закодированную в формате Base64 URL.

**Параметры**:
- `a` (list[int]): Массив 32-битных целых чисел, который необходимо преобразовать в строку Base64 URL.

**Возвращает**:
- `str`: Строка, закодированная в формате Base64 URL, полученная из массива целых чисел.

**Как работает функция**:
1. Преобразует входной массив 32-битных целых чисел `a` в строку байтов с помощью функции `a32_to_str`.
2. Кодирует полученную строку байтов в формат Base64 URL с помощью функции `base64urlencode`.
3. Возвращает полученную строку в формате Base64 URL.

### `get_chunks`

```python
def get_chunks(size) -> dict[int, int]:
    """Разбивает размер файла на чанки (chunks) для передачи.

    Args:
        size (int): Размер файла в байтах.

    Returns:
        dict[int, int]: Словарь, где ключ - начальная позиция чанка, значение - размер чанка.

    Примеры:
        >>> get_chunks(1024)
        {0: 1024}
    """
```

**Назначение**: Функция разбивает размер файла на чанки (chunks) для передачи, определяя размер каждого чанка и его начальную позицию.

**Параметры**:
- `size` (int): Размер файла в байтах, который необходимо разбить на чанки.

**Возвращает**:
- `dict[int, int]`: Словарь, где ключ - начальная позиция чанка, а значение - размер чанка в байтах.

**Как работает функция**:
1. Инициализирует пустой словарь `chunks` для хранения информации о чанках.
2. Устанавливает начальные значения для позиции `p`, предыдущей позиции `pp` и итератора `i`.
3. Создает первые чанки размером, кратным `0x20000`, пока `i` не превысит 8 или `p` не станет достаточно близким к `size`.
4. Создает оставшиеся чанки размером `0x100000` до тех пор, пока `p` не достигнет `size`.
5. Устанавливает размер последнего чанка равным оставшейся части файла.
6. Если последний чанк имеет размер 0, удаляет его из словаря.
7. Возвращает словарь `chunks`, содержащий информацию о чанках.