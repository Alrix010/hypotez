Как использовать этот блок кода
=========================================================================================

Описание
-------------------------
Данный код реализует API для общения с языковой моделью, используя библиотеку `g4f`. Он включает в себя функциональность для обработки запросов, формирования сообщений, получения результатов поиска в интернете и управления прокси-серверами. Код также поддерживает различные "джейлбрейки" (jailbreak), которые изменяют поведение языковой модели.

Шаги выполнения
-------------------------
1. **Инициализация API**:
   - Класс `Backend_Api` инициализируется с Flask-приложением и конфигурацией.
   - Определяются маршруты API, в данном случае `/backend-api/v2/conversation`, который связан с методом `_conversation`.
   - Если включено использование автоматических прокси, запускается поток для обновления списка рабочих прокси-серверов.

2. **Обработка запроса на разговор (`_conversation`)**:
   - Извлекаются параметры из JSON-запроса, такие как `streaming` (использовать ли потоковую передачу), `jailbreak` (название джейлбрейка) и `model` (используемая модель).
   - Формируются сообщения для языковой модели с помощью функции `build_messages`.
   - Генерируется ответ от языковой модели с использованием `ChatCompletion.create` из библиотеки `g4f`.
   - Возвращается потоковый ответ (если `streaming` включен) или обычный ответ.
   - В случае ошибки возвращается сообщение об ошибке с кодом 400.

3. **Формирование сообщений (`build_messages`)**:
   - Извлекается история разговора, флаг доступа в интернет и промпт из JSON-запроса.
   - Формируется системное сообщение, включающее текущую дату и язык ответа.
   - Добавляется история разговора, результаты поиска (если разрешен доступ в интернет) и инструкции джейлбрейка (если выбран джейлбрейк).
   - Ограничивается размер истории разговора для избежания ошибок, связанных с количеством токенов.

4. **Получение результатов поиска (`fetch_search_results`)**:
   - Выполняется поиск в интернете с использованием API `ddg-api.herokuapp.com`.
   - Формируется список результатов поиска, включающий сниппеты и ссылки.

5. **Генерация потока (`generate_stream`)**:
   - Если включен джейлбрейк, проверяется, успешно ли он применен, и возвращается соответствующий ответ.
   - Если джейлбрейк не включен, возвращается обычный потоковый ответ.

6. **Проверка успешности/неудачи джейлбрейка (`response_jailbroken_success`, `response_jailbroken_failed`)**:
   - Проверяется, содержит ли ответ признаки успешного или неудачного применения джейлбрейка.

7. **Определение языка ответа (`set_response_language`)**:
   - Определяется язык промпта с помощью библиотеки `googletrans`.
   - Формируется строка, указывающая языковой модели, на каком языке отвечать.

8. **Проверка джейлбрейка (`isJailbreak`)**:
   - Если выбран джейлбрейк, возвращаются соответствующие инструкции из словаря `special_instructions`.

Пример использования
-------------------------

```python
from flask import Flask, request, jsonify
from server.backend import Backend_Api
import json

app = Flask(__name__)

# Загрузка конфигурации
config_file = 'config.json'
try:
    with open(config_file, 'r', encoding='utf-8') as f:
        config = json.load(f)
except FileNotFoundError:
    print(f"Error: The file {config_file} was not found.")
    exit()
except json.JSONDecodeError:
    print(f"Error: The file {config_file} contains invalid JSON.")
    exit()

# Инициализация API
backend_api = Backend_Api(app, config)

# Регистрация маршрутов
with app.test_request_context():
    for route, route_config in backend_api.routes.items():
        endpoint_name = route_config['function'].__name__
        app.add_url_rule(route, endpoint=endpoint_name, view_func=route_config['function'], methods=route_config['methods'])

# Пример запроса
@app.route('/test', methods=['POST'])
def test():
    # Пример JSON-запроса
    data = {
        "stream": True,
        "jailbreak": "Default",
        "model": "gpt-3.5-turbo",
        "meta": {
            "content": {
                "conversation": [],
                "internet_access": False,
                "parts": [{"content": "Hello, how are you?", "role": "user"}]
            }
        }
    }
    request.json = data  # Эмуляция JSON-запроса
    return backend_api._conversation()

if __name__ == '__main__':
    app.run(debug=True, port=5000)