Как использовать этот блок кода
=========================================================================================

Описание
-------------------------
Этот код предназначен для взаимодействия с сервисом Poe для получения ответов от различных моделей, таких как GPT-3.5-turbo или Llama-2. Он использует Selenium WebDriver для автоматизации действий в браузере, внедряет JavaScript для перехвата сообщений WebSocket и извлекает ответы модели.

Шаги выполнения
-------------------------
1. **Подготовка**:
   - Импортируются необходимые библиотеки, такие как `time`, `WebDriver`, `By`, `WebDriverWait` и `expected_conditions`.
   - Определяются модели, доступные в Poe, и их соответствующие имена.

2. **Инициализация**:
   - Функция `create_completion` принимает параметры, такие как `model`, `messages` (список сообщений для отправки), `stream` (флаг для потоковой передачи ответов), `proxy`, `webdriver`, `user_data_dir` и `headless`.
   - Если `model` не указана, устанавливается значение по умолчанию "gpt-3.5-turbo".
   - Проверяется, поддерживается ли указанная модель. Если нет, выбрасывается исключение `ValueError`.
   - Форматируется `prompt` из списка `messages` с использованием функции `format_prompt`.

3. **Создание сессии WebDriver**:
   - Создается экземпляр `WebDriverSession` с использованием переданного `webdriver`, `user_data_dir`, `headless` и `proxy`.
   - Открывается сессия WebDriver с помощью контекстного менеджера `with session as driver:`.

4. **Внедрение JavaScript**:
   - Внедряется JavaScript-код для перехвата сообщений WebSocket. Этот код переопределяет класс `WebSocket` и добавляет прослушиватель событий `message`, который извлекает данные из сообщений и сохраняет их в глобальных переменных `window._message` и `window._last_message`.

5. **Навигация и ожидание**:
   - Выполняется переход по URL, соответствующему выбранной модели: `f"{cls.url}/{models[model]['name']}"`.
   - Используется `WebDriverWait` для ожидания появления элемента `textarea` на странице. Если элемент не найден, выполняется повторное открытие браузера для повторной аутентификации.

6. **Взаимодействие с элементами страницы**:
   - Функция `element_send_text` используется для ввода текста `prompt` в элемент `textarea`.
   - Выполняется клик по кнопке отправки сообщения.

7. **Извлечение ответа**:
   - Выполняется JavaScript-код для извлечения части ответа из `window._message`. Если ответ изменился с момента последнего извлечения, возвращается новая часть. Если ответ завершен, возвращается `null`. Если ответа нет, возвращается пустая строка `''`.
   - В цикле `while True:` извлекаются части ответа, пока не будет получен `null` или непустая строка.
   - Каждая полученная часть ответа передается через `yield chunk`, обеспечивая потоковую передачу ответа.

Пример использования
-------------------------

```python
from src.endpoints.gpt4free.g4f.Provider.not_working import Poe
from src.webdriver import Driver, Firefox
from typing import List, Dict

# Пример использования
messages: List[Dict[str, str]] = [{"role": "user", "content": "Напиши короткий стих о весне"}]
model: str = "gpt-3.5-turbo"
stream: bool = True
webdriver = Driver(browser=Firefox).instance # передаем инстанс webdriver

try:
    for chunk in Poe.create_completion(model=model, messages=messages, stream=stream, webdriver=webdriver):
        print(chunk, end="")
except Exception as e:
    print(f"Произошла ошибка: {e}")
finally:
    if webdriver:
        webdriver.quit()