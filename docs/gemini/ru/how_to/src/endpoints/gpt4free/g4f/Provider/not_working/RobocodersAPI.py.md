### Как использовать этот блок кода
=========================================================================================

Описание
-------------------------
Данный код представляет собой класс `RobocodersAPI`, который является асинхронным провайдером для взаимодействия с API Robocoders AI. Он предназначен для создания чат-сессий с использованием различных агентов (моделей), таких как `GeneralCodingAgent`, `RepoAgent` и `FrontEndAgent`. Класс предоставляет методы для получения или создания токена доступа и идентификатора сессии, отправки запросов к API для получения ответов и управления кэшированием данных для повторного использования токенов и сессий.

Шаги выполнения
-------------------------
1. **Инициализация**: Создается экземпляр класса `RobocodersAPI`.
2. **Получение или создание токена и сессии**: 
   - Функция пытается получить access token и session ID из кэша.
   - Если в кэше нет или они не валидны, функция запрашивает новые access token и session ID с использованием методов `_fetch_and_cache_access_token` и `_create_and_cache_session`.
3. **Формирование запроса**: Подготавливаются заголовки запроса с использованием полученного access token, формируется JSON-данные, включающие `session_id`, `prompt` (сообщение пользователя) и `agent` (модель).
4. **Отправка запроса к API**: Отправляется POST-запрос к API Robocoders AI с использованием `aiohttp.ClientSession`.
5. **Обработка ответа**:
   - Функция проверяет статус ответа и обрабатывает различные ошибки, такие как неавторизованный доступ (401), ошибки валидации (422) и серверные ошибки (500+).
   - Если ответ успешен (200), функция начинает асинхронно читать содержимое ответа построчно.
   - Каждая строка декодируется из байтов в строку, и извлекается сообщение из полей `'args.content'` или `'message'` в JSON-ответе.
   - Если сообщение извлечено, оно возвращается как часть асинхронного генератора.
   - Проверяется, достигнут ли лимит ресурсов, и если требуется продолжение диалога, автоматически отправляется запрос на продолжение.
6. **Кэширование данных**: Access token и session ID сохраняются в кэш для последующего использования.
7. **Очистка кэша**: В случае ошибки авторизации или других проблем, кэш может быть очищен.

Пример использования
-------------------------

```python
import asyncio
from src.endpoints.gpt4free.g4f.Provider.not_working.RobocodersAPI import RobocodersAPI
from src.endpoints.gpt4free.g4f.typing import Messages

async def main():
    model = 'GeneralCodingAgent'
    messages: Messages = [{"role": "user", "content": "Напиши функцию на Python, которая вычисляет факториал числа."}]
    proxy = None

    try:
        async for message in RobocodersAPI.create_async_generator(model=model, messages=messages, proxy=proxy):
            print(message, end="")
    except Exception as e:
        print(f"Ошибка: {e}")

if __name__ == "__main__":
    asyncio.run(main())