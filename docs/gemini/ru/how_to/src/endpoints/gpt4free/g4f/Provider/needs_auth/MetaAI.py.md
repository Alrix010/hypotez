### Как использовать класс `MetaAI` для взаимодействия с Meta AI
=========================================================================================

Описание
-------------------------
Класс `MetaAI` предоставляет асинхронный интерфейс для взаимодействия с Meta AI. Он позволяет отправлять текстовые запросы и получать ответы, включая текст и изображения.

Шаги выполнения
-------------------------
1. **Инициализация класса**:
   - Создайте экземпляр класса `MetaAI` с использованием `proxy` и `connector` для настройки прокси и параметров соединения.
   - Если прокси не требуется, можно оставить значения по умолчанию (`None`).

2. **Обновление cookies (опционально)**:
   - Если необходимо, обновите cookies, вызвав метод `update_cookies`.
   - Этот метод отправляет запрос на главную страницу Meta AI и извлекает необходимые значения `lsd`, `dtsg` и cookies.

3. **Получение access token (опционально)**:
   - Если необходимо, получите или обновите access token, вызвав метод `update_access_token`.
   - Этот метод отправляет запрос для получения нового токена доступа, необходимого для выполнения определенных действий.

4. **Отправка запроса и получение ответа**:
   - Используйте метод `prompt` для отправки текстового запроса в Meta AI.
   - Метод `prompt` принимает текстовое сообщение и возвращает асинхронный генератор, который выдает части ответа, включая текст и изображения.

5. **Обработка ответа**:
   - Итерируйтесь по асинхронному генератору, возвращаемому методом `prompt`, чтобы получить части ответа.
   - Обрабатывайте каждую часть ответа, проверяя, является ли она текстовым фрагментом или изображением.

6. **Получение источников (опционально)**:
   - Если в ответе есть `fetch_id`, используйте метод `fetch_sources` для получения списка источников, связанных с ответом.
   - Этот метод возвращает объект `Sources`, содержащий список ссылок на источники.

Пример использования
-------------------------

```python
import asyncio

from src.endpoints.gpt4free.g4f.Provider.needs_auth.MetaAI import MetaAI

async def main():
    # Инициализация класса MetaAI
    meta_ai = MetaAI()

    try:
        # Отправка запроса и получение ответа
        async for chunk in meta_ai.prompt("Напиши стихотворение о космосе."):
            print(chunk, end="")  # Вывод каждой части ответа
        
    except Exception as e:
        print(f"Произошла ошибка: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

### Как использовать класс `Sources` для представления списка источников
=========================================================================================

Описание
-------------------------
Класс `Sources` предназначен для хранения и представления списка источников, каждый из которых содержит заголовок и ссылку.

Шаги выполнения
-------------------------
1. **Создание экземпляра класса `Sources`**:
   - Создайте экземпляр класса `Sources`, передав в конструктор список словарей, где каждый словарь содержит ключи `'title'` и `'link'`.

2. **Получение строкового представления списка источников**:
   - Используйте метод `__str__` для получения строкового представления списка источников.
   - Этот метод форматирует список источников в виде Markdown-ссылок, разделенных переносами строк.

Пример использования
-------------------------

```python
from src.endpoints.gpt4free.g4f.Provider.needs_auth.MetaAI import Sources

# Создание списка источников
link_list = [
    {"title": "Wikipedia", "link": "https://www.wikipedia.org/"},
    {"title": "Google", "link": "https://www.google.com/"}
]

# Создание экземпляра класса Sources
sources = Sources(link_list)

# Получение строкового представления списка источников
print(sources)
```

### Как использовать функцию `generate_offline_threading_id` для генерации идентификатора треда
=========================================================================================

Описание
-------------------------
Функция `generate_offline_threading_id` генерирует уникальный идентификатор треда, который можно использовать для отслеживания сообщений в оффлайн-режиме.

Шаги выполнения
-------------------------
1. **Вызов функции**:
   - Вызовите функцию `generate_offline_threading_id` без аргументов.

2. **Получение идентификатора**:
   - Функция вернет строковый идентификатор треда, который можно использовать для дальнейшей обработки.

Пример использования
-------------------------

```python
from src.endpoints.gpt4free.g4f.Provider.needs_auth.MetaAI import generate_offline_threading_id

# Генерация идентификатора треда
threading_id = generate_offline_threading_id()

# Вывод идентификатора
print(f"Generated threading ID: {threading_id}")