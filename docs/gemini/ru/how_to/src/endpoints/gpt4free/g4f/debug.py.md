Как использовать этот блок кода
=========================================================================================

Описание
-------------------------
Этот блок кода предназначен для отладки и логирования в библиотеке `g4f`. Он включает в себя функции для логирования сообщений и ошибок, а также настройки для управления логированием и проверкой версии.

Шаги выполнения
-------------------------
1. **Импорт необходимых модулей**:
   - Импортируется модуль `sys` для вывода ошибок в стандартный поток ошибок.
   - Импортируются типы `Callable`, `List`, `Optional`, `Any` из модуля `typing` для аннотации типов.

2. **Определение глобальных переменных**:
   - `logging`: Флаг, определяющий, включено ли логирование. По умолчанию `False`.
   - `version_check`: Флаг, определяющий, нужно ли проверять версию. По умолчанию `True`.
   - `version`: Переменная для хранения версии. По умолчанию `None`.
   - `log_handler`: Функция, используемая для логирования сообщений. По умолчанию `print`. Может быть изменена на другую функцию для более сложного логирования.
   - `logs`: Список для хранения логов. По умолчанию пустой список.

3. **Функция `log`**:
   - Принимает произвольное количество аргументов `*text` и опциональный аргумент `file`.
   - Если логирование включено (`logging is True`), вызывает функцию `log_handler` с переданными аргументами.

4. **Функция `error`**:
   - Принимает произвольное количество аргументов `*error` и опциональный аргумент `name`.
   - Преобразует каждый элемент `error` в строку. Если элемент не является строкой, формирует строку с именем типа элемента (или `name`, если указано) и самим элементом.
   - Вызывает функцию `log` с преобразованными сообщениями об ошибках и `file=sys.stderr` для вывода в стандартный поток ошибок.

Пример использования
-------------------------

```python
import sys
from typing import Callable, List, Optional, Any

logging: bool = False
version_check: bool = True
version: Optional[str] = None
log_handler: Callable = print
logs: List[str] = []

def log(*text: Any, file: Optional[Any] = None) -> None:
    """Log a message if logging is enabled."""
    if logging:
        log_handler(*text, file=file)

def error(*error: Any, name: Optional[str] = None) -> None:
    """Log an error message to stderr."""
    error = [e if isinstance(e, str) else f"{type(e).__name__ if name is None else name}: {e}" for e in error]
    log(*error, file=sys.stderr)

# Включение логирования
logging = True

# Пример использования функции log
log("Сообщение для логирования")  # Выведет: Сообщение для логирования

# Пример использования функции error
try:
    raise ValueError("Некорректное значение")
except ValueError as e:
    error("Произошла ошибка:", e)  # Выведет в stderr: Произошла ошибка: ValueError: Некорректное значение

# Изменение обработчика логов
def custom_log_handler(*text: Any, file: Optional[Any] = None) -> None:
    message = " ".join(map(str, text))
    if file == sys.stderr:
        print(f"ОШИБКА: {message}")
    else:
        print(f"ЛОГ: {message}")

log_handler = custom_log_handler

log("Новое сообщение для логирования")  # Выведет: ЛОГ: Новое сообщение для логирования
error("Критическая ошибка")  # Выведет в stderr: ОШИБКА: Критическая ошибка