## Как использовать этот блок кода
=========================================================================================

Описание
-------------------------
Модуль `file.py` предоставляет набор инструментов для работы с файлами и директориями.  
Он включает функции для чтения, записи, обработки больших файлов с помощью генераторов, рекурсивного поиска и фильтрации файлов, а также удаления BOM (Byte Order Mark) из текстовых файлов.

Шаги выполнения
-------------------------
1. **Импорт модуля `file.py`:** Импортируйте модуль `file.py` в ваш скрипт. 
2. **Использование функций:** Выберите нужную функцию из модуля `file.py` и вызовите ее с необходимыми аргументами.
3. **Обработка результатов:**  Обработайте результат, возвращенный функцией.  Это может быть строка, список строк, генератор или `None` в случае ошибки.

Пример использования
-------------------------

```python
from src.utils.file import save_text_file, read_text_file_generator

# Сохранение данных в файл
data = "Пример текста для записи в файл."
file_path = "output.txt"
save_text_file(data, file_path)

# Чтение файла с использованием генератора
file_path = "input.txt"
for line in read_text_file_generator(file_path, as_list=True):
    print(line)
```

## **1. `save_text_file(data, file_path, mode='w')`**

Описание
-------------------------
Функция `save_text_file` записывает данные в указанный текстовый файл. 
Она поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).

Шаги выполнения
-------------------------
1. **Проверка типа данных `data`:**  Определяется тип данных, которые нужно записать в файл.
2. **Создание директории:** Если путь к файлу содержит несуществующие директории, они создаются.
3. **Открытие файла:**  Файл открывается в указанном режиме (`mode`) с кодировкой UTF-8.
4. **Запись данных:**  
    * Если `data` - строка, она записывается в файл. 
    * Если `data` - список строк, каждая строка записывается в файл с добавлением символа новой строки (`\n`). 
    * Если `data` - словарь, он сериализуется в JSON с отступами и записывается в файл.
5. **Возврат результата:**  Функция возвращает `True`, если запись прошла успешно, `False` в случае ошибки.

Пример использования
-------------------------

```python
from src.utils.file import save_text_file

# Запись строки в файл
text = "Это тестовая строка для записи."
file_path = "test.txt"
save_text_file(text, file_path)

# Запись списка строк в файл
lines = ["Строка 1", "Строка 2", "Строка 3"]
file_path = "lines.txt"
save_text_file(lines, file_path)

# Запись словаря в файл
data = {"ключ1": "значение1", "ключ2": "значение2"}
file_path = "data.json"
save_text_file(data, file_path)
```

## **2. `read_text_file_generator(file_path, as_list=False, extensions=None, chunk_size=8192, recursive=False, patterns=None)`**

Описание
-------------------------
Функция `read_text_file_generator` считывает содержимое файла или директории, используя генератор для эффективной обработки больших файлов.  
Она поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.

Шаги выполнения
-------------------------
1. **Проверка типа `file_path`:**  Определяется, является ли `file_path` файлом или директорией.
2. **Обработка файла:**
    * Если `file_path` - файл, содержимое файла считывается построчно с помощью генератора.
    * Если `as_list` - `True`, возвращается генератор строк.
    * Если `as_list` - `False`, возвращается строка (для файлов) или объединенную строку из всех файлов директории (для директорий).
3. **Обработка директории:**
    * Если `file_path` - директория, рекурсивно (если `recursive=True`) или в текущей директории (если `recursive=False`)  
      считывается содержимое файлов, соответствующих `patterns` и `extensions`.
    * Если `as_list` - `True`, возвращается генератор, объединяющий строки из всех файлов.
    * Если `as_list` - `False`, возвращается объединенную строку из всех файлов.

Пример использования
-------------------------

```python
from src.utils.file import read_text_file_generator

# Чтение файла построчно с помощью генератора
file_path = "input.txt"
for line in read_text_file_generator(file_path, as_list=True):
    print(line)

# Чтение всех файлов в директории с рекурсивным поиском
directory = "data"
for file in read_text_file_generator(directory, recursive=True, patterns="*.txt"):
    print(f"Файл: {file}")

# Чтение всех файлов в директории с фильтрацией по расширению
directory = "data"
for file in read_text_file_generator(directory, extensions=["*.csv", "*.txt"]):
    print(f"Файл: {file}")
```

## **3. `read_text_file(file_path, as_list=False, extensions=None, exc_info=True, chunk_size=8192)`**

Описание
-------------------------
Функция `read_text_file` считывает содержимое файла или директории. 
Она работает аналогично `read_text_file_generator`, но без использования генераторов, что может быть менее эффективно для больших файлов.

Шаги выполнения
-------------------------
1. **Проверка типа `file_path`:**  Определяется, является ли `file_path` файлом или директорией.
2. **Обработка файла:**  
    * Содержимое файла считывается в строку или в список строк, в зависимости от значения `as_list`.
3. **Обработка директории:**
    * Рекурсивно считывается содержимое файлов в директории, соответствующих `extensions`.
    *  Содержимое файлов объединяется в одну строку или в список строк.

Пример использования
-------------------------

```python
from src.utils.file import read_text_file

# Чтение файла в строку
file_path = "input.txt"
content = read_text_file(file_path)
print(content)

# Чтение всех файлов в директории и объединение их содержимого в список строк
directory = "data"
content = read_text_file(directory, as_list=True, extensions=["*.csv", "*.txt"])
print(content)
```

## **4. `yield_text_from_files(file_path, as_list=False, chunk_size=8192)`**

Описание
-------------------------
Функция `yield_text_from_files` считывает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`). 
Эта функция является вспомогательной для `read_text_file_generator`.

Шаги выполнения
-------------------------
1. **Проверка `as_list`:**  
    * Если `as_list` - `True`, используется функция `_read_file_lines_generator` для чтения файла построчно с помощью генератора.
    * Если `as_list` - `False`, используется функция `_read_file_content` для чтения всего содержимого файла в одну строку.

Пример использования
-------------------------

```python
from src.utils.file import yield_text_from_files

# Чтение файла построчно с помощью генератора
file_path = "input.txt"
for line in yield_text_from_files(file_path, as_list=True):
    print(line)

# Чтение файла в одну строку
file_path = "input.txt"
content = yield_text_from_files(file_path, as_list=False)
print(content)
```

## **5. `_read_file_content(file_path, chunk_size)`**

Описание
-------------------------
Вспомогательная функция `_read_file_content` читает содержимое файла по чанкам и возвращает его как одну строку. 
Эта функция используется для повышения эффективности при работе с очень большими файлами.

Шаги выполнения
-------------------------
1. **Открытие файла:**  Файл открывается в режиме чтения с кодировкой UTF-8.
2. **Чтение по чанкам:** Файл читается по частям размером `chunk_size`.
3. **Объединение чанков:**  Прочитанные части объединяются в переменную `content`.
4. **Обработка пробелов и кавычек:**  Извлекаются лишние пробелы и экранируются кавычки.
5. **Возврат результата:**  Возвращается объединенное содержимое файла как одна строка.

## **6. `_read_file_lines_generator(file_path, chunk_size)`**

Описание
-------------------------
Вспомогательная функция `_read_file_lines_generator` читает файл построчно с помощью генератора. 
Эта функция эффективна для больших файлов, поскольку не загружает весь файл в память сразу.

Шаги выполнения
-------------------------
1. **Открытие файла:**  Файл открывается в режиме чтения с кодировкой UTF-8.
2. **Чтение по чанкам:** Файл читается по частям размером `chunk_size`.
3. **Разделение на строки:**  Каждый чанк разделяется на строки с помощью `splitlines()`.
4. **Обработка неполных строк:**  Если последняя строка в чанке неполная, она дополняется следующим символом из файла.
5. **Обработка пробелов и кавычек:**  Извлекаются лишние пробелы и экранируются кавычки.
6. **Возврат строк:**  Каждая строка из файла возвращается как отдельное значение генератора.

## **7. `get_filenames_from_directory(directory, ext='*')`**

Описание
-------------------------
Функция `get_filenames_from_directory` возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.

Шаги выполнения
-------------------------
1. **Открытие директории:**  Директория открывается для чтения.
2. **Итерация по файлам:**  Итерирует по файлам в директории.
3. **Фильтрация по расширению:**  Если `ext` не равен '*',  проверяется, соответствует ли расширение файла указанному.
4. **Добавление в список:**  Имена файлов, соответствующие условиям, добавляются в список.
5. **Возврат результата:**  Возвращается список имен файлов.

Пример использования
-------------------------

```python
from src.utils.file import get_filenames_from_directory

# Получение списка всех файлов в директории
directory = "data"
filenames = get_filenames_from_directory(directory)
print(filenames)

# Получение списка файлов с расширением .txt
directory = "data"
filenames = get_filenames_from_directory(directory, ext="*.txt")
print(filenames)
```

## **8. `recursively_yield_file_path(root_dir, patterns='*')`**

Описание
-------------------------
Функция `recursively_yield_file_path` рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.

Шаги выполнения
-------------------------
1. **Проверка `patterns`:**  
    * Если `patterns` - строка, она преобразуется в список.
2. **Рекурсивный поиск:**  Используется `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.
3. **Возврат пути:**  Путь к каждому найденному файлу возвращается как отдельное значение генератора.

Пример использования
-------------------------

```python
from src.utils.file import recursively_yield_file_path

# Рекурсивный поиск всех файлов с расширением .txt
root_dir = "data"
for file in recursively_yield_file_path(root_dir, patterns="*.txt"):
    print(file)
```

## **9. `recursively_get_file_path(root_dir, patterns='*')`**

Описание
-------------------------
Функция `recursively_get_file_path` рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.

Шаги выполнения
-------------------------
1. **Проверка `patterns`:**  
    * Если `patterns` - строка, она преобразуется в список.
2. **Рекурсивный поиск:**  Используется `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.
3. **Добавление в список:**  Пути к найденным файлам добавляются в список.
4. **Возврат результата:**  Возвращается список путей к файлам.

Пример использования
-------------------------

```python
from src.utils.file import recursively_get_file_path

# Рекурсивный поиск всех файлов с расширением .txt
root_dir = "data"
file_paths = recursively_get_file_path(root_dir, patterns="*.txt")
print(file_paths)
```

## **10. `recursively_read_text_files(root_dir, patterns, as_list=False)`**

Описание
-------------------------
Функция `recursively_read_text_files` рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.

Шаги выполнения
-------------------------
1. **Проверка `patterns`:**  
    * Если `patterns` - строка, она преобразуется в список.
2. **Рекурсивный обход:**  Используется `os.walk()` для рекурсивного обхода директории.
3. **Чтение файлов:**  Считывается содержимое файлов, соответствующих шаблонам.
4. **Добавление в список:**  Содержимое файлов добавляется в результирующий список.
5. **Возврат результата:**  Возвращается список содержимого файлов (либо список списков строк).

Пример использования
-------------------------

```python
from src.utils.file import recursively_read_text_files

# Рекурсивное чтение всех файлов с расширением .txt
root_dir = "data"
content = recursively_read_text_files(root_dir, patterns="*.txt")
print(content)
```

## **11. `get_directory_names(directory)`**

Описание
-------------------------
Функция `get_directory_names` возвращает список имен поддиректорий в указанной директории.

Шаги выполнения
-------------------------
1. **Открытие директории:**  Директория открывается для чтения.
2. **Итерация по элементам:**  Итерирует по элементам в директории.
3. **Проверка на директорию:**  Проверяется, является ли элемент директорией.
4. **Добавление в список:**  Имена директорий добавляются в список.
5. **Возврат результата:**  Возвращается список имен поддиректорий.

Пример использования
-------------------------

```python
from src.utils.file import get_directory_names

# Получение списка имен поддиректорий
directory = "data"
directory_names = get_directory_names(directory)
print(directory_names)
```

## **12. `remove_bom(path)`**

Описание
-------------------------
Функция `remove_bom` удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.  BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.

Шаги выполнения
-------------------------
1. **Проверка типа `path`:**  Определяется, является ли `path` файлом или директорией.
2. **Обработка файла:**
    * Если `path` - файл, BOM удаляется из него.
3. **Обработка директории:**
    * Если `path` - директория, рекурсивно обходятся все `.py` файлы и удаляется BOM из них.

Пример использования
-------------------------

```python
from src.utils.file import remove_bom

# Удаление BOM из файла
file_path = "test.txt"
remove_bom(file_path)

# Удаление BOM из всех `.py` файлов в директории
directory = "src"
remove_bom(directory)
```

## **13. `main()`**

Описание
-------------------------
Функция `main()` является точкой входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.

Шаги выполнения
-------------------------
1. **Вызов функции `remove_bom`:**  Вызывает функцию `remove_bom` для директории `src`.

Пример использования
-------------------------

```python
from src.utils.file import main

# Запуск скрипта
main()
```