# Модуль для чтения и обработки файлов для Chat GPT

## Обзор

Модуль `code2file_for_chat_gpt.py` предназначен для рекурсивного чтения текстовых файлов в указанной директории, их обработки (например, удаления HTML-тегов или docstrings) и сохранения объединенного содержимого в один или несколько выходных файлов. Основная цель - подготовить данные для использования в задачах, связанных с Chat GPT.

## Подробнее

Модуль предоставляет функциональность для очистки HTML-содержимого, удаления docstrings из файлов Python, рекурсивного удаления содержимого директорий и чтения текстовых файлов с возможностью разделения объединенного текста на несколько файлов, если общее количество символов превышает заданный лимит. Это полезно для обработки больших объемов кода и текста, разбивая их на более мелкие части, пригодные для анализа и обработки.

## Функции

### `clean_html`

```python
def clean_html(content: str) -> str:
    """ Удаляет HTML-теги из содержимого.

    Args:
        content (str): HTML-содержимое для очистки.

    Returns:
        str: Содержимое без HTML-тегов.

    Пример:
        >>> clean_html('<p>Hello, World!</p>')
        'Hello, World!'
    """
    ...
```

**Назначение**:
Функция `clean_html` принимает на вход строку с HTML-содержимым и удаляет из нее все HTML-теги, используя библиотеку `BeautifulSoup`. Это полезно для извлечения чистого текста из HTML-документов.

**Параметры**:
- `content` (str): Строка, содержащая HTML-код, из которого требуется удалить теги.

**Возвращает**:
- `str`: Строка, содержащая только текст из исходного HTML-содержимого, без каких-либо HTML-тегов.

**Как работает функция**:
1. Создает объект `BeautifulSoup` для переданного HTML-содержимого, используя парсер `"html.parser"`.
2. Извлекает текст из объекта `BeautifulSoup` с помощью метода `get_text()`.\
3. Возвращает полученный текст.

**Примеры**:

```python
>>> clean_html('<p>Hello, World!</p>')
'Hello, World!'
```

### `remove_docstrings`

```python
def remove_docstrings(content: str) -> str:
    """ Удаляет все блоки с тройными кавычками `"""` и `'''` из текста.

    Args:
        content (str): Текстовое содержимое, из которого нужно удалить блоки с тройными кавычками.

    Returns:
        str: Текст без блоков с тройными кавычками.

    Пример:
        >>> remove_docstrings(\'\'\'def foo():\n    """This is a docstring"""\n    pass\'\'\')
        'def foo():\n    pass'
    """
    ...
```

**Назначение**:
Функция `remove_docstrings` удаляет все docstrings (многострочные комментарии), заключенные в тройные кавычки (`"""` или `'''`), из переданного текста. Это полезно для очистки кода от комментариев перед его анализом.

**Параметры**:
- `content` (str): Строка, из которой нужно удалить docstrings.

**Возвращает**:
- `str`: Строка, из которой удалены все docstrings.

**Как работает функция**:
1. Использует регулярное выражение `r\"\"\"[\s\S]*?\"\"\"` для поиска и удаления docstrings, заключенных в тройные двойные кавычки.
2. Использует регулярное выражение `r"'''[\s\S]*?'''"` для поиска и удаления docstrings, заключенных в тройные одинарные кавычки.
3. Возвращает строку, из которой удалены все найденные docstrings.

**Примеры**:

```python
>>> remove_docstrings(\'\'\'def foo():\n    """This is a docstring"""\n    pass\'\'\')
'def foo():\n    pass'
```

### `delete_directory_contents`

```python
def delete_directory_contents(directory: Path) -> None:
    """ Рекурсивно удаляет все содержимое указанной директории.

    Args:
        directory (Path): Путь к директории, содержимое которой нужно удалить.

    Returns:
        None
    """
    ...
```

**Назначение**:
Функция `delete_directory_contents` рекурсивно удаляет все файлы и поддиректории внутри указанной директории.

**Параметры**:
- `directory` (Path): Объект `Path`, представляющий путь к директории, содержимое которой нужно удалить.

**Возвращает**:
- `None`: Функция ничего не возвращает.

**Как работает функция**:
1. Итерируется по всем элементам (файлам и поддиректориям) внутри указанной директории.
2. Если элемент является директорией, рекурсивно вызывает `delete_directory_contents` для этой директории, а затем пытается удалить саму директорию.
3. Если элемент является файлом, пытается удалить файл.
4. Логирует успешные удаления файлов и директорий, а также ошибки при удалении.

**Примеры**:

```python
>>> delete_directory_contents(Path('../tmp/chat_gpt/aliexpress'))
```

### `read_text_files`

```python
def read_text_files(
    directory: str, output_file: str, remove_docs: bool = False, max_chars: int = 2000
) -> None:
    """ Читает все указанные Python файлы в каталоге и сохраняет объединенный текст в несколько файлов,
    если размер содержания превышает 2000 символов.

    Args:
        directory (str): Каталог для поиска файлов.
        output_file (str): Базовое имя файла для сохранения объединенного текста.
        remove_docs (bool): Если `True`, удаляет блоки с тройными кавычками из текста. По умолчанию `False`.
        max_chars (int): Максимальное количество символов для каждого файла. По умолчанию 2000.

    Returns:
        None
    """
    ...
```

**Назначение**:
Функция `read_text_files` читает все Python-файлы в указанной директории, опционально удаляет docstrings и сохраняет объединенный текст в один или несколько выходных файлов. Если общее количество символов превышает `max_chars`, текст разбивается на несколько файлов.

**Параметры**:
- `directory` (str): Путь к директории, в которой нужно искать файлы.
- `output_file` (str): Путь к файлу, в который будет сохранен объединенный текст. Если текста много, будут созданы файлы с именами `output_file_1`, `output_file_2` и т.д.
- `remove_docs` (bool): Если `True`, из содержимого файлов будут удалены docstrings. По умолчанию `False`.
- `max_chars` (int): Максимальное количество символов в каждом выходном файле. По умолчанию 2000.

**Как работает функция**:
1. Определяет пути для выходных файлов, создает директорию для них, если она не существует.
2. Рекурсивно обходит указанную директорию, исключая директории из списка `EXCLUDE_DIRS` и директории, начинающиеся с `"_"` или содержащие `"*"`.\
3. Для каждого найденного Python-файла (`.py`):
   - Читает содержимое файла.
   - Если файл пустой, пропускает его.
   - Если `remove_docs` равен `True`, удаляет docstrings из содержимого.
   - Проверяет, нужно ли создавать новый файл для вывода (если текущее количество символов плюс длина содержимого файла превышает `max_chars`).
   - Записывает содержимое файла в текущий выходной файл с префиксом `--- {filename} ---`.
4. Логирует информацию об обрабатываемых файлах, создании новых файлов и возникающих ошибках.

**Примеры**:

```python
>>> read_text_files('src', 'output.txt', remove_docs=True)
```

## Параметры модуля

- `MODE` (str): Указывает режим работы модуля (в данном случае 'development').
- `EXCLUDE_DIRS` (List[str]): Список директорий, которые исключаются из обработки при чтении файлов.
- `EXCLUDE_EXTENSIONS` (List[str]): Список расширений файлов, которые исключаются из обработки при чтении файлов (например, временные файлы Python).

## Примеры использования

В конце модуля приведен пример использования функции `read_text_files`:

```python
if __name__ == "__main__":
    # Указываем каталог для поиска и файл для сохранения вывода
    directory_to_search = "../data/chat_gpt/code2file"
    output_file_path = Path("../data/chat_gpt/code2file/code2file.txt")

    # Создаем директорию, если она не существует
    output_file_path.parent.mkdir(parents=True, exist_ok=True)

    # Создаем файл, если его не существует
    output_file_path.touch(exist_ok=True)

    read_text_files(directory_to_search, output_file_path, remove_docs=True)
```

Этот код выполняет следующие действия:

1. Определяет каталог для поиска файлов (`directory_to_search`) и путь к выходному файлу (`output_file_path`).
2. Создает директорию для выходного файла, если она не существует.
3. Создает выходной файл, если он не существует.
4. Вызывает функцию `read_text_files` для чтения файлов из указанного каталога, удаления docstrings и сохранения объединенного содержимого в выходной файл.