# Модуль для чтения и обработки текстовых файлов для Chat GPT

## Обзор

Этот модуль предназначен для рекурсивного чтения и обработки текстовых и данных файлов в указанном каталоге. Он объединяет содержимое файлов и сохраняет его в один или несколько выходных файлов, при этом может удалять блоки с тройными кавычками из Python-файлов.

## Подробней

Модуль предоставляет функции для очистки HTML-содержимого, удаления docstring'ов из Python-кода, рекурсивного удаления содержимого директорий, а также для чтения текстовых файлов и объединения их содержимого в выходные файлы. Это полезно для подготовки данных для Chat GPT, когда необходимо извлечь и обработать текстовую информацию из различных файлов и директорий.

## Функции

### `clean_html`

**Назначение**: Удаляет HTML-теги из содержимого.

```python
def clean_html(content: str) -> str:
    """ Удаляет HTML-теги из содержимого.

    Args:
        content (str): HTML-содержимое для очистки.

    Returns:
        str: Содержимое без HTML-тегов.

    Пример:
        >>> clean_html('<p>Hello, World!</p>')
        'Hello, World!'
    """
    ...
```

**Параметры**:
- `content` (str): HTML-содержимое, из которого нужно удалить теги.

**Возвращает**:
- `str`: Текст без HTML-тегов.

**Как работает функция**:
- Функция принимает HTML-содержимое в качестве аргумента.
- Использует библиотеку `BeautifulSoup` для парсинга HTML.
- Извлекает текст из HTML-структуры, удаляя все теги.

**Примеры**:
```python
>>> clean_html('<p>Hello, World!</p>')
'Hello, World!'
```

### `remove_docstrings`

**Назначение**: Удаляет все блоки с тройными кавычками `"""` и `'''` из текста.

```python
def remove_docstrings(content: str) -> str:
    """ Удаляет все блоки с тройными кавычками `\\"""` и `\\\'\'\'` из текста.

    Args:
        content (str): Текстовое содержимое, из которого нужно удалить блоки с тройными кавычками.

    Returns:
        str: Текст без блоков с тройными кавычками.

    Пример:
        >>> remove_docstrings('\'\'\'def foo():\\n    \\"""This is a docstring\\"""\\\\n    pass\'\'\')
        'def foo():\\\\n    pass'
    """
    ...
```

**Параметры**:
- `content` (str): Текстовое содержимое, из которого нужно удалить docstring'и.

**Возвращает**:
- `str`: Текст без docstring'ов.

**Как работает функция**:
- Функция принимает текстовое содержимое в качестве аргумента.
- Использует регулярные выражения для поиска и удаления блоков, заключенных в тройные двойные (`"""`) и тройные одинарные (`'''`) кавычки.

**Примеры**:
```python
>>> remove_docstrings('\'\'\'def foo():\\n    \\"""This is a docstring\\"""\\\\n    pass\'\'\')
'def foo():\\\\n    pass'
```

### `delete_directory_contents`

**Назначение**: Рекурсивно удаляет все содержимое указанной директории.

```python
def delete_directory_contents(directory: Path) -> None:
    """ Рекурсивно удаляет все содержимое указанной директории.

    Args:
        directory (Path): Путь к директории, содержимое которой нужно удалить.

    Returns:
        None

    Пример:
        >>> delete_directory_contents(Path('../tmp/chat_gpt/aliexpress'))
    """
    ...
```

**Параметры**:
- `directory` (Path): Путь к директории, содержимое которой нужно удалить.

**Возвращает**:
- `None`

**Как работает функция**:
- Функция принимает путь к директории в качестве аргумента.
- Рекурсивно перебирает все элементы в директории.
- Если элемент является директорией, вызывает себя для удаления содержимого этой директории, а затем пытается удалить саму директорию.
- Если элемент является файлом, пытается удалить файл.
- Логгирует информацию об удаленных файлах и директориях, а также об ошибках при удалении.

### `read_text_files`

**Назначение**: Читает все указанные Python файлы в каталоге и сохраняет объединенный текст в несколько файлов, если размер содержания превышает `max_chars`.

```python
def read_text_files(
    directory: str, output_file: str, remove_docs: bool = False, max_chars: int = 2000
) -> None:
    """ Читает все указанные Python файлы в каталоге и сохраняет объединенный текст в несколько файлов,
    если размер содержания превышает 2000 символов.

    Args:
        directory (str): Каталог для поиска файлов.
        output_file (str): Базовое имя файла для сохранения объединенного текста.
        remove_docs (bool): Если `True`, удаляет блоки с тройными кавычками из текста. По умолчанию `False`.
        max_chars (int): Максимальное количество символов для каждого файла. По умолчанию 2000.

    Returns:
        None

    Пример:
        >>> read_text_files('src', 'output.txt', remove_docs=True)
    """
    ...
```

**Параметры**:
- `directory` (str): Каталог для поиска файлов.
- `output_file` (str): Базовое имя файла для сохранения объединенного текста.
- `remove_docs` (bool): Если `True`, удаляет docstring'и из текста. По умолчанию `False`.
- `max_chars` (int): Максимальное количество символов для каждого выходного файла. По умолчанию 2000.

**Возвращает**:
- `None`

**Как работает функция**:
1.  Функция принимает каталог для поиска файлов, имя выходного файла и флаг для удаления docstring'ов.
2.  Создает выходной файл и рекурсивно перебирает все файлы в указанном каталоге.
3.  Для каждого Python-файла считывает его содержимое, удаляет docstring'и, если указано, и записывает содержимое в выходной файл.
4.  Если размер содержимого превышает `max_chars`, создает новый выходной файл и продолжает запись в него.
5.  Пропускает пустые файлы, чтобы не добавлять их в конечный файл.
6.  Логгирует информацию об обрабатываемых файлах, создаваемых выходных файлах и ошибках при обработке.

**Примеры**:
```python
>>> read_text_files('src', 'output.txt', remove_docs=True)
```

## Параметры модуля

- `MODE` (str): Определяет режим работы модуля (в данном случае, 'development').
- `EXCLUDE_DIRS` (List[str]): Список директорий, которые нужно исключить из обработки (например, "__pycache__", ".git").
- `EXCLUDE_EXTENSIONS` (List[str]): Список расширений файлов, которые нужно исключить из обработки (например, ".pyc", ".pyo").

## Запуск модуля

В блоке `if __name__ == "__main__":` указывается каталог для поиска (`directory_to_search`) и путь к выходному файлу (`output_file_path`). Перед запуском функции `read_text_files` создаются выходная директория и файл, если они не существуют.
```python
if __name__ == "__main__":
    # Указываем каталог для поиска и файл для сохранения вывода
    directory_to_search = "../data/chat_gpt/code2file"
    output_file_path = Path("../data/chat_gpt/code2file/code2file.txt")

    # Создаем директорию, если она не существует
    output_file_path.parent.mkdir(parents=True, exist_ok=True)

    # Создаем файл, если его не существует
    output_file_path.touch(exist_ok=True)

    read_text_files(directory_to_search, output_file_path, remove_docs=True)