# Модуль `html2text`

## Обзор

Модуль `html2text` предназначен для преобразования HTML-документов в удобочитаемый текст в формате Markdown. Он обеспечивает базовую структуру и форматирование текста, извлекая содержимое из HTML-тегов и представляя его в виде Markdown. Модуль поддерживает обработку ссылок, изображений, заголовков и других элементов HTML.

## Подробней

Модуль анализирует HTML-код, преобразуя его в текст с Markdown-разметкой. Он обрабатывает различные HTML-элементы, такие как заголовки, списки, ссылки и изображения, и преобразует их в соответствующий Markdown-формат. Модуль также предоставляет возможность настройки параметров преобразования, таких как ширина текста и стиль списков.

## Функции

### `has_key(x, y)`

**Назначение**: Проверяет наличие ключа `y` в объекте `x`.

**Параметры**:
- `x` (object): Объект, в котором производится поиск ключа.
- `y` (object): Ключ, наличие которого проверяется.

**Возвращает**:
- `bool`: `True`, если ключ присутствует в объекте, иначе `False`.

**Как работает функция**:
Функция проверяет, имеет ли объект `x` метод `has_key`. Если да, то использует этот метод для проверки наличия ключа `y`. В противном случае, проверяет наличие ключа `y` напрямую в объекте `x`.

**Примеры**:

```python
d = {'a': 1, 'b': 2}
print(has_key(d, 'a'))  # Вывод: True
print(has_key(d, 'c'))  # Вывод: False

l = [1, 2, 3]
print(has_key(l, 1))  # Вывод: True
print(has_key(l, 4))  # Вывод: False
```

### `name2cp(k)`

**Назначение**: Преобразует имя HTML-сущности в её Unicode code point.

**Параметры**:
- `k` (str): Имя HTML-сущности.

**Возвращает**:
- `int`: Unicode code point HTML-сущности.

**Как работает функция**:
Функция преобразует имя HTML-сущности в её Unicode code point. Если имя сущности `'apos'`, возвращается code point символа `'`. Функция использует `htmlentitydefs.name2codepoint`, если он доступен (Python 2.3+), иначе использует `htmlentitydefs.entitydefs` и преобразует результат в целое число.

**Примеры**:

```python
print(name2cp('copy')) # Вывод: 169
```

### `charref(name)`

**Назначение**: Преобразует ссылку на символ (character reference) в Unicode символ.

**Параметры**:
- `name` (str): Строка, представляющая ссылку на символ.

**Возвращает**:
- `str`: Unicode символ, соответствующий ссылке.

**Как работает функция**:
Функция `charref` принимает строку `name`, которая может быть в шестнадцатеричном или десятичном формате, и преобразует её в Unicode символ. Если символ находится в словаре `unifiable_n`, возвращается соответствующее значение, иначе возвращается символ на основе его Unicode code point.

**Примеры**:

```python
print(charref('169'))   # Вывод: ©
print(charref('x41'))   # Вывод: A
```

### `entityref(c)`

**Назначение**: Преобразует ссылку на сущность (entity reference) в Unicode символ.

**Параметры**:
- `c` (str): Строка, представляющая ссылку на сущность.

**Возвращает**:
- `str`: Unicode символ, соответствующий ссылке.

**Как работает функция**:
Функция `entityref` принимает строку `c`, представляющую ссылку на сущность, и пытается преобразовать её в Unicode символ. Если сущность находится в словаре `unifiable`, возвращается соответствующее значение. В противном случае, функция пытается преобразовать сущность с помощью `name2cp` и вернуть соответствующий символ.

**Примеры**:

```python
print(entityref('copy'))   # Вывод: (C)
```

### `replaceEntities(s)`

**Назначение**: Заменяет HTML-сущности в строке на соответствующие Unicode символы.

**Параметры**:
- `s` (re.Match): Объект Match, содержащий найденную HTML-сущность.

**Возвращает**:
- `str`: Unicode символ, соответствующий HTML-сущности.

**Как работает функция**:
Функция `replaceEntities` извлекает HTML-сущность из объекта Match и заменяет её на соответствующий Unicode символ. Если сущность является ссылкой на символ (начинается с '#'), используется функция `charref`. В противном случае, используется функция `entityref`.

**Примеры**:

```python
import re
r_unescape = re.compile(r"&(#?[xX]?(?:[0-9a-fA-F]+|\w{1,8}));")
s = "&copy;"
match = r_unescape.search(s)
if match:
    print(replaceEntities(match))   # Вывод: (C)
```

### `unescape(s)`

**Назначение**: Заменяет все HTML-сущности в строке на соответствующие Unicode символы.

**Параметры**:
- `s` (str): Строка, в которой нужно заменить HTML-сущности.

**Возвращает**:
- `str`: Строка с замененными HTML-сущностями.

**Как работает функция**:
Функция `unescape` использует регулярное выражение `r_unescape` для поиска всех HTML-сущностей в строке `s` и заменяет их на соответствующие Unicode символы с помощью функции `replaceEntities`.

**Примеры**:

```python
s = "кот &copy; пес"
print(unescape(s))   # Вывод: кот (C) пес
```

### `onlywhite(line)`

**Назначение**: Проверяет, состоит ли строка только из пробельных символов.

**Параметры**:
- `line` (str): Строка для проверки.

**Возвращает**:
- `bool`: `True`, если строка состоит только из пробельных символов, иначе `False`.

**Как работает функция**:
Функция `onlywhite` проверяет, состоит ли строка `line` только из пробельных символов. Она перебирает каждый символ в строке и возвращает `False`, если находит символ, отличный от пробела.

**Примеры**:

```python
print(onlywhite('   '))   # Вывод: True
print(onlywhite('  a '))   # Вывод: False
```

### `optwrap(text)`

**Назначение**: Оборачивает абзацы в тексте для заданной ширины.

**Параметры**:
- `text` (str): Текст для оборачивания.

**Возвращает**:
- `str`: Текст с обернутыми абзацами.

**Как работает функция**:
Функция `optwrap` принимает текст и оборачивает каждый абзац в нем для заданной ширины `BODY_WIDTH`. Если `BODY_WIDTH` равно 0, текст возвращается без изменений. Функция использует модуль `textwrap` для оборачивания текста.

**Примеры**:

```python
text = "Это очень длинная строка, которую нужно обернуть. " * 10
BODY_WIDTH = 78
print(optwrap(text))
```

### `hn(tag)`

**Назначение**: Определяет уровень заголовка HTML-тега.

**Параметры**:
- `tag` (str): HTML-тег.

**Возвращает**:
- `int | None`: Уровень заголовка (1-9), если тег является заголовком, иначе `None`.

**Как работает функция**:
Функция `hn` проверяет, является ли тег заголовком (h1-h9). Если тег является заголовком, функция пытается преобразовать номер заголовка в целое число и возвращает его. В противном случае, возвращается 0.

**Примеры**:

```python
print(hn('h1'))   # Вывод: 1
print(hn('h6'))   # Вывод: 6
print(hn('p'))    # Вывод: None
```

### `dumb_property_dict(style)`

**Назначение**: Преобразует строку CSS-стилей в словарь атрибутов.

**Параметры**:
- `style` (str): Строка CSS-стилей.

**Возвращает**:
- `dict`: Словарь CSS-атрибутов.

**Как работает функция**:
Функция `dumb_property_dict` принимает строку CSS-стилей и преобразует её в словарь, где ключами являются имена атрибутов, а значениями - значения атрибутов.

**Примеры**:

```python
style = "color: red; font-size: 12px;"
print(dumb_property_dict(style))
# Вывод: {'color': 'red', 'font-size': '12px'}
```

### `dumb_css_parser(data)`

**Назначение**: Разбирает CSS-данные и возвращает словарь селекторов и атрибутов.

**Параметры**:
- `data` (str): Строка CSS-данных.

**Возвращает**:
- `dict`: Словарь CSS-селекторов, где каждый селектор содержит словарь CSS-атрибутов.

**Как работает функция**:
Функция `dumb_css_parser` разбирает CSS-данные и возвращает словарь, где ключами являются CSS-селекторы, а значениями - словари CSS-атрибутов. Функция удаляет `@import` предложения и разделяет данные на селекторы и атрибуты.

**Примеры**:

```python
css_data = "body { color: black; } h1 { font-size: 20px; }"
print(dumb_css_parser(css_data))
# Вывод: {'body': {'color': 'black'}, 'h1': {'font-size': '20px'}}
```

### `element_style(attrs, style_def, parent_style)`

**Назначение**: Определяет окончательный стиль элемента на основе атрибутов, CSS-определений и стиля родительского элемента.

**Параметры**:
- `attrs` (dict): Атрибуты элемента.
- `style_def` (dict): Определения стилей CSS.
- `parent_style` (dict): Стиль родительского элемента.

**Возвращает**:
- `dict`: Словарь "финальных" атрибутов стиля элемента.

**Как работает функция**:
Функция `element_style` определяет окончательный стиль элемента на основе атрибутов, CSS-определений и стиля родительского элемента. Функция копирует стиль родительского элемента, обновляет его на основе CSS-классов элемента и добавляет непосредственные стили из атрибута `style` элемента.

**Примеры**:

```python
attrs = {'class': 'title', 'style': 'font-weight: bold;'}
style_def = {'.title': {'color': 'red'}}
parent_style = {'font-size': '12px'}
print(element_style(attrs, style_def, parent_style))
# Вывод: {'font-size': '12px', 'color': 'red', 'font-weight': 'bold'}
```

### `google_list_style(style)`

**Назначение**: Определяет, является ли список упорядоченным или неупорядоченным на основе CSS-стилей Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `str`: `'ul'`, если список неупорядоченный, иначе `'ol'`.

**Как работает функция**:
Функция `google_list_style` определяет, является ли список упорядоченным или неупорядоченным на основе CSS-стилей Google Docs. Функция проверяет наличие атрибута `list-style-type` в стиле и возвращает `'ul'`, если значение атрибута равно `'disc'`, `'circle'`, `'square'` или `'none'`. В противном случае, возвращается `'ol'`.

**Примеры**:

```python
style = {'list-style-type': 'disc'}
print(google_list_style(style))   # Вывод: ul
style = {'list-style-type': 'decimal'}
print(google_list_style(style))   # Вывод: ol
```

### `google_nest_count(style)`

**Назначение**: Вычисляет уровень вложенности списка Google Docs на основе CSS-стилей.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `int`: Уровень вложенности списка.

**Как работает функция**:
Функция `google_nest_count` вычисляет уровень вложенности списка Google Docs на основе CSS-стилей. Функция проверяет наличие атрибута `margin-left` в стиле и вычисляет уровень вложенности, разделяя значение атрибута на `GOOGLE_LIST_INDENT`.

**Примеры**:

```python
style = {'margin-left': '36px'}
GOOGLE_LIST_INDENT = 36
print(google_nest_count(style))   # Вывод: 1
style = {'margin-left': '72px'}
print(google_nest_count(style))   # Вывод: 2
```

### `google_has_height(style)`

**Назначение**: Проверяет, определен ли атрибут `height` в CSS-стиле элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `bool`: `True`, если атрибут `height` определен, иначе `False`.

**Как работает функция**:
Функция `google_has_height` проверяет, определен ли атрибут `height` в CSS-стиле элемента.

**Примеры**:

```python
style = {'height': '10px'}
print(google_has_height(style))   # Вывод: True
style = {'width': '10px'}
print(google_has_height(style))   # Вывод: False
```

### `google_text_emphasis(style)`

**Назначение**: Возвращает список модификаторов выделения текста на основе CSS-стилей Google Docs.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `list`: Список модификаторов выделения текста.

**Как работает функция**:
Функция `google_text_emphasis` возвращает список модификаторов выделения текста на основе CSS-стилей Google Docs. Функция проверяет наличие атрибутов `text-decoration`, `font-style` и `font-weight` в стиле и добавляет их значения в список.

**Примеры**:

```python
style = {'text-decoration': 'line-through', 'font-style': 'italic'}
print(google_text_emphasis(style))
# Вывод: ['line-through', 'italic']
```

### `google_fixed_width_font(style)`

**Назначение**: Проверяет, используется ли шрифт фиксированной ширины в CSS-стилях элемента.

**Параметры**:
- `style` (dict): Словарь CSS-стилей.

**Возвращает**:
- `bool`: `True`, если используется шрифт фиксированной ширины, иначе `False`.

**Как работает функция**:
Функция `google_fixed_width_font` проверяет, используется ли шрифт фиксированной ширины в CSS-стилях элемента. Функция проверяет значение атрибута `font-family` в стиле и возвращает `True`, если значение равно `'Courier New'` или `'Consolas'`.

**Примеры**:

```python
style = {'font-family': 'Courier New'}
print(google_fixed_width_font(style))   # Вывод: True
style = {'font-family': 'Arial'}
print(google_fixed_width_font(style))   # Вывод: False
```

### `list_numbering_start(attrs)`

**Назначение**: Извлекает начальное значение нумерации из атрибутов элемента списка.

**Параметры**:
- `attrs` (dict): Атрибуты элемента.

**Возвращает**:
- `int`: Начальное значение нумерации (уменьшенное на 1).

**Как работает функция**:
Функция `list_numbering_start` извлекает начальное значение нумерации из атрибутов элемента списка. Если атрибут `start` присутствует в атрибутах, функция преобразует его значение в целое число и возвращает его, уменьшенное на 1. В противном случае, возвращается 0.

**Примеры**:

```python
attrs = {'start': '3'}
print(list_numbering_start(attrs))   # Вывод: 2
attrs = {}
print(list_numbering_start(attrs))   # Вывод: 0
```

### `class _html2text(HTMLParser.HTMLParser)`

**Описание**: Класс `_html2text` наследуется от `HTMLParser.HTMLParser` и предназначен для преобразования HTML в текст.

**Наследует**:
- `HTMLParser.HTMLParser`

**Атрибуты**:
- `out` (callable): Функция для вывода текста.
- `outtextlist` (list): Список для хранения выводимых символов перед их объединением.
- `outtext` (str): Строка для хранения выводимого текста.
- `quiet` (int): Флаг для подавления вывода.
- `p_p` (int): Количество символов новой строки для вывода перед следующим выводом.
- `outcount` (int): Счетчик выведенных символов.
- `start` (int): Флаг начала текста.
- `space` (int): Флаг пробела.
- `a` (list): Список ссылок.
- `astack` (list): Стек ссылок.
- `acount` (int): Счетчик ссылок.
- `list` (list): Список списков.
- `blockquote` (int): Уровень цитирования.
- `pre` (int): Флаг предварительно форматированного текста.
- `startpre` (int): Флаг начала предварительно форматированного текста.
- `code` (bool): Флаг кода.
- `br_toggle` (str): Переключатель тега `<br>`.
- `lastWasNL` (bool): Флаг последнего символа новой строки.
- `lastWasList` (bool): Флаг последнего элемента списка.
- `style` (int): Флаг стиля.
- `style_def` (dict): Определения стилей.
- `tag_stack` (list): Стек тегов.
- `emphasis` (int): Уровень выделения текста.
- `drop_white_space` (int): Флаг удаления пробелов.
- `inheader` (bool): Флаг заголовка.
- `abbr_title` (str): Заголовок текущего определения аббревиатуры.
- `abbr_data` (str): Последний внутренний HTML для определяемой аббревиатуры.
- `abbr_list` (dict): Стек аббревиатур для записи позже.
- `baseurl` (str): Базовый URL.

**Методы**:
- `__init__(self, out=None, baseurl='')`: Инициализирует объект класса `_html2text`.
- `feed(self, data)`: Обрабатывает данные HTML.
- `outtextf(self, s)`: Выводит текст в `self.outtextlist`.
- `close(self)`: Завершает обработку HTML и возвращает текст.
- `handle_charref(self, c)`: Обрабатывает ссылку на символ.
- `handle_entityref(self, c)`: Обрабатывает ссылку на сущность.
- `handle_starttag(self, tag, attrs)`: Обрабатывает начальный тег.
- `handle_endtag(self, tag)`: Обрабатывает конечный тег.
- `previousIndex(self, attrs)`: Возвращает индекс набора атрибутов (ссылки) в списке `self.a`.
- `drop_last(self, nLetters)`: Удаляет последние `nLetters` из `self.outtext`.
- `handle_emphasis(self, start, tag_style, parent_style)`: Обрабатывает выделение текста.
- `handle_tag(self, tag, attrs, start)`: Обрабатывает тег.
- `pbr(self)`: Добавляет одну новую строку.
- `p(self)`: Добавляет две новые строки.
- `soft_br(self)`: Добавляет мягкий перенос строки.
- `o(self, data, puredata=0, force=0)`: Выводит данные.
- `handle_data(self, data)`: Обрабатывает данные тега.
- `unknown_decl(self, data)`: Обрабатывает неизвестное объявление.

### `_html2text.__init__(self, out=None, baseurl='')`

**Назначение**: Инициализирует объект класса `_html2text`.

**Параметры**:
- `out` (callable, optional): Функция для вывода текста. По умолчанию `self.outtextf`.
- `baseurl` (str, optional): Базовый URL. По умолчанию `''`.

**Как работает функция**:
Функция инициализирует объект класса `_html2text`, устанавливая функцию вывода, базовый URL и другие атрибуты.

### `_html2text.feed(self, data)`

**Назначение**: Обрабатывает данные HTML.

**Параметры**:
- `data` (str): Данные HTML для обработки.

**Как работает функция**:
Функция `feed` заменяет `</\' + \'script>` на `</ignore>` и передает данные в базовый класс `HTMLParser.HTMLParser` для обработки.

### `_html2text.outtextf(self, s)`

**Назначение**: Добавляет текст в список `self.outtextlist`.

**Параметры**:
- `s` (str): Текст для добавления.

**Как работает функция**:
Функция `outtextf` добавляет текст `s` в список `self.outtextlist`. Если текст не пустой, устанавливается флаг `self.lastWasNL`, указывающий на наличие символа новой строки в конце текста.

### `_html2text.close(self)`

**Назначение**: Завершает обработку HTML и возвращает текст.

**Как работает функция**:
Функция `close` завершает обработку HTML, вызывает `self.pbr()` и `self.o('', 0, 'end')`, объединяет элементы списка `self.outtextlist` в строку `self.outtext` и возвращает её. Если включена опция `google_doc`, заменяет `&nbsp_place_holder;` на пробел.

### `_html2text.handle_charref(self, c)`

**Назначение**: Обрабатывает ссылку на символ (character reference).

**Параметры**:
- `c` (str): Строка, представляющая ссылку на символ.

**Как работает функция**:
Функция `handle_charref` обрабатывает ссылку на символ, вызывая функцию `charref` для преобразования ссылки в Unicode символ и выводит результат с помощью `self.o`.

### `_html2text.handle_entityref(self, c)`

**Назначение**: Обрабатывает ссылку на сущность (entity reference).

**Параметры**:
- `c` (str): Строка, представляющая ссылку на сущность.

**Как работает функция**:
Функция `handle_entityref` обрабатывает ссылку на сущность, вызывая функцию `entityref` для преобразования ссылки в Unicode символ и выводит результат с помощью `self.o`.

### `_html2text.handle_starttag(self, tag, attrs)`

**Назначение**: Обрабатывает начальный тег HTML.

**Параметры**:
- `tag` (str): Имя тега.
- `attrs` (list): Список атрибутов тега.

**Как работает функция**:
Функция `handle_starttag` обрабатывает начальный тег HTML, вызывая `self.handle_tag` с параметром `start=1`.

### `_html2text.handle_endtag(self, tag)`

**Назначение**: Обрабатывает конечный тег HTML.

**Параметры**:
- `tag` (str): Имя тега.

**Как работает функция**:
Функция `handle_endtag` обрабатывает конечный тег HTML, вызывая `self.handle_tag` с параметром `start=0`.

### `_html2text.previousIndex(self, attrs)`

**Назначение**: Возвращает индекс набора атрибутов (ссылки) в списке `self.a`.

**Параметры**:
- `attrs` (dict): Атрибуты ссылки.

**Возвращает**:
- `int | None`: Индекс набора атрибутов в списке `self.a`, если найден, иначе `None`.

**Как работает функция**:
Функция `previousIndex` ищет в списке `self.a` ссылку с заданными атрибутами и возвращает её индекс. Если ссылка не найдена, возвращается `None`.

### `_html2text.drop_last(self, nLetters)`

**Назначение**: Удаляет последние `nLetters` символов из `self.outtext`.

**Параметры**:
- `nLetters` (int): Количество символов для удаления.

**Как работает функция**:
Функция `drop_last` удаляет последние `nLetters` символов из `self.outtext`, если вывод не подавлен.

### `_html2text.handle_emphasis(self, start, tag_style, parent_style)`

**Назначение**: Обрабатывает выделение текста на основе стилей.

**Параметры**:
- `start` (bool): Флаг начала или конца тега.
- `tag_style` (dict): Стили текущего тега.
- `parent_style` (dict): Стили родительского тега.

**Как работает функция**:
Функция `handle_emphasis` обрабатывает выделение текста на основе стилей, добавляя или удаляя символы выделения (`_`, `**`, \`\`) в зависимости от атрибутов стилей.

### `_html2text.handle_tag(self, tag, attrs, start)`

**Назначение**: Обрабатывает HTML-тег.

**Параметры**:
- `tag` (str): Имя тега.
- `attrs` (dict): Атрибуты тега.
- `start` (int): Флаг, указывающий на начало (1) или конец (0) тега.

**Как работает функция**:
Функция `handle_tag` обрабатывает различные HTML-теги, такие как заголовки, параграфы, разрывы строк, горизонтальные линии, блоки кода, ссылки и изображения. Она также обрабатывает стили и атрибуты тегов, чтобы определить, как они должны быть преобразованы в Markdown.

### `_html2text.pbr(self)`

**Назначение**: Добавляет одну новую строку, если необходимо.

**Как работает функция**:
Функция `pbr` устанавливает значение `self.p_p` равным 1, что означает добавление одной новой строки перед следующим выводом.

### `_html2text.p(self)`

**Назначение**: Добавляет две новые строки.

**Как работает функция**:
Функция `p` устанавливает значение `self.p_p` равным 2, что означает добавление двух новых строк перед следующим выводом.

### `_html2text.soft_br(self)`

**Назначение**: Добавляет мягкий перенос строки.

**Как работает функция**:
Функция `soft_br` добавляет мягкий перенос строки, устанавливая `self.pbr()` и `self.br_toggle = '  '`.

### `_html2text.o(self, data, puredata=0, force=0)`

**Назначение**: Выводит данные.

**Параметры**:
- `data` (str): Данные для вывода.
- `puredata` (int, optional): Флаг, указывающий, что данные являются чистым текстом. По умолчанию 0.
- `force` (int, optional): Флаг, указывающий на принудительный вывод. По умолчанию 0.

**Как работает функция**:
Функция `o` выводит данные с учетом различных флагов и состояний, таких как подавление вывода, предварительное форматирование, цитирование и ссылки.

### `_html2text.handle_data(self, data)`

**Назначение**: Обрабатывает данные внутри HTML-тега.

**Параметры**:
- `data` (str): Данные для обработки.

**Как работает функция**:
Функция `handle_data` обрабатывает данные внутри HTML-тега, удаляя закрывающий тег `</script>`, обновляя определения стилей и выводя данные с помощью `self.o`.

### `_html2text.unknown_decl(self, data)`

**Назначение**: Обрабатывает неизвестное объявление.

**Параметры**:
- `data` (str): Данные объявления.

**Как работает функция**:
Функция `unknown_decl` ничего не делает, просто принимает данные объявления.

### `wrapwrite(text)`

**Назначение**: Записывает текст в стандартный поток вывода, кодируя его в UTF-8.

**Параметры**:
- `text` (str): Текст для записи.

**Как работает функция**:
Функция `wrapwrite` кодирует текст в UTF-8 и записывает его в стандартный поток вывода.

### `html2text_file(html, out=wrapwrite, baseurl='')`

**Назначение**: Преобразует HTML-код в текст, используя указанную функцию вывода.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `out` (callable, optional): Функция для вывода текста. По умолчанию `wrapwrite`.
- `baseurl` (str, optional): Базовый URL. По умолчанию `''`.

**Возвращает**:
- `str`: Преобразованный текст.

**Как работает функция**:
Функция `html2text_file` создает экземпляр класса `_html2text`, передает ему HTML-код для обработки и возвращает преобразованный текст.

### `html2text(html, baseurl='')`

**Назначение**: Преобразует HTML-код в текст с обертыванием абзацев.

**Параметры**:
- `html` (str): HTML-код для преобразования.
- `baseurl` (str, optional): Базовый URL. По умолчанию `''`.

**Возвращает**:
- `str`: Преобразованный текст с обертыванием абзацев.

**Как работает функция**:
Функция `html2text` преобразует HTML-код в текст, используя функцию `html2text_file`, и оборачивает абзацы в тексте с помощью функции `optwrap`.

### `Storage`

**Описание**: Пустой класс для хранения параметров.

### `options`

**Описание**: Экземпляр класса `Storage`, содержащий параметры преобразования HTML в текст.

**Атрибуты**:
- `google_doc` (bool): Флаг, указывающий, что входные данные являются документом Google.
- `ul_item_mark` (str): Маркер для элементов неупорядоченного списка.

## Параметры класса

- `google_doc` (bool): Определяет, является ли документ документом Google.
- `ul_item_mark` (str): Определяет символ, используемый для обозначения пунктов неупорядоченного списка.

## Методы класса

### `my_func`

```python
def my_func(param1:str, param2:Optional[int] = 0) -> bool:
    """ Функция выполняет некоторое действия... <Тут Ты пишешь что именно делает функция> 
    Args:
        param1 (str): Описание параметра `param1`.
        param2 (Optional[int], optional): Описание параметра `param2`. По умолчанию 0.
    Returns:
        bool: Описание возвращаемого значения. Возвращает `True` или `False`.

     Raises:
          Ошибка выполнение

     Example:
         Примеры вызовов со всем спектром параметров. которы можно передать в функцию

    """
```

## Примеры

Примеры использования функций и методов модуля.
```python
print(html2text("<h1>Hello World</h1>"))
```
```python
print(html2text("<ol><li>Item 1</li><li>Item 2</li></ol>"))
```
```python
print(html2text("<p>This is a paragraph with a <a href='http://example.com'>link</a>.</p>"))
```