# Модуль для работы с JSON (`jjson.py`)

## Обзор

Модуль `jjson.py` предоставляет набор функций для работы с данными в формате JSON. Он включает в себя инструменты для загрузки, выгрузки, преобразования и обработки JSON-данных. Модуль предназначен для упрощения работы с JSON-данными в проекте `hypotez`.

## Подробнее

Этот модуль содержит функции для чтения и записи JSON-файлов, преобразования данных между различными форматами (например, `dict` и `SimpleNamespace`), а также для обработки ошибок, которые могут возникнуть при работе с JSON. Он также включает функции для очистки и исправления JSON-строк.

## Классы

### `Config`

**Описание**: Класс `Config` содержит статические переменные, используемые для определения режимов работы с файлами.

**Атрибуты**:
- `MODE_WRITE` (str): Режим записи файла (`"w"`).
- `MODE_APPEND_START` (str): Режим добавления в начало файла (`"a+"`).
- `MODE_APPEND_END` (str): Режим добавления в конец файла (`"+a"`).

## Функции

### `_convert_to_dict`

**Назначение**: Преобразует объекты `SimpleNamespace` и списки в словари.

**Параметры**:
- `value` (Any): Значение для преобразования.

**Возвращает**:
- Any: Преобразованное значение в виде словаря или списка.

**Как работает функция**:
Функция рекурсивно преобразует объекты `SimpleNamespace` и списки в словари. Если входное значение является экземпляром `SimpleNamespace`, оно преобразуется в словарь, где ключи и значения рекурсивно обрабатываются. Если входное значение является словарем, функция рекурсивно преобразует его значения. Если входное значение является списком, функция применяет преобразование к каждому элементу списка.

**Примеры**:

```python
from types import SimpleNamespace

data = SimpleNamespace(name='John', age=30, address=SimpleNamespace(city='New York'))
result = _convert_to_dict(data)
print(result)  # {'name': 'John', 'age': 30, 'address': {'city': 'New York'}}
```

### `_read_existing_data`

**Назначение**: Читает существующие JSON-данные из файла.

**Параметры**:
- `path` (Path): Путь к файлу.
- `exc_info` (bool, optional): Если `True`, логирует исключения с трассировкой. По умолчанию `True`.

**Возвращает**:
- dict: Словарь с данными из JSON-файла.

**Как работает функция**:
Функция пытается прочитать JSON-данные из файла, указанного в параметре `path`. В случае успешного чтения и разбора JSON, функция возвращает словарь с данными. Если возникает ошибка при чтении или разборе JSON, функция логирует ошибку и возвращает пустой словарь.

**Примеры**:

```python
from pathlib import Path
# Пример с реальным файлом
file_path = Path('example.json')
#file_path.write_text('{"name": "John", "age": 30}')  # Создаем временный файл для примера
data = _read_existing_data(file_path)
print(data)  # {'name': 'John', 'age': 30}
```

### `_merge_data`

**Назначение**: Объединяет новые данные с существующими данными в зависимости от режима.

**Параметры**:
- `data` (Dict): Новые данные для объединения.
- `existing_data` (Dict): Существующие данные.
- `mode` (str): Режим объединения (`Config.MODE_APPEND_START` или `Config.MODE_APPEND_END`).

**Возвращает**:
- Dict: Объединенные данные.

**Как работает функция**:
Функция объединяет новые данные с существующими данными на основе указанного режима. Если режим `Config.MODE_APPEND_START`, новые данные добавляются в начало существующих данных (если это списки) или обновляют существующий словарь. Если режим `Config.MODE_APPEND_END`, существующие данные добавляются в начало новых данных (если это списки) или обновляют новый словарь.

**Примеры**:

```python
data = {'name': 'John', 'age': 30}
existing_data = {'city': 'New York'}
mode = Config.MODE_APPEND_START
result = _merge_data(data, existing_data, mode)
print(result)  # {'city': 'New York', 'name': 'John', 'age': 30}
```

### `j_dumps`

**Назначение**: Записывает JSON-данные в файл или возвращает JSON-данные в виде словаря.

**Параметры**:
- `data` (Union[Dict, SimpleNamespace, List[Dict], List[SimpleNamespace]]): Данные для записи.
- `file_path` (Optional[Path], optional): Путь к файлу. Если `None`, возвращает JSON в виде словаря. По умолчанию `None`.
- `ensure_ascii` (bool, optional): Если `True`, экранирует не-ASCII символы. По умолчанию `False`.
- `mode` (str, optional): Режим открытия файла (`'w'`, `'a+'`, `'+a'`). По умолчанию `'w'`.
- `exc_info` (bool, optional): Если `True`, логирует исключения с трассировкой. По умолчанию `True`.

**Возвращает**:
- Optional[Dict]: JSON-данные в виде словаря, если успешно, или `None` в случае ошибки.

**Вызывает исключения**:
- ValueError: Если указан неподдерживаемый режим файла.

**Как работает функция**:
Функция `j_dumps` записывает JSON-совместимые данные в файл, если указан `file_path`, или возвращает JSON-данные в виде словаря, если `file_path` не указан. Функция поддерживает различные режимы записи файла (`'w'`, `'a+'`, `'+a'`) и обрабатывает исключения, возникающие при записи данных.

**Примеры**:

```python
from pathlib import Path

data = {'name': 'John', 'age': 30}
file_path = Path('example.json')
result = j_dumps(data, file_path=file_path)
print(result)  # {'name': 'John', 'age': 30}
```

### `_decode_strings`

**Назначение**: Рекурсивно декодирует строки в структуре данных.

**Параметры**:
- `data` (Any): Данные для декодирования.

**Возвращает**:
- Any: Декодированные данные.

**Как работает функция**:
Функция рекурсивно проходит по структуре данных и декодирует строки, используя кодировку `unicode_escape`. Если происходит ошибка при декодировании, функция возвращает исходную строку без изменений.

**Примеры**:

```python
data = {'name': 'John\\u0020Doe', 'age': 30}
result = _decode_strings(data)
print(result)  # {'name': 'John Doe', 'age': 30}
```

### `_string_to_dict`

**Назначение**: Удаляет markdown-кавычки и разбирает JSON-строку.

**Параметры**:
- `json_string` (str): JSON-строка для разбора.

**Возвращает**:
- dict: Словарь, полученный из JSON-строки.

**Как работает функция**:
Функция удаляет markdown-кавычки (если они есть) из JSON-строки и пытается разобрать строку как JSON. Если разбор успешен, функция возвращает словарь, полученный из JSON-строки. Если возникает ошибка при разборе JSON, функция логирует ошибку и возвращает пустой словарь.

**Примеры**:

```python
json_string = '```json\n{"name": "John", "age": 30}\n```'
result = _string_to_dict(json_string)
print(result)  # {'name': 'John', 'age': 30}
```

### `j_loads`

**Назначение**: Загружает JSON или CSV данные из файла, директории, строки или объекта.

**Параметры**:
- `jjson` (Union[dict, SimpleNamespace, str, Path, list]): Путь к файлу/директории, JSON строка или JSON объект.
- `ordered` (bool, optional): Использовать OrderedDict для сохранения порядка элементов. По умолчанию `True`.

**Возвращает**:
- Union[dict, list]: Обработанные данные (словарь или список словарей).

**Вызывает исключения**:
- FileNotFoundError: Если указанный файл не найден.
- json.JSONDecodeError: Если JSON данные не могут быть разобраны.

**Как работает функция**:
Функция `j_loads` загружает JSON или CSV данные из различных источников, таких как файлы, директории, строки или объекты. Она поддерживает чтение JSON файлов, CSV файлов (с использованием pandas), JSON строк и JSON объектов. Функция также обрабатывает ошибки, возникающие при загрузке и разборе данных.

**Примеры**:

```python
from pathlib import Path

#file_path = Path('example.json')
#file_path.write_text('{"name": "John", "age": 30}')
#result = j_loads(file_path)
#print(result)  # {'name': 'John', 'age': 30}
```

### `j_loads_ns`

**Назначение**: Загружает JSON/CSV данные и преобразует в SimpleNamespace.

**Параметры**:
- `jjson` (Union[Path, SimpleNamespace, Dict, str]): Путь, SimpleNamespace, словарь или строка с JSON данными.
- `ordered` (bool, optional): Использовать ли OrderedDict для сохранения порядка элементов. По умолчанию `True`.

**Возвращает**:
- Union[SimpleNamespace, List[SimpleNamespace], Dict]: Преобразованные данные в виде SimpleNamespace или списка SimpleNamespace.

**Как работает функция**:
Функция `j_loads_ns` загружает JSON/CSV данные с помощью `j_loads` и преобразует их в объекты `SimpleNamespace`. Если данные представляют собой список, каждый элемент списка преобразуется в `SimpleNamespace`.

**Примеры**:

```python
from pathlib import Path

#file_path = Path('example.json')
#file_path.write_text('{"name": "John", "age": 30}')
#result = j_loads_ns(file_path)
#print(result)  # namespace(name='John', age=30)