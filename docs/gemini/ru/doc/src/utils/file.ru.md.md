# Модуль `file.py`

## Обзор

Модуль `file.py` предоставляет набор функций для работы с файлами и директориями, включая обработку больших файлов с помощью генераторов и рекурсивный поиск файлов. Функции хорошо структурированы и имеют ясное назначение. Добавленные функции обработки лишних пробелов и экранирования кавычек улучшают функциональность.

## Подробнее

Этот модуль предоставляет инструменты для выполнения различных операций с файлами и директориями, включая чтение, запись, рекурсивный поиск и удаление BOM (Byte Order Mark). Он предназначен для упрощения работы с файловой системой и обеспечения эффективной обработки больших файлов.

## Функции

### `save_text_file`

**Назначение**: Записывает данные в указанный текстовый файл. Поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).

**Параметры**:
- `data` (str | list[str] | dict): Данные для записи в файл. Может быть строкой, списком строк или словарем.
- `file_path` (str | Path): Путь к файлу, куда нужно записать данные. Может быть строкой или объектом `Path` из библиотеки `pathlib`.
- `mode` (str, optional): Режим открытия файла. По умолчанию `'w'` (запись, перезаписывает файл). Можно использовать `'a'` (добавление, добавляет данные в конец файла).

**Возвращает**:
- `bool`: `True`, если запись прошла успешно, `False` в случае ошибки.

**Как работает функция**:
1. Функция создает директории, если они не существуют, используя `file_path.parent.mkdir(parents=True, exist_ok=True)`.
2. Открывает файл в указанном режиме с кодировкой UTF-8.
3. В зависимости от типа данных `data`:
   - Если это строка, записывает её в файл.
   - Если это список строк, записывает каждую строку с добавлением символа новой строки (`\n`).
   - Если это словарь, сериализует его в JSON с отступами для читаемости и записывает в файл.
4. Функция возвращает `True` при успешной записи, `False` и логирует ошибку при возникновении исключения.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import save_text_file

# Пример записи строки в файл
file_path = Path('example.txt')
data = "Hello, world!"
result = save_text_file(data, file_path)
print(f"Запись строки: {result}")

# Пример записи списка строк в файл
file_path = Path('example.txt')
data = ["Hello,", "world!"]
result = save_text_file(data, file_path)
print(f"Запись списка строк: {result}")

# Пример записи словаря в файл
file_path = Path('example.json')
data = {"name": "John", "age": 30}
result = save_text_file(data, file_path)
print(f"Запись словаря: {result}")
```

### `read_text_file_generator`

**Назначение**: Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов. Поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
- `extensions` (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
- `chunk_size` (int, optional): Размер чанка для чтения файла (в байтах). Увеличивает эффективность для очень больших файлов.
- `recursive` (bool, optional): Если `True`, рекурсивно обходит все поддиректории.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов (например, `'*.txt'`, `['*.txt', '*.csv']`). Используется вместе с `recursive`.

**Возвращает**:
- `Generator[str, None, None] | str | list[str] | None`: Возвращает генератор строк (`as_list=True`), строку (`as_list=False` и файл), объединенную строку из всех файлов директории (`as_list=False` и директория), или `None` в случае ошибки.

**Как работает функция**:
1. Функция проверяет, является ли `file_path` файлом или директорией.
2. Для файлов:
   - Если `as_list=True`, использует `_read_file_lines_generator` для возврата генератора строк.
   - Если `as_list=False`, использует `_read_file_content` для возврата всего содержимого как строки.
3. Для директорий:
   - Если `recursive=True`, рекурсивно находит все файлы, соответствующие `patterns` и `extensions`, и обрабатывает их.
   - Если `recursive=False`, обрабатывает только файлы в текущей директории.
   - Если `as_list=True`, возвращает генератор, объединяющий строки из всех файлов.
   - Если `as_list=False`, возвращает объединенную строку из всех файлов.
4. Функция возвращает `None` при ошибках и логирует их.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import read_text_file_generator

# Пример чтения файла как генератора строк
file_path = Path('example.txt')
generator = read_text_file_generator(file_path, as_list=True)
if generator:
    for line in generator:
        print(line)

# Пример чтения директории как объединенной строки
dir_path = Path('.')
content = read_text_file_generator(dir_path, as_list=False, extensions=['.txt'])
if content:
    print(f"Содержимое директории: {content[:100]}...")
```

### `read_text_file`

**Назначение**: Читает содержимое файла или директории. Более простая версия, чем `read_text_file_generator`, не использующая генераторы.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает список строк. Если `False`, возвращает строку.
- `extensions` (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
- `exc_info` (bool, optional): Определяет, надо ли выводить служебную информацию.
- `chunk_size` (int, optional): Размер чанка для чтения файла в байтах.

**Возвращает**:
- `str | list[str] | None`: Строка (если `as_list=False`) или список строк (если `as_list=True`). `None` в случае ошибки.

**Как работает функция**:
1. Функция проверяет, является ли `file_path` файлом или директорией.
2. Для файлов:
   - Если `as_list=True`, возвращает список строк.
   - Если `as_list=False`, возвращает содержимое как строку.
3. Для директорий рекурсивно считывает все файлы, соответствующие `extensions`, и объединяет их содержимое в одну строку или список строк.
4. Функция возвращает `None` при возникновении ошибки и логирует ее.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import read_text_file

# Пример чтения файла как строки
file_path = Path('example.txt')
content = read_text_file(file_path, as_list=False)
if content:
    print(f"Содержимое файла: {content[:100]}...")

# Пример чтения файла как списка строк
file_path = Path('example.txt')
lines = read_text_file(file_path, as_list=True)
if lines:
    for line in lines:
        print(line)
```

### `yield_text_from_files`

**Назначение**: Читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`). Вспомогательная функция для `read_text_file_generator`.

**Параметры**:
- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Флаг, указывающий на возврат генератора или строки.
- `chunk_size` (int, optional): Размер чанка для чтения.

**Возвращает**:
- `Generator[str, None, None] | str | None`: Генератор строк или строка, или `None` при ошибке.

**Как работает функция**:
1. Функция использует `_read_file_lines_generator` или `_read_file_content` в зависимости от значения `as_list`.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import yield_text_from_files

# Пример чтения файла как генератора строк
file_path = Path('example.txt')
generator = yield_text_from_files(file_path, as_list=True)
if generator:
    for line in generator:
        print(line)

# Пример чтения файла как строки
file_path = Path('example.txt')
content = yield_text_from_files(file_path, as_list=False)
if content:
    print(f"Содержимое файла: {content[:100]}...")
```

### `_read_file_content`

**Назначение**: Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки. Используется для повышения эффективности при работе с очень большими файлами.

**Параметры**:
- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка.

**Возвращает**:
- `str`: Содержимое файла как одна строка.

**Как работает функция**:
1. Функция читает файл по частям размером `chunk_size`, накапливая данные в переменной `content`, и возвращает итоговую строку.
2. Функция обрабатывает лишние пробелы и экранирует кавычки.

### `_read_file_lines_generator`

**Назначение**: Вспомогательная функция для чтения файла построчно с помощью генератора. Эффективна для больших файлов, поскольку не загружает весь файл в память сразу.

**Параметры**:
- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка.

**Возвращает**:
- `Generator[str, None, None]`: Генератор, который выдает строки файла по одной.

**Как работает функция**:
1. Функция читает файл по чанкам, разделяет чанк на строки с помощью `splitlines()`.
2. Обрабатывает случай, когда последняя строка в чанке неполная – добавляет к ней следующий символ из файла.
3. Функция обрабатывает лишние пробелы и экранирует кавычки в каждой строке.

### `get_filenames_from_directory`

**Назначение**: Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.

**Параметры**:
- `directory` (str | Path): Путь к директории.
- `ext` (str | list[str], optional): Расширение или список расширений файлов для фильтрации.

**Возвращает**:
- `list[str]`: Список имен файлов.

**Как работает функция**:
1. Функция итерирует по файлам в директории и возвращает список имен тех файлов, которые соответствуют указанному расширению (или всем файлам, если `ext='*'`).

**Примеры**:

```python
from pathlib import Path
from src.utils.file import get_filenames_from_directory

# Пример получения списка всех файлов в директории
dir_path = Path('.')
filenames = get_filenames_from_directory(dir_path)
print(f"Все файлы: {filenames}")

# Пример получения списка файлов с расширением .txt
filenames = get_filenames_from_directory(dir_path, ext='.txt')
print(f"Файлы .txt: {filenames}")
```

### `recursively_yield_file_path`

**Назначение**: Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:
- `Generator[Path, None, None]`: Генератор, который выдает пути к файлам.

**Как работает функция**:
1. Функция использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import recursively_yield_file_path

# Пример рекурсивного поиска всех файлов .txt
root_dir = Path('.')
generator = recursively_yield_file_path(root_dir, patterns='*.txt')
for file_path in generator:
    print(file_path)
```

### `recursively_get_file_path`

**Назначение**: Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:
- `list[Path]`: Список путей к файлам.

**Как работает функция**:
1. Функция использует `Path.rglob()` и собирает все найденные пути в список.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import recursively_get_file_path

# Пример рекурсивного получения списка всех файлов .txt
root_dir = Path('.')
file_paths = recursively_get_file_path(root_dir, patterns='*.txt')
print(f"Файлы .txt: {file_paths}")
```

### `recursively_read_text_files`

**Назначение**: Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов.
- `as_list` (bool, optional): Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.

**Возвращает**:
- `list[str]`: Список содержимого файлов (либо список списков строк).

**Как работает функция**:
1. Функция использует `os.walk()` для рекурсивного обхода директории.
2. Читает файлы, соответствующие шаблонам, и добавляет их содержимое в результирующий список.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import recursively_read_text_files

# Пример рекурсивного чтения всех файлов .txt как строк
root_dir = Path('.')
contents = recursively_read_text_files(root_dir, patterns='*.txt', as_list=False)
print(f"Содержимое файлов: {contents}")

# Пример рекурсивного чтения всех файлов .txt как списков строк
contents = recursively_read_text_files(root_dir, patterns='*.txt', as_list=True)
print(f"Содержимое файлов (списки строк): {contents}")
```

### `get_directory_names`

**Назначение**: Возвращает список имен поддиректорий в указанной директории.

**Параметры**:
- `directory` (str | Path): Путь к директории.

**Возвращает**:
- `list[str]`: Список имен поддиректорий.

**Как работает функция**:
1. Функция итерирует по элементам в директории и возвращает список имен только тех, которые являются директориями.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import get_directory_names

# Пример получения списка поддиректорий
dir_path = Path('.')
directory_names = get_directory_names(dir_path)
print(f"Поддиректории: {directory_names}")
```

### `remove_bom`

**Назначение**: Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории. BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.

**Параметры**:
- `path` (str | Path): Путь к файлу или директории.

**Возвращает**:
- `None`.

**Как работает функция**:
1. Если `path` – файл, функция удаляет BOM из него.
2. Если `path` – директория, функция рекурсивно обходит все `.py` файлы и удаляет BOM из них.

**Примеры**:

```python
from pathlib import Path
from src.utils.file import remove_bom

# Пример удаления BOM из файла
file_path = Path('example.py')
remove_bom(file_path)

# Пример удаления BOM из всех .py файлов в директории
dir_path = Path('.')
remove_bom(dir_path)
```

### `main`

**Назначение**: Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.

**Параметры**:
- Нет.

**Возвращает**:
- `None`.

**Как работает функция**:
1. Функция вызывает `remove_bom()` для директории `src`.