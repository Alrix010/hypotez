# Модуль `file.py`

## Обзор

Модуль `file.py` предоставляет набор функций для работы с файлами и директориями, включая обработку больших файлов с помощью генераторов и рекурсивный поиск файлов. Функции хорошо структурированы и имеют ясное назначение. Добавленные функции обработки лишних пробелов и экранирования кавычек улучшают функциональность.

## Подробнее

Этот модуль предоставляет инструменты для выполнения различных операций с файлами и директориями, такие как запись, чтение, рекурсивный поиск, фильтрация файлов по расширениям и удаление BOM (Byte Order Mark). Он разработан для обеспечения эффективной обработки файлов, особенно больших, с использованием генераторов и других оптимизаций.

## Функции

### `save_text_file`

**Назначение**: Записывает данные в указанный текстовый файл. Поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).

**Параметры**:
- `data` (str | list[str] | dict): Данные для записи в файл. Может быть строкой, списком строк или словарем.
- `file_path` (str | Path): Путь к файлу, куда нужно записать данные. Может быть строкой или объектом `Path` из библиотеки `pathlib`.
- `mode` (str, optional): Режим открытия файла. По умолчанию `'w'` (запись, перезаписывает файл). Можно использовать `'a'` (добавление, добавляет данные в конец файла).

**Возвращает**:
- `bool`: `True`, если запись прошла успешно, `False` в случае ошибки.

**Как работает функция**:
1. Функция извлекает родительский каталог из `file_path`.
2. Функция создает директории, если они не существуют, с использованием `file_path.parent.mkdir(parents=True, exist_ok=True)`.
3. Функция открывает файл в указанном режиме с кодировкой UTF-8.
4. В зависимости от типа данных `data`:
    - Если это строка, записывает её в файл.
    - Если это список строк, записывает каждую строку с добавлением символа новой строки (`\n`).
    - Если это словарь, сериализует его в JSON с отступами для читаемости и записывает в файл.
5. Функция возвращает `True` при успешной записи, `False` и логирует ошибку при возникновении исключения.

**Примеры**:

```python
from pathlib import Path
data_string = "Hello, world!"
save_text_file(data_string, "example.txt")

data_list = ["Line 1", "Line 2", "Line 3"]
save_text_file(data_list, "example.txt", mode='a')

data_dict = {"name": "John", "age": 30}
save_text_file(data_dict, "example.json")
```

### `read_text_file_generator`

**Назначение**: Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов. Поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает генератор строк. Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
- `extensions` (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
- `chunk_size` (int, optional): Размер чанка для чтения файла (в байтах). Увеличивает эффективность для очень больших файлов.
- `recursive` (bool, optional): Если `True`, рекурсивно обходит все поддиректории.
- `patterns` (str | list[str], optional): Шаблоны для фильтрации файлов (например, `'*.txt'`, `['*.txt', '*.csv']`). Используется вместе с `recursive`.

**Возвращает**:
- `Generator[str, None, None] | str | list[str] | None`: Возвращает генератор строк (`as_list=True`), строку (`as_list=False` и файл), объединенную строку из всех файлов директории (`as_list=False` и директория), или `None` в случае ошибки.

**Как работает функция**:
1. Функция проверяет, является ли `file_path` файлом или директорией.
2. Если `file_path` это файл:
    - Если `as_list` установлен в `True`, функция вызывает `_read_file_lines_generator` и возвращает генератор строк.
    - Если `as_list` установлен в `False`, функция вызывает `_read_file_content` и возвращает всё содержимое файла как строку.
3. Если `file_path` это директория:
    - Если `recursive` установлен в `True`, функция рекурсивно находит все файлы, которые соответствуют заданным `patterns` и `extensions`, и обрабатывает их.
    - Если `recursive` установлен в `False`, функция обрабатывает только файлы в текущей директории.
    - Если `as_list` установлен в `True`, функция возвращает генератор, который объединяет строки из всех обработанных файлов.
    - Если `as_list` установлен в `False`, функция возвращает объединённую строку, состоящую из содержимого всех обработанных файлов.
4. В случае возникновения ошибок, функция возвращает `None` и логирует информацию об ошибке.

**Примеры**:

```python
from pathlib import Path

# Чтение файла как генератора строк
file_path = Path("example.txt")
lines_generator = read_text_file_generator(file_path, as_list=True)
for line in lines_generator:
    print(line)

# Чтение содержимого файла как одной строки
file_path = Path("example.txt")
content = read_text_file_generator(file_path, as_list=False)
print(content)

# Чтение всех txt файлов в директории рекурсивно
dir_path = Path("my_directory")
all_lines = read_text_file_generator(dir_path, as_list=True, recursive=True, patterns="*.txt")
for line in all_lines:
    print(line)
```

### `read_text_file`

**Назначение**: Читает содержимое файла или директории. Более простая версия, чем `read_text_file_generator`, не использующая генераторы.

**Параметры**:
- `file_path` (str | Path): Путь к файлу или директории.
- `as_list` (bool, optional): Если `True`, возвращает список строк. Если `False`, возвращает строку.
- `extensions` (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
- `exc_info` (bool, optional): Если `True`, включает информацию об исключении в логи.
- `chunk_size` (int, optional): Размер чанка для чтения файла (в байтах).

**Возвращает**:
- `str | list[str] | None`: Строка (если `as_list=False`) или список строк (если `as_list=True`). `None` в случае ошибки.

**Как работает функция**:
1. Функция проверяет, является ли `file_path` файлом или директорией.
2. Если это файл:
    - Если `as_list=True`, функция возвращает список строк, полученный из файла.
    - Если `as_list=False`, функция возвращает содержимое файла в виде строки.
3. Если это директория:
    - Функция рекурсивно считывает все файлы, соответствующие указанным расширениям, и объединяет их содержимое в одну строку или список строк.

**Примеры**:

```python
from pathlib import Path

# Чтение содержимого файла как строки
file_path = Path("example.txt")
content = read_text_file(file_path, as_list=False)
print(content)

# Чтение содержимого файла как списка строк
file_path = Path("example.txt")
lines = read_text_file(file_path, as_list=True)
print(lines)

# Чтение всех файлов с расширением .txt в директории
dir_path = Path("my_directory")
all_content = read_text_file(dir_path, as_list=False, extensions=[".txt"])
print(all_content)
```

### `yield_text_from_files`

**Назначение**: Читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`). Вспомогательная функция для `read_text_file_generator`.

**Параметры**:
- `file_path` (str | Path): Путь к файлу.
- `as_list` (bool, optional): Флаг, указывающий на возврат генератора или строки.
- `chunk_size` (int, optional): Размер чанка для чтения.

**Возвращает**:
- `Generator[str, None, None] | str | None`: Генератор строк или строка, или `None` при ошибке.

**Как работает функция**:
1. Функция проверяет значение `as_list`.
2. Если `as_list` равен `True`, функция вызывает `_read_file_lines_generator` и возвращает генератор строк.
3. Если `as_list` равен `False`, функция вызывает `_read_file_content` и возвращает содержимое файла в виде одной строки.

**Примеры**:

```python
from pathlib import Path

# Получение генератора строк из файла
file_path = Path("example.txt")
lines_generator = yield_text_from_files(file_path, as_list=True)
for line in lines_generator:
    print(line)

# Получение содержимого файла как строки
file_path = Path("example.txt")
content = yield_text_from_files(file_path, as_list=False)
print(content)
```

### `_read_file_content`

**Назначение**: Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки. Используется для повышения эффективности при работе с очень большими файлами.

**Параметры**:
- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка.

**Возвращает**:
- `str`: Содержимое файла как одна строка.

**Как работает функция**:
1. Функция открывает файл для чтения в бинарном режиме.
2. Функция читает файл по частям размером `chunk_size`, накапливая данные в переменной `content`.
3. Функция декодирует накопленные данные в строку с кодировкой UTF-8.
4. Функция заменяет двойные кавычки на одинарные и удаляет лишние пробелы.
5. Функция возвращает итоговую строку.

**Примеры**:

```python
from pathlib import Path

file_path = Path("example.txt")
content = _read_file_content(file_path, chunk_size=8192)
print(content)
```

### `_read_file_lines_generator`

**Назначение**: Вспомогательная функция для чтения файла построчно с помощью генератора. Эффективна для больших файлов, поскольку не загружает весь файл в память сразу.

**Параметры**:
- `file_path` (Path): Путь к файлу.
- `chunk_size` (int): Размер чанка.

**Возвращает**:
- `Generator[str, None, None]`: Генератор, который выдает строки файла по одной.

**Как работает функция**:
1. Функция открывает файл для чтения в бинарном режиме.
2. Функция читает файл по частям размером `chunk_size`.
3. Функция декодирует полученный чанк в строку с кодировкой UTF-8.
4. Функция разделяет чанк на строки с помощью `splitlines()`.
5. Функция обрабатывает случай, когда последняя строка в чанке неполная – добавляет к ней следующий символ из файла.
6. Функция заменяет двойные кавычки на одинарные и удаляет лишние пробелы в каждой строке.
7. Функция возвращает строки с использованием `yield`.

**Примеры**:

```python
from pathlib import Path

file_path = Path("example.txt")
lines_generator = _read_file_lines_generator(file_path, chunk_size=8192)
for line in lines_generator:
    print(line)
```

### `get_filenames_from_directory`

**Назначение**: Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.

**Параметры**:
- `directory` (str | Path): Путь к директории.
- `ext` (str | list[str], optional): Расширение или список расширений файлов для фильтрации.

**Возвращает**:
- `list[str]`: Список имен файлов.

**Как работает функция**:
1. Функция преобразует путь к директории в объект `Path`.
2. Функция проверяет, является ли указанный путь директорией. Если нет, возвращает пустой список.
3. Функция перечисляет файлы в директории и возвращает список имен только тех файлов, которые соответствуют указанному расширению (или всем файлам, если `ext='*'`).

**Примеры**:

```python
from pathlib import Path

# Получение списка всех файлов в директории
dir_path = Path("my_directory")
all_files = get_filenames_from_directory(dir_path)
print(all_files)

# Получение списка файлов с расширением .txt
txt_files = get_filenames_from_directory(dir_path, ext=".txt")
print(txt_files)

# Получение списка файлов с расширениями .txt и .log
txt_log_files = get_filenames_from_directory(dir_path, ext=[".txt", ".log"])
print(txt_log_files)
```

### `recursively_yield_file_path`

**Назначение**: Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:
- `Generator[Path, None, None]`: Генератор, который выдает пути к файлам.

**Как работает функция**:
1. Функция преобразует путь к корневой директории в объект `Path`.
2. Функция использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.
3. Функция возвращает пути к найденным файлам с использованием `yield`.

**Примеры**:

```python
from pathlib import Path

# Рекурсивный поиск всех txt файлов
root_dir = Path("my_directory")
txt_files = recursively_yield_file_path(root_dir, patterns="*.txt")
for file_path in txt_files:
    print(file_path)

# Рекурсивный поиск файлов с расширениями .txt и .log
txt_log_files = recursively_yield_file_path(root_dir, patterns=["*.txt", "*.log"])
for file_path in txt_log_files:
    print(file_path)
```

### `recursively_get_file_path`

**Назначение**: Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:
- `list[Path]`: Список путей к файлам.

**Как работает функция**:
1. Функция преобразует путь к корневой директории в объект `Path`.
2. Функция использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.
3. Функция собирает все найденные пути в список и возвращает его.

**Примеры**:

```python
from pathlib import Path

# Рекурсивный поиск всех txt файлов
root_dir = Path("my_directory")
txt_files = recursively_get_file_path(root_dir, patterns="*.txt")
print(txt_files)

# Рекурсивный поиск файлов с расширениями .txt и .log
txt_log_files = recursively_get_file_path(root_dir, patterns=["*.txt", "*.log"])
print(txt_log_files)
```

### `recursively_read_text_files`

**Назначение**: Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.

**Параметры**:
- `root_dir` (str | Path): Корневая директория.
- `patterns` (str | list[str]): Шаблоны имен файлов.
- `as_list` (bool, optional): Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.

**Возвращает**:
- `list[str]`: Список содержимого файлов (либо список списков строк).

**Как работает функция**:
1. Функция преобразует путь к корневой директории в объект `Path`.
2. Функция использует `os.walk()` для рекурсивного обхода директории.
3. Функция перебирает все найденные файлы, соответствующие заданным шаблонам.
4. Функция читает содержимое каждого файла и добавляет его в результирующий список. Если `as_list` равно `True`, добавляется список строк; иначе добавляется строка с содержимым файла.

**Примеры**:

```python
from pathlib import Path

# Рекурсивное чтение всех txt файлов как строк
root_dir = Path("my_directory")
txt_content = recursively_read_text_files(root_dir, patterns="*.txt", as_list=False)
print(txt_content)

# Рекурсивное чтение всех txt файлов как списков строк
root_dir = Path("my_directory")
txt_lines = recursively_read_text_files(root_dir, patterns="*.txt", as_list=True)
print(txt_lines)
```

### `get_directory_names`

**Назначение**: Возвращает список имен поддиректорий в указанной директории.

**Параметры**:
- `directory` (str | Path): Путь к директории.

**Возвращает**:
- `list[str]`: Список имен поддиректорий.

**Как работает функция**:
1. Функция преобразует путь к директории в объект `Path`.
2. Функция проверяет, является ли указанный путь директорией. Если нет, возвращает пустой список.
3. Функция перечисляет элементы в директории и возвращает список имен только тех элементов, которые являются директориями.

**Примеры**:

```python
from pathlib import Path

dir_path = Path("my_directory")
subdirectories = get_directory_names(dir_path)
print(subdirectories)
```

### `remove_bom`

**Назначение**: Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории. BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.

**Параметры**:
- `path` (str | Path): Путь к файлу или директории.

**Возвращает**:
- `None`

**Как работает функция**:
1. Функция проверяет, является ли `path` файлом или директорией.
2. Если `path` – файл, функция удаляет BOM из него.
3. Если `path` – директория, функция рекурсивно обходит все `.py` файлы и удаляет BOM из них.

**Примеры**:

```python
from pathlib import Path

# Удаление BOM из файла
file_path = Path("example.py")
remove_bom(file_path)

# Удаление BOM из всех .py файлов в директории
dir_path = Path("my_directory")
remove_bom(dir_path)
```

### `main`

**Назначение**: Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.

**Параметры**:
- Нет

**Возвращает**:
- `None`

**Как работает функция**:
1. Функция вызывает `remove_bom()` для директории `src`.

**Примеры**:

```python
# Пример вызова функции main
main()
```