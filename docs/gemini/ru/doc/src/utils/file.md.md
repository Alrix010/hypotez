# Модуль `file.py`

## Обзор

Модуль `file.py` предоставляет набор функций для работы с файлами и директориями, включая обработку больших файлов с помощью генераторов и рекурсивный поиск файлов.  Функции хорошо структурированы и имеют ясное назначение.  Добавленные функции обработки лишних пробелов и экранирования кавычек улучшают функциональность.

## Подробнее

Модуль `file.py` расположен в `/hypotez/src/utils/file.py` и является частью проекта `hypotez`. Он предоставляет функции для удобной работы с файлами и директориями, включая:

- Запись данных в текстовые файлы
- Чтение содержимого файлов и директорий с помощью генераторов
- Рекурсивный поиск файлов в директориях
- Фильтрация файлов по расширениям и шаблонам имен
- Удаление BOM из текстовых файлов

## Классы

###  `class FileUtils`

**Описание**:  Класс `FileUtils` содержит статические методы для работы с файлами и директориями.  Он предоставляет удобные функции для чтения, записи, обработки файлов и поиска файлов по заданным критериям.

**Атрибуты**:

- `None`

**Методы**:

- `save_text_file(data, file_path, mode='w')`:  Записывает данные в указанный текстовый файл.
- `read_text_file_generator(file_path, as_list=False, extensions=None, chunk_size=8192, recursive=False, patterns=None)`:  Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов.
- `read_text_file(file_path, as_list=False, extensions=None, exc_info=True, chunk_size=8192)`:  Читает содержимое файла или директории.
- `yield_text_from_files(file_path, as_list=False, chunk_size=8192)`:  Читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`).
- `_read_file_content(file_path, chunk_size)`:  Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки.
- `_read_file_lines_generator(file_path, chunk_size)`:  Вспомогательная функция для чтения файла построчно с помощью генератора.
- `get_filenames_from_directory(directory, ext='*')`:  Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.
- `recursively_yield_file_path(root_dir, patterns='*')`:  Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.
- `recursively_get_file_path(root_dir, patterns='*')`:  Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.
- `recursively_read_text_files(root_dir, patterns, as_list=False)`:  Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.
- `get_directory_names(directory)`:  Возвращает список имен поддиректорий в указанной директории.
- `remove_bom(path)`:  Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.
- `main()`:  Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.


## Методы класса

### `save_text_file`

```python
def save_text_file(data, file_path, mode='w'):
    """
    Записывает данные в указанный текстовый файл.  Поддерживает запись строк, списков строк и словарей (словари сериализуются в JSON).

    Args:
        data (str | list[str] | dict): Данные для записи в файл.  Может быть строкой, списком строк или словарем.
        file_path (str | Path): Путь к файлу, куда нужно записать данные.  Может быть строкой или объектом `Path` из библиотеки `pathlib`.
        mode (str, optional): Режим открытия файла.  По умолчанию `'w'` (запись, перезаписывает файл).  Можно использовать `'a'` (добавление, добавляет данные в конец файла).

    Returns:
        bool: `True`, если запись прошла успешно, `False` в случае ошибки.

    Raises:
        Exception: Если возникла ошибка при записи в файл.
    """
```

**Назначение**:  Функция `save_text_file` записывает данные в указанный текстовый файл. Она поддерживает запись строк, списков строк и словарей.  В случае словарей она сериализует их в формат JSON с отступами для лучшей читаемости.

**Параметры**:

- `data (str | list[str] | dict)`: Данные для записи в файл. Может быть строкой, списком строк или словарем.
- `file_path (str | Path)`: Путь к файлу, куда нужно записать данные. Может быть строкой или объектом `Path` из библиотеки `pathlib`.
- `mode (str, optional)`: Режим открытия файла. По умолчанию `'w'` (запись, перезаписывает файл). Можно использовать `'a'` (добавление, добавляет данные в конец файла).

**Возвращает**:

- `bool`: `True`, если запись прошла успешно, `False` в случае ошибки.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при записи в файл.

**Как работает функция**:

1. Создает директории, если они не существуют, используя `file_path.parent.mkdir(parents=True, exist_ok=True)`.
2. Открывает файл в указанном режиме с кодировкой UTF-8.
3. В зависимости от типа данных `data`:
    - Если это строка, записывает её в файл.
    - Если это список строк, записывает каждую строку с добавлением символа новой строки (`\n`).
    - Если это словарь, сериализует его в JSON с отступами для читаемости и записывает в файл.
4. Возвращает `True` при успешной записи, `False` и логирует ошибку при возникновении исключения.

**Примеры**:

```python
from pathlib import Path

# Запись строки в файл
save_text_file("Hello, world!", "test.txt")

# Запись списка строк в файл
save_text_file(["Line 1", "Line 2", "Line 3"], "test.txt")

# Запись словаря в файл
data = {"name": "Alice", "age": 30}
save_text_file(data, "test.json")
```

### `read_text_file_generator`

```python
def read_text_file_generator(file_path, as_list=False, extensions=None, chunk_size=8192, recursive=False, patterns=None):
    """
    Читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов.  Поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов.

    Args:
        file_path (str | Path): Путь к файлу или директории.
        as_list (bool, optional):  Если `True`, возвращает генератор строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
        extensions (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
        chunk_size (int, optional): Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.
        recursive (bool, optional):  Если `True`, рекурсивно обходит все поддиректории.
        patterns (str | list[str], optional): Шаблоны для фильтрации файлов (например, `'*.txt'`, `['*.txt', '*.csv']`).  Используется вместе с `recursive`.

    Returns:
        Generator[str, None, None] | str | list[str] | None:  Возвращает генератор строк (`as_list=True`), строку (`as_list=False` и файл), объединенную строку из всех файлов директории (`as_list=False` и директория), или `None` в случае ошибки.

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `read_text_file_generator` читает содержимое файла или директории, используя генератор для эффективной обработки больших файлов. Она поддерживает рекурсивный поиск файлов в директориях и фильтрацию по расширениям и шаблонам имен файлов. 

**Параметры**:

- `file_path (str | Path)`: Путь к файлу или директории.
- `as_list (bool, optional)`: Если `True`, возвращает генератор строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
- `extensions (list[str], optional)`: Список расширений файлов для фильтрации при чтении директории.
- `chunk_size (int, optional)`: Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.
- `recursive (bool, optional)`: Если `True`, рекурсивно обходит все поддиректории.
- `patterns (str | list[str], optional)`: Шаблоны для фильтрации файлов (например, `'*.txt'`, `['*.txt', '*.csv']`).  Используется вместе с `recursive`.

**Возвращает**:

- `Generator[str, None, None] | str | list[str] | None`: Возвращает генератор строк (`as_list=True`), строку (`as_list=False` и файл), объединенную строку из всех файлов директории (`as_list=False` и директория), или `None` в случае ошибки.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

1. Проверяет, является ли `file_path` файлом или директорией.
2. Для файлов:
    - Если `as_list=True`, использует `_read_file_lines_generator` для возврата генератора строк.
    - Если `as_list=False`, использует `_read_file_content` для возврата всего содержимого как строки.
3. Для директорий:
    - Если `recursive=True`, рекурсивно находит все файлы, соответствующие `patterns` и `extensions`, и обрабатывает их.
    - Если `recursive=False`, обрабатывает только файлы в текущей директории.
    - Если `as_list=True`, возвращает генератор, объединяющий строки из всех файлов.
    - Если `as_list=False`, возвращает объединенную строку из всех файлов.
4. Возвращает `None` при ошибках и логирует их.

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно с помощью генератора
for line in read_text_file_generator("test.txt", as_list=True):
    print(line)

# Чтение содержимого файла как одной строки
content = read_text_file_generator("test.txt")
print(content)

# Рекурсивное чтение всех .txt файлов в директории
for line in read_text_file_generator("test_dir", recursive=True, patterns="*.txt", as_list=True):
    print(line)
```

### `read_text_file`

```python
def read_text_file(file_path, as_list=False, extensions=None, exc_info=True, chunk_size=8192):
    """
    Читает содержимое файла или директории.  Более простая версия, чем `read_text_file_generator`, не использующая генераторы.

    Args:
        file_path (str | Path): Путь к файлу или директории.
        as_list (bool, optional):  Если `True`, возвращает список строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
        extensions (list[str], optional): Список расширений файлов для фильтрации при чтении директории.
        exc_info (bool, optional): Флаг для передачи служебной информации об ошибке в логгер при возникновении исключения.
        chunk_size (int, optional): Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.

    Returns:
        str | list[str] | None: Строка (если `as_list=False`) или список строк (если `as_list=True`).  `None` в случае ошибки.

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `read_text_file` читает содержимое файла или директории. Она является более простой версией `read_text_file_generator`, не использующей генераторы.

**Параметры**:

- `file_path (str | Path)`: Путь к файлу или директории.
- `as_list (bool, optional)`: Если `True`, возвращает список строк.  Если `False`, возвращает строку (для файлов) или объединенную строку из всех файлов директории (для директорий).
- `extensions (list[str], optional)`: Список расширений файлов для фильтрации при чтении директории.
- `exc_info (bool, optional)`: Флаг для передачи служебной информации об ошибке в логгер при возникновении исключения.
- `chunk_size (int, optional)`: Размер чанка для чтения файла (в байтах).  Увеличивает эффективность для очень больших файлов.

**Возвращает**:

- `str | list[str] | None`: Строка (если `as_list=False`) или список строк (если `as_list=True`).  `None` в случае ошибки.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

Проще, чем `read_text_file_generator`. Для директорий рекурсивно считывает все файлы, соответствующие `extensions`, и объединяет их содержимое в одну строку или список строк.

**Примеры**:

```python
from pathlib import Path

# Чтение файла как строки
content = read_text_file("test.txt")
print(content)

# Чтение файла построчно
lines = read_text_file("test.txt", as_list=True)
print(lines)

# Чтение всех .txt файлов в директории
content = read_text_file("test_dir", extensions=["txt"])
print(content)
```

### `yield_text_from_files`

```python
def yield_text_from_files(file_path, as_list=False, chunk_size=8192):
    """
    Читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`).  Вспомогательная функция для `read_text_file_generator`.

    Args:
        file_path (str | Path): Путь к файлу.
        as_list (bool, optional): Флаг, указывающий на возврат генератора или строки.
        chunk_size (int, optional): Размер чанка для чтения.

    Returns:
        Generator[str, None, None] | str | None:  Генератор строк или строка, или `None` при ошибке.

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `yield_text_from_files` читает файл и возвращает его содержимое как генератор строк (`as_list=True`) или как одну строку (`as_list=False`). Она является вспомогательной функцией для `read_text_file_generator`.

**Параметры**:

- `file_path (str | Path)`: Путь к файлу.
- `as_list (bool, optional)`: Флаг, указывающий на возврат генератора или строки.
- `chunk_size (int, optional)`: Размер чанка для чтения.

**Возвращает**:

- `Generator[str, None, None] | str | None`: Генератор строк или строка, или `None` при ошибке.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

Использует `_read_file_lines_generator` или `_read_file_content` в зависимости от значения `as_list`.

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно с помощью генератора
for line in yield_text_from_files("test.txt", as_list=True):
    print(line)

# Чтение файла как одной строки
content = yield_text_from_files("test.txt")
print(content)
```

### `_read_file_content`

```python
def _read_file_content(file_path, chunk_size):
    """
    Вспомогательная функция для чтения содержимого файла по чанкам и возврата его как одной строки.  Используется для повышения эффективности при работе с очень большими файлами.

    Args:
        file_path (Path): Путь к файлу.
        chunk_size (int): Размер чанка.

    Returns:
        str:  Содержимое файла как одна строка.

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `_read_file_content` является вспомогательной функцией для чтения содержимого файла по чанкам и возврата его как одной строки.  Она используется для повышения эффективности при работе с очень большими файлами.

**Параметры**:

- `file_path (Path)`: Путь к файлу.
- `chunk_size (int)`: Размер чанка.

**Возвращает**:

- `str`: Содержимое файла как одна строка.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

Читает файл по частям размером `chunk_size`, накапливая данные в переменной `content`, и возвращает итоговую строку.  Обрабатывает лишние пробелы и экранирует кавычки.

**Примеры**:

```python
from pathlib import Path

# Чтение файла по чанкам
content = _read_file_content(Path("test.txt"), 8192)
print(content)
```

### `_read_file_lines_generator`

```python
def _read_file_lines_generator(file_path, chunk_size):
    """
    Вспомогательная функция для чтения файла построчно с помощью генератора.  Эффективна для больших файлов, поскольку не загружает весь файл в память сразу.

    Args:
        file_path (Path): Путь к файлу.
        chunk_size (int): Размер чанка.

    Returns:
        Generator[str, None, None]:  Генератор, который выдает строки файла по одной.

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `_read_file_lines_generator` является вспомогательной функцией для чтения файла построчно с помощью генератора.  Она эффективна для больших файлов, поскольку не загружает весь файл в память сразу.

**Параметры**:

- `file_path (Path)`: Путь к файлу.
- `chunk_size (int)`: Размер чанка.

**Возвращает**:

- `Generator[str, None, None]`: Генератор, который выдает строки файла по одной.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

Читает файл по чанкам, разделяет чанк на строки с помощью `splitlines()`.  Обрабатывает случай, когда последняя строка в чанке неполная –  добавляет к ней следующий символ из файла.  Обрабатывает лишние пробелы и экранирует кавычки в каждой строке.

**Примеры**:

```python
from pathlib import Path

# Чтение файла построчно с помощью генератора
for line in _read_file_lines_generator(Path("test.txt"), 8192):
    print(line)
```

### `get_filenames_from_directory`

```python
def get_filenames_from_directory(directory, ext='*'):
    """
    Возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.

    Args:
        directory (str | Path): Путь к директории.
        ext (str | list[str], optional): Расширение или список расширений файлов для фильтрации.

    Returns:
        list[str]:  Список имен файлов.

    Raises:
        Exception: Если возникла ошибка при чтении директории.
    """
```

**Назначение**:  Функция `get_filenames_from_directory` возвращает список имен файлов в указанной директории, опционально фильтруя по расширению.

**Параметры**:

- `directory (str | Path)`: Путь к директории.
- `ext (str | list[str], optional)`: Расширение или список расширений файлов для фильтрации.

**Возвращает**:

- `list[str]`: Список имен файлов.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении директории.

**Как работает функция**:

Итерирует по файлам в директории и возвращает список имен тех файлов, которые соответствуют указанному расширению (или всем файлам, если `ext='*'`).

**Примеры**:

```python
from pathlib import Path

# Получение списка имен всех файлов в директории
filenames = get_filenames_from_directory("test_dir")
print(filenames)

# Получение списка имен только .txt файлов
filenames = get_filenames_from_directory("test_dir", ext=".txt")
print(filenames)
```

### `recursively_yield_file_path`

```python
def recursively_yield_file_path(root_dir, patterns='*'):
    """
    Рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.

    Args:
        root_dir (str | Path): Корневая директория.
        patterns (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

    Returns:
        Generator[Path, None, None]:  Генератор, который выдает пути к файлам.

    Raises:
        Exception: Если возникла ошибка при чтении директории.
    """
```

**Назначение**:  Функция `recursively_yield_file_path` рекурсивно итерирует по файлам в указанной директории и её поддиректориях, возвращая пути к файлам, соответствующим заданным шаблонам.

**Параметры**:

- `root_dir (str | Path)`: Корневая директория.
- `patterns (str | list[str])`: Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:

- `Generator[Path, None, None]`: Генератор, который выдает пути к файлам.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении директории.

**Как работает функция**:

Использует `Path.rglob()` для рекурсивного поиска файлов, соответствующих заданным шаблонам.

**Примеры**:

```python
from pathlib import Path

# Рекурсивный поиск всех .txt файлов в директории
for file_path in recursively_yield_file_path("test_dir", patterns="*.txt"):
    print(file_path)
```

### `recursively_get_file_path`

```python
def recursively_get_file_path(root_dir, patterns='*'):
    """
    Рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.

    Args:
        root_dir (str | Path): Корневая директория.
        patterns (str | list[str]): Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

    Returns:
        list[Path]: Список путей к файлам.

    Raises:
        Exception: Если возникла ошибка при чтении директории.
    """
```

**Назначение**:  Функция `recursively_get_file_path` рекурсивно находит все файлы в директории и её поддиректориях, соответствующие указанным шаблонам, и возвращает список их путей.

**Параметры**:

- `root_dir (str | Path)`: Корневая директория.
- `patterns (str | list[str])`: Шаблоны имен файлов (например, `'*.txt'`, `['*.txt', '*.log']`).

**Возвращает**:

- `list[Path]`: Список путей к файлам.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении директории.

**Как работает функция**:

Использует `Path.rglob()` и собирает все найденные пути в список.

**Примеры**:

```python
from pathlib import Path

# Рекурсивный поиск всех .txt файлов в директории
file_paths = recursively_get_file_path("test_dir", patterns="*.txt")
print(file_paths)
```

### `recursively_read_text_files`

```python
def recursively_read_text_files(root_dir, patterns, as_list=False):
    """
    Рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.

    Args:
        root_dir (str | Path): Корневая директория.
        patterns (str | list[str]): Шаблоны имен файлов.
        as_list (bool, optional):  Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.

    Returns:
        list[str]: Список содержимого файлов (либо список списков строк).

    Raises:
        Exception: Если возникла ошибка при чтении файла.
    """
```

**Назначение**:  Функция `recursively_read_text_files` рекурсивно читает содержимое файлов в указанной директории, соответствующих заданным шаблонам.

**Параметры**:

- `root_dir (str | Path)`: Корневая директория.
- `patterns (str | list[str])`: Шаблоны имен файлов.
- `as_list (bool, optional)`: Если `True`, возвращает список строк для каждого файла; иначе – строку для каждого файла.

**Возвращает**:

- `list[str]`: Список содержимого файлов (либо список списков строк).

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла.

**Как работает функция**:

Использует `os.walk()` для рекурсивного обхода директории.  Читает файлы, соответствующие шаблонам, и добавляет их содержимое в результирующий список.

**Примеры**:

```python
from pathlib import Path

# Рекурсивное чтение всех .txt файлов в директории
contents = recursively_read_text_files("test_dir", patterns="*.txt")
print(contents)
```

### `get_directory_names`

```python
def get_directory_names(directory):
    """
    Возвращает список имен поддиректорий в указанной директории.

    Args:
        directory (str | Path): Путь к директории.

    Returns:
        list[str]: Список имен поддиректорий.

    Raises:
        Exception: Если возникла ошибка при чтении директории.
    """
```

**Назначение**:  Функция `get_directory_names` возвращает список имен поддиректорий в указанной директории.

**Параметры**:

- `directory (str | Path)`: Путь к директории.

**Возвращает**:

- `list[str]`: Список имен поддиректорий.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении директории.

**Как работает функция**:

Итерирует по элементам в директории и возвращает список имен только тех, которые являются директориями.

**Примеры**:

```python
from pathlib import Path

# Получение списка имен поддиректорий
directory_names = get_directory_names("test_dir")
print(directory_names)
```

### `remove_bom`

```python
def remove_bom(path):
    """
    Удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.  BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.

    Args:
        path (str | Path): Путь к файлу или директории.

    Returns:
        None.

    Raises:
        Exception: Если возникла ошибка при чтении файла или директории.
    """
```

**Назначение**:  Функция `remove_bom` удаляет BOM (Byte Order Mark) из текстового файла или из всех `.py` файлов в директории.  BOM – это невидимый символ, который может вызывать проблемы в некоторых приложениях.

**Параметры**:

- `path (str | Path)`: Путь к файлу или директории.

**Возвращает**:

- `None`.

**Вызывает исключения**:

- `Exception`: Если возникла ошибка при чтении файла или директории.

**Как работает функция**:

Если `path` – файл, удаляет BOM из него.  Если `path` – директория, рекурсивно обходит все `.py` файлы и удаляет BOM из них.

**Примеры**:

```python
from pathlib import Path

# Удаление BOM из файла
remove_bom("test.txt")

# Удаление BOM из всех .py файлов в директории
remove_bom("test_dir")
```

### `main`

```python
def main():
    """
    Точка входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.

    Args:
        None.

    Returns:
        None.
    """
```

**Назначение**:  Функция `main` является точкой входа для скрипта, который удаляет BOM из всех `.py` файлов в директории `src`.

**Параметры**:

- `None`.

**Возвращает**:

- `None`.

**Как работает функция**:

Вызывает `remove_bom()` для директории `src`.

**Примеры**:

```python
# Запуск скрипта:
python file.py
```

## Параметры класса

- `None`

## Примеры

```python
from pathlib import Path
from src.utils.file import FileUtils

# Создание объекта FileUtils
file_utils = FileUtils()

# Запись данных в файл
file_utils.save_text_file("Hello, world!", "test.txt")

# Чтение файла построчно с помощью генератора
for line in file_utils.read_text_file_generator("test.txt", as_list=True):
    print(line)

# Рекурсивный поиск всех .txt файлов в директории
for file_path in file_utils.recursively_yield_file_path("test_dir", patterns="*.txt"):
    print(file_path)

# Удаление BOM из файла
file_utils.remove_bom("test.txt")

# Запуск скрипта:
python file.py
```