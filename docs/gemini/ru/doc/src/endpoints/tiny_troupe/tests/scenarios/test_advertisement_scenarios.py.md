# Модуль для тестирования сценариев рекламы

## Обзор

Этот модуль содержит тесты, предназначенные для проверки сценариев, связанных с оценкой и созданием рекламных объявлений, а также профилированием потребителей. Он использует библиотеку `tinytroupe` для моделирования поведения агентов и среды, в которой они взаимодействуют с рекламным контентом.

## Подробнее

Модуль включает в себя следующие сценарии:
- Оценка рекламных объявлений: Агенты оценивают различные рекламные объявления, и выбирают наиболее убедительное.
- Создание рекламных объявлений: Фокус-группа обсуждает лучшие способы рекламы квартиры.
- Профилирование потребителей: Создаются профили потребителей на основе их предпочтений и реакций на маркетинговые стимулы.

## Функции

### `test_ad_evaluation_scenario`

```python
def test_ad_evaluation_scenario(setup):
    """
    Оценивает рекламные объявления, выбирая наиболее убедительное.

    Args:
        setup: Параметры настройки теста (не описаны в коде).

    Raises:
        AssertionError: Если результаты не соответствуют ожиданиям.

    Example:
        >>> test_ad_evaluation_scenario(setup)
    """
```

**Назначение**:
Функция `test_ad_evaluation_scenario` предназначена для оценки эффективности различных рекламных объявлений, моделируя процесс принятия решений агентами на основе их личностных характеристик и предоставленного контекста.

**Параметры**:
- `setup`: Параметр `setup` не имеет аннотации типов и не документирован в предоставленном коде. Предположительно, он содержит настройки и зависимости, необходимые для выполнения теста.

**Возвращает**:
Функция ничего не возвращает явно.

**Вызывает исключения**:
- `AssertionError`: Вызывается, если результаты извлечения информации из ответов агентов не соответствуют ожидаемым критериям (например, отсутствие `ad_id`, неверный формат `ad_id`, отсутствие `ad_title` или `justification`).

**Как работает функция**:
1. **Определение рекламных объявлений**: В начале функции определяются четыре рекламных объявления (`travel_ad_1`, `travel_ad_2`, `travel_ad_3`, `travel_ad_4`), каждое из которых представляет собой строку с текстом рекламного предложения для туристических услуг.
2. **Формирование запроса на оценку**: Создается строка `eval_request_msg`, содержащая запрос к агентам на оценку предоставленных рекламных объявлений. Запрос включает в себя сами объявления, а также инструкцию выбрать одно из них и объяснить свой выбор, основываясь на личном опыте и предпочтениях.
3. **Определение контекста**: Задается контекст `situation`, описывающий сценарий, в котором агенты должны представить себя планирующими отпуск в Европе и ищущими выгодные предложения.
4. **Определение цели извлечения информации**: Указывается цель `extraction_objective` для извлечения конкретной информации из ответов агентов: номер выбранного объявления, его заголовок и обоснование выбора.
5. **Создание агентов**: Создаются два агента — Оскар-архитектор и Лиза-специалист по данным — с использованием функций `create_oscar_the_architect()` и `create_lisa_the_data_scientist()`.
6. **Взаимодействие агентов с рекламными объявлениями**:
   - Для каждого агента устанавливается контекст `situation` с помощью метода `person.change_context(situation)`.
   - Агенты "слушают" запрос на оценку рекламных объявлений и "действуют" в соответствии с ним, используя метод `person.listen_and_act(eval_request_msg)`. Этот метод, вероятно, моделирует процесс обработки информации и принятия решения агентом.
7. **Извлечение результатов**:
   - Создается экземпляр класса `ResultsExtractor`.
   - Для каждого агента извлекаются результаты его выбора и обоснования с использованием метода `extractor.extract_results_from_agent()`. Результаты сохраняются в переменной `res`.
8. **Проверка результатов**:
   - Проверяется, что результат `res` не является `None`, что указывает на успешное извлечение информации.
   - Проверяется наличие ключей `"ad_id"`, `"ad_title"` и `"justification"` в словаре `res`, а также соответствие значения `ad_id` одному из допустимых вариантов (`"1"`, `"2"`, `"3"`, `"4"`).
9. **Сбор результатов**: Результаты выбора каждого агента добавляются в список `choices`.
10. **Финальная проверка**: Проверяется, что в списке `choices` содержится ровно два элемента, что соответствует количеству агентов.

**Примеры**:
В коде предоставлен пример вызова функции `test_ad_evaluation_scenario(setup)`.

### `test_ad_creation_scenario`

```python
def test_ad_creation_scenario(setup, focus_group_world):
    """
    Тестирует сценарий создания рекламных объявлений с использованием фокус-группы.

    Args:
        setup: Параметры настройки теста (не описаны в коде).
        focus_group_world: Объект, представляющий мир фокус-группы.

    Raises:
        AssertionError: Если предложенные идеи не соответствуют требованиям.

    Example:
        >>> test_ad_creation_scenario(setup, focus_group_world)
    """
```

**Назначение**:
Функция `test_ad_creation_scenario` моделирует процесс создания рекламного объявления для сдачи квартиры в аренду с использованием фокус-группы агентов, которые обсуждают лучшие способы привлечения потенциальных арендаторов.

**Параметры**:
- `setup`: Параметр `setup` не имеет аннотации типов и не документирован в предоставленном коде. Предположительно, он содержит настройки и зависимости, необходимые для выполнения теста.
- `focus_group_world`: Объект `focus_group_world`, представляющий собой виртуальный мир, в котором агенты фокус-группы взаимодействуют друг с другом. Тип этого объекта явно не указан, но можно предположить, что это экземпляр класса, моделирующего социальную среду или группу агентов.

**Возвращает**:
Функция ничего не возвращает явно.

**Вызывает исключения**:
- `AssertionError`: Вызывается, если утверждение о наличии идей для рекламы квартиры в извлеченных результатах не подтверждается. Это проверяется с помощью функции `proposition_holds`.

**Как работает функция**:
1. **Определение контекста**:
   - Задается контекст `situation`, описывающий цель фокус-группы — найти лучший способ рекламы квартиры для сдачи в аренду.
   - Предоставляется описание квартиры `apartment_description`, включающее характеристики, такие как расположение, ремонт, планировка и доступные удобства.
   - Определяется задача `task` для фокус-группы — обсудить лучшие способы рекламы квартиры.
2. **Настройка фокус-группы**:
   - Фокус-группа представлена объектом `focus_group_world`.
3. **Взаимодействие агентов в фокус-группе**:
   - Информация о контексте, описании квартиры и задаче "распространяется" среди агентов в фокус-группе с помощью метода `focus_group.broadcast()`. Это может означать, что каждый агент получает эту информацию и использует ее для формирования своего мнения.
   - Фокус-группа "запускается" на 2 итерации с помощью метода `focus_group.run(2)`. Это может моделировать процесс обсуждения и взаимодействия между агентами в течение определенного времени.
4. **Извлечение результатов**:
   - Создается экземпляр класса `ResultsExtractor`.
   - Извлекаются результаты обсуждения из виртуального мира фокус-группы с помощью метода `extractor.extract_results_from_world()`. Параметр `verbose=True` указывает на то, что процесс извлечения должен быть подробным.
5. **Проверка результатов**:
   - Проверяется, содержит ли извлеченный результат `res` идеи для рекламы квартиры. Это делается с помощью функции `proposition_holds()`, которая, вероятно, использует LLM (Language Model) для проверки соответствия утверждения ("The following contains ideas for an apartment advertisement") содержанию результата `res`.

**Примеры**:
В коде предоставлен пример вызова функции `test_ad_creation_scenario(setup, focus_group_world)`.

### `test_consumer_profiling_scenario`

```python
def test_consumer_profiling_scenario(setup):
    """
    Тестирует сценарий профилирования потребителей.

    Args:
        setup: Параметры настройки теста (не описаны в коде).

    Raises:
        AssertionError: Если файл кэша не создан.

    Example:
        >>> test_consumer_profiling_scenario(setup)
    """
```

**Назначение**:
Функция `test_consumer_profiling_scenario` предназначена для моделирования процесса профилирования потребителей на основе их ответов на вопросы о предпочтениях и отношении к определенному продукту (в данном случае, бутилированному гаспачо).

**Параметры**:
- `setup`: Параметр `setup` не имеет аннотации типов и не документирован в предоставленном коде. Предположительно, он содержит настройки и зависимости, необходимые для выполнения теста.

**Возвращает**:
Функция ничего не возвращает явно.

**Вызывает исключения**:
- `AssertionError`: Вызывается, если после выполнения процесса профилирования не был создан файл кэша `test_consumer_profiling_scenario.cache.json`.

**Как работает функция**:
1. **Подготовка к профилированию**:
   - Удаляется файл кэша `test_consumer_profiling_scenario.cache.json`, если он существует.
   - Начинается процесс контроля с использованием функции `control.begin()`, которая, вероятно, инициализирует систему кэширования или логирования для сохранения состояния выполнения теста.
2. **Определение контекста**:
   - Задается общий контекст `general_context`, описывающий цель исследования рынка и важность мнения различных слоев населения.
3. **Создание фабрики потребителей**:
   - Создается экземпляр класса `TinyPersonFactory` с использованием общего контекста. Эта фабрика используется для генерации потребителей с различными характеристиками и предпочтениями.
4. **Интервьюирование потребителей**:
   - Определяется функция `interview_consumer_batch(n)`, которая выполняет интервьюирование `n` потребителей.
   - В цикле для каждого потребителя:
     - Генерируется случайный потребитель с помощью метода `consumer_factory.generate_person()`.
     - Потребителю задаются вопросы о его личности, интересах и отношении к бутилированному гаспачо с помощью метода `consumer.listen_and_act()`.
     - Результаты интервью добавляются в список `consumers`.
     - Состояние выполнения сохраняется с помощью функции `control.checkpoint()`.
5. **Запуск процесса интервьюирования**:
   - Вызывается функция `interview_consumer_batch(15)` для проведения интервью с 15 потребителями.
6. **Проверка результатов**:
   - Проверяется, был ли создан файл кэша `test_consumer_profiling_scenario.cache.json`, что свидетельствует об успешном сохранении состояния выполнения теста.
7. **Завершение процесса контроля**:
   - Завершается процесс контроля с использованием функции `control.end()`.

**Внутренние функции**:

### `interview_consumer_batch`

```python
def interview_consumer_batch(n):
    """
    Выполняет серию интервью с потребителями.

    Args:
        n (int): Количество потребителей для интервьюирования.
    """
```

**Назначение**:
Функция `interview_consumer_batch` выполняет серию интервью с заданным количеством потребителей, генерируя каждого потребителя случайным образом и задавая им вопросы для выявления их предпочтений и отношения к продукту.

**Параметры**:
- `n` (int): Количество потребителей, с которыми необходимо провести интервью.

**Возвращает**:
Функция ничего не возвращает явно.

**Как работает функция**:
1. **Цикл по потребителям**: Функция выполняет цикл `for` `n` раз, где `n` - это количество потребителей, которых необходимо опросить.
2. **Генерация потребителя**: На каждой итерации цикла создается новый объект `consumer` с использованием фабрики `consumer_factory`. Метод `generate_person("A random person with highly detailed preferences.")` фабрики создает потребителя со случайными, но детализированными предпочтениями.
3. **Представление потребителя**: Вызывается метод `consumer.minibio()`, который, вероятно, возвращает краткое описание потребителя (мини-биографию). Это описание выводится в консоль для отслеживания процесса.
4. **Задание вопросов потребителю**: Потребителю задаются вопросы с использованием метода `consumer.listen_and_act()`. В данном коде задаются следующие вопросы:
   - "We are performing some market research and need to know you more. Can you please present yourself and also list your top-10 interests?" (Представьтесь и перечислите свои 10 главных интересов).
   - "Would you buy bottled gazpacho if you went to the supermarket today? Why yes, or why not? Please be honest, we are not here to judge you, but just to learn from you.\n We know these choices depend on many factors, but please make your best guess, consider your current situation in life, location, job and interests,\n and tell us whether you would buy bottled gazpacho or not. To make it easier, start your response with "Yes, " or "No, "." (Купили бы вы бутилированный гаспачо в супермаркете сегодня? Почему да или почему нет? Будьте честны, мы здесь не для того, чтобы судить вас, а просто чтобы учиться у вас. Мы знаем, что эти решения зависят от многих факторов, но, пожалуйста, сделайте свой лучший выбор, учитывайте свою текущую жизненную ситуацию, местоположение, работу и интересы, и скажите нам, купили бы вы бутилированный гаспачо или нет. Чтобы было проще, начните свой ответ с "Да, " или "Нет, ".).
5. **Добавление потребителя в список**: Объект `consumer` добавляется в список `consumers`.
6. **Создание контрольной точки**: Вызывается функция `control.checkpoint()`, которая, вероятно, сохраняет текущее состояние выполнения программы (например, состояние списка `consumers`) для последующего восстановления или анализа.

**Примеры**:
В коде вызывается функция `interview_consumer_batch(15)`, указывая на то, что будет проведено 15 интервью с потребителями.