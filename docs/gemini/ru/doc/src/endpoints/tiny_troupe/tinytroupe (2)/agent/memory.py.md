# Модуль `memory.py`

## Обзор

Модуль содержит классы для реализации различных типов памяти агента в системе `tinytroupe`. Включает базовый класс `TinyMemory` и его подклассы `EpisodicMemory` и `SemanticMemory`, предназначенные для хранения и извлечения информации разных типов (эпизодической и семантической соответственно).

## Подробнее

Модуль предоставляет инструменты для управления памятью агента, позволяя сохранять и извлекать информацию о прошлых событиях и общих знаниях. `TinyMemory` является абстрактным базовым классом, определяющим интерфейс для работы с памятью, в то время как `EpisodicMemory` и `SemanticMemory` реализуют конкретные типы памяти.

## Классы

### `TinyMemory`

**Описание**: Базовый класс для различных типов памяти.

**Наследует**: `TinyMentalFaculty`

**Методы**:

- `_preprocess_value_for_storage(value: Any) -> Any`: Предобрабатывает значение перед сохранением в памяти. По умолчанию не выполняет никаких действий.
- `_store(value: Any) -> None`: Абстрактный метод для хранения значения в памяти. Должен быть реализован в подклассах.
- `store(value: dict) -> None`: Сохраняет значение в памяти, предварительно обработав его.
- `store_all(values: list) -> None`: Сохраняет список значений в памяти.
- `retrieve(first_n: int, last_n: int, include_omission_info: bool = True) -> list`: Абстрактный метод для извлечения значений из памяти. Должен быть реализован в подклассах.
- `retrieve_recent() -> list`: Абстрактный метод для извлечения последних значений из памяти. Должен быть реализован в подклассах.
- `retrieve_all() -> list`: Абстрактный метод для извлечения всех значений из памяти. Должен быть реализован в подклассах.
- `retrieve_relevant(relevance_target: str, top_k=20) -> list`: Абстрактный метод для извлечения значений, релевантных заданной цели. Должен быть реализован в подклассах.

### `EpisodicMemory`

**Описание**: Предоставляет возможности эпизодической памяти для агента. Эпизодическая память - это способность помнить конкретные события или эпизоды в прошлом.

**Наследует**: `TinyMemory`

**Атрибуты**:
- `MEMORY_BLOCK_OMISSION_INFO (dict)`: Информационное сообщение, включаемое при пропуске части сообщений для краткости.
- `fixed_prefix_length (int)`: Фиксированная длина префикса памяти.
- `lookback_length (int)`: Длина "взгляда назад" для извлечения недавних значений.
- `memory (list)`: Список, хранящий значения в памяти.

**Методы**:

- `__init__(fixed_prefix_length: int = 100, lookback_length: int = 100) -> None`: Инициализирует память.
    - **Параметры**:
        - `fixed_prefix_length (int)`: Фиксированная длина префикса. По умолчанию 100.
        - `lookback_length (int)`: Длина для просмотра последних значений. По умолчанию 100.

- `_store(value: Any) -> None`: Сохраняет значение в памяти, добавляя его в список `self.memory`.
- `count() -> int`: Возвращает количество значений в памяти.
- `retrieve(first_n: int, last_n: int, include_omission_info: bool = True) -> list`: Извлекает первые `n` и/или последние `n` значений из памяти.
    - **Параметры**:
        - `first_n (int)`: Количество первых значений для извлечения.
        - `last_n (int)`: Количество последних значений для извлечения.
        - `include_omission_info (bool)`: Включать ли информационное сообщение при пропуске значений. По умолчанию `True`.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    - **Как работает функция**:
        Функция извлекает данные из памяти в зависимости от указанных параметров `first_n` и `last_n`. Она вызывает вспомогательные методы `retrieve_first` и `retrieve_last` для извлечения соответствующих частей памяти. Если `include_omission_info` равно `True`, функция также добавляет информационное сообщение `EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO` для указания на пропуск значений.

- `retrieve_recent(include_omission_info: bool = True) -> list`: Извлекает `n` самых последних значений из памяти.
    - **Параметры**:
        - `include_omission_info (bool)`: Включать ли информационное сообщение при пропуске значений. По умолчанию `True`.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    - **Как работает функция**:
        Функция извлекает последние значения из памяти, учитывая параметры `fixed_prefix_length` и `lookback_length`. Сначала вычисляется фиксированный префикс, а затем оставшиеся значения для просмотра. Если `include_omission_info` равно `True`, функция также добавляет информационное сообщение `EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO` между фиксированным префиксом и последними значениями.

- `retrieve_all() -> list`: Извлекает все значения из памяти.
- `retrieve_relevant(relevance_target: str, top_k: int) -> list`: Извлекает `top_k` значений из памяти, наиболее релевантных заданной цели.
    - **Параметры**:
        - `relevance_target (str)`: Цель релевантности.
        - `top_k (int)`: Количество наиболее релевантных значений для извлечения.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    - **Вызывает исключения**:
        - `NotImplementedError`: Метод не реализован в текущем классе.
- `retrieve_first(n: int, include_omission_info: bool = True) -> list`: Извлекает первые `n` значений из памяти.
    - **Параметры**:
        - `n (int)`: Количество первых значений для извлечения.
        - `include_omission_info (bool)`: Включать ли информационное сообщение при пропуске значений. По умолчанию `True`.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    -  **Как работает функция**:
       Функция извлекает первые `n` значений из списка `self.memory`. Если `include_omission_info` равно `True`, функция также добавляет информационное сообщение `EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO` в конец возвращаемого списка.

- `retrieve_last(n: int, include_omission_info: bool = True) -> list`: Извлекает последние `n` значений из памяти.
    - **Параметры**:
        - `n (int)`: Количество последних значений для извлечения.
        - `include_omission_info (bool)`: Включать ли информационное сообщение при пропуске значений. По умолчанию `True`.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    - **Как работает функция**:
        Функция извлекает последние `n` значений из списка `self.memory`. Если `include_omission_info` равно `True`, функция также добавляет информационное сообщение `EpisodicMemory.MEMORY_BLOCK_OMISSION_INFO` в начало возвращаемого списка.

### `SemanticMemory`

**Описание**: Реализует семантическую память, хранящую значения, понимания и знания, не связанные с конкретными эпизодами.

**Наследует**: `TinyMemory`

**Атрибуты**:
- `memories (list)`: Список для хранения семантической информации.
- `serializable_attrs (list)`: Список атрибутов для сериализации.
- `semantic_grounding_connector (BaseSemanticGroundingConnector)`: Коннектор для семантического обоснования.

**Методы**:

- `__init__(memories: list = None) -> None`: Инициализирует семантическую память.
    - **Параметры**:
        - `memories (list)`: Список начальных значений для памяти. По умолчанию `None`.
- `_post_init(self)`: Выполняет постобработку после инициализации, настраивая `semantic_grounding_connector`.
- `_preprocess_value_for_storage(self, value: dict) -> Any`: Преобразует значение в формат, пригодный для хранения, на основе типа значения ('action' или 'stimulus').
    - **Параметры**:
        - `value (dict)`: Значение для преобразования. Ожидается, что значение будет словарем с ключами 'type', 'simulation_timestamp' и 'content'.
    - **Возвращает**:
        - `engram (str)`: Преобразованное значение в виде строки, пригодной для хранения в памяти.
    - **Как работает функция**:
        Функция проверяет тип переданного значения (словаря). Если тип равен 'action', она формирует строку с информацией о выполненном действии, включая дату и время симуляции и содержание действия. Если тип равен 'stimulus', она формирует строку с информацией о полученном стимуле, также включая дату и время симуляции и содержание стимула.

- `_store(self, value: Any) -> None`: Сохраняет значение в памяти, предварительно обработав его и добавив как документ в `semantic_grounding_connector`.
- `retrieve_relevant(self, relevance_target: str, top_k=20) -> list`: Извлекает значения из памяти, релевантные заданной цели.
    - **Параметры**:
        - `relevance_target (str)`: Цель релевантности.
        - `top_k (int)`: Количество наиболее релевантных значений для извлечения.
    - **Возвращает**:
        - `list`: Извлеченные значения.
    - **Как работает функция**:
        Функция использует `semantic_grounding_connector` для извлечения `top_k` наиболее релевантных значений из семантической памяти на основе заданной цели (`relevance_target`).
- `_build_document_from(memory) -> Document`: Создает документ из переданной памяти. Используется для совместимости.
- `_build_documents_from(self, memories: list) -> list`: Создает список документов из списка воспоминаний. Используется для совместимости.

## Примеры

### Инициализация и использование `EpisodicMemory`

```python
from tinytroupe.agent.memory import EpisodicMemory

# Инициализация эпизодической памяти
episodic_memory = EpisodicMemory(fixed_prefix_length=50, lookback_length=50)

# Сохранение значений в памяти
episodic_memory.store({'role': 'user', 'content': 'Hello, how are you?', 'simulation_timestamp': '2024-07-04 10:00:00'})
episodic_memory.store({'role': 'assistant', 'content': 'I am doing well, thank you!', 'simulation_timestamp': '2024-07-04 10:01:00'})

# Извлечение последних значений из памяти
recent_values = episodic_memory.retrieve_recent()
print(recent_values)

# Извлечение всех значений из памяти
all_values = episodic_memory.retrieve_all()
print(all_values)
```

### Инициализация и использование `SemanticMemory`

```python
from tinytroupe.agent.memory import SemanticMemory

# Инициализация семантической памяти
semantic_memory = SemanticMemory()

# Сохранение значений в памяти
semantic_memory.store({'type': 'action', 'content': 'I went to the store.', 'simulation_timestamp': '2024-07-04 10:00:00'})
semantic_memory.store({'type': 'stimulus', 'content': 'I saw a red car.', 'simulation_timestamp': '2024-07-04 10:01:00'})

# Извлечение релевантных значений из памяти
relevant_values = semantic_memory.retrieve_relevant(relevance_target='travel')
print(relevant_values)