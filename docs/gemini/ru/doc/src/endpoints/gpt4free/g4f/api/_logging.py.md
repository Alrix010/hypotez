# Модуль для обработки исключений и ведения логов

## Обзор

Этот модуль предоставляет функции для обработки исключений и ведения логов. Он включает в себя:

- `__exception_handle`: Функция, которая перехватывает исключения, выводит сообщение об ошибке и завершает работу программы, если возникло исключение `KeyboardInterrupt` (например, при нажатии Ctrl+C).
- `hook_except_handle`: Функция, которая устанавливает `__exception_handle` в качестве обработчика исключений для текущей программы.
- Комментарии к неиспользуемому коду: Этот модуль содержит закомментированный код, который был предназначен для использования `loguru` для ведения логов, но в конечном итоге был заменен стандартным модулем `logging`. 

## Подробнее

Этот модуль обеспечивает централизованную обработку исключений в проекте, что делает его более устойчивым к неожиданным ошибкам. Функция `__exception_handle` позволяет перехватывать исключения, выводить сообщения об ошибке и завершать работу программы в случае возникновения `KeyboardInterrupt`. 

## Функции

### `__exception_handle`

```python
def __exception_handle(e_type, e_value, e_traceback):
    """
    Функция, которая перехватывает исключения, выводит сообщение об ошибке и завершает работу программы, если возникло исключение `KeyboardInterrupt`.

    Args:
        e_type: Тип исключения.
        e_value: Значение исключения.
        e_traceback: Трассировка стека исключения.

    Returns:
        None

    Example:
        >>> try:
        ...    raise ValueError('Ошибка')
        ... except Exception as ex:
        ...    __exception_handle(type(ex), ex, ex.__traceback__)
        Ошибка
    """
    if issubclass(e_type, KeyboardInterrupt):
        print('\nBye...')
        sys.exit(0)

    sys.__excepthook__(e_type, e_value, e_traceback)
```
#### **Назначение**: 
    - Эта функция перехватывает исключения, выводит сообщение об ошибке и завершает работу программы, если возникло исключение `KeyboardInterrupt`.
#### **Параметры**: 
    - `e_type`: Тип исключения.
    - `e_value`: Значение исключения.
    - `e_traceback`: Трассировка стека исключения.
#### **Возвращает**: 
    - `None`.
#### **Как работает функция**:
    - Функция проверяет, является ли перехваченное исключение `KeyboardInterrupt`. Если да, то она выводит сообщение "Bye..." и завершает работу программы с помощью `sys.exit(0)`. 
    - В противном случае она вызывает `sys.__excepthook__(e_type, e_value, e_traceback)`, чтобы обеспечить стандартную обработку исключений.
#### **Примеры**:
    ```python
        >>> try:
        ...    raise ValueError('Ошибка')
        ... except Exception as ex:
        ...    __exception_handle(type(ex), ex, ex.__traceback__)
        Ошибка
    ```

### `hook_except_handle`

```python
def hook_except_handle():
    """
    Функция, которая устанавливает `__exception_handle` в качестве обработчика исключений для текущей программы.

    Args:
        None

    Returns:
        None
    """
    sys.excepthook = __exception_handle
```
#### **Назначение**: 
    - Эта функция устанавливает `__exception_handle` в качестве обработчика исключений для текущей программы.
#### **Параметры**: 
    - `None`.
#### **Возвращает**: 
    - `None`.
#### **Как работает функция**:
    - Функция присваивает `__exception_handle` атрибуту `sys.excepthook`. Это означает, что теперь все исключения, которые не были перехвачены в коде, будут обрабатываться `__exception_handle`. 
#### **Примеры**:
    ```python
    >>> hook_except_handle()
    >>> try:
    ...    raise ValueError('Ошибка')
    ... except Exception as ex:
    ...    print('Ошибка перехвачена')
    Ошибка
    >>> try:
    ...    raise KeyboardInterrupt()
    ... except Exception as ex:
    ...    print('Ошибка перехвачена')
    Bye...
    ```

## Закомментированный код

### `__InterceptHandler`

```python
#class __InterceptHandler(logging.Handler):
#    def emit(self, record):
#        try:
#            level = logger.level(record.levelname).name
#        except ValueError:
#            level = record.levelno
#
#        frame, depth = logging.currentframe(), 2
#        while frame.f_code.co_filename == logging.__file__:
#            frame = frame.f_back
#            depth += 1
#
#        logger.opt(depth=depth, exception=record.exc_info).log(
#            level, record.getMessage()
#        )
```
#### **Назначение**: 
    - Этот класс был предназначен для использования с `loguru` для перехвата сообщений из стандартного модуля `logging` и перенаправления их в `loguru` для ведения логов.
#### **Параметры**: 
    - `None`.
#### **Возвращает**: 
    - `None`.
#### **Как работает класс**:
    - Класс `__InterceptHandler` наследует от `logging.Handler`. 
    - Метод `emit` перехватывает сообщение из стандартного модуля `logging`, извлекает уровень лога и отправляет его в `loguru` с помощью `logger.opt`. 
#### **Примеры**:
    - Этот код был закомментирован, поэтому примеры отсутствуют.

## **Дополнительные замечания**:

- Этот модуль предоставляет простую, но эффективную реализацию обработки исключений и ведения логов. 
- Комментарии к неиспользуемому коду предоставляют контекст для понимания истории развития этого модуля.
- Модуль предоставляет базовые функции для обработки ошибок и может быть расширен для поддержки более сложных сценариев.