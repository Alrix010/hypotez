# Модуль для копирования медиафайлов 

## Обзор

Модуль `copy_images.py`  предназначен для загрузки и сохранения медиафайлов (изображений, аудио, видео) локально, с использованием безопасных для Unicode имен файлов.

## Подробнее

Данный модуль используется для решения следующей задачи: 

- **Загрузка медиафайлов:**  Модуль запрашивает медиафайлы по указанным URL-адресам и сохраняет их локально в папке `./generated_images`. 
- **Создание безопасных имен файлов:**  Для предотвращения ошибок, связанных с Unicode-символами в именах файлов, модуль использует функцию `secure_filename`  для создания  безопасных имен файлов.
- **Обработка различных типов медиафайлов:**  Модуль поддерживает различные типы медиафайлов, включая изображения, аудио и видео. 

## Классы

### `class BackendApi`

**Описание**:  Класс  `BackendApi`  предоставляет информацию о бекенд-API (API-интерфейсе) и  используется  для настройки запросов к этому API. 

**Атрибуты**:

- `working`: (bool): Флаг, указывающий на то, работает ли API. 
- `url`: (str): Базовый URL-адрес API.
- `headers`: (dict): Заголовки запросов к API. 
- `ssl`: (bool): Флаг, указывающий на то, нужно ли использовать SSL-соединение для запросов к API.

**Методы**:

- `None`


## Функции

### `get_media_extension`

**Назначение**: Извлечение расширения медиафайла из URL или имени файла.

**Параметры**:

- `media` (str): URL-адрес или имя файла.

**Возвращает**:

- `str`: Расширение медиафайла (например, `.jpg`, `.png`, `.mp3`, `.mp4`).

**Вызывает исключения**:

- `ValueError`: Если расширение файла не поддерживается.

**Как работает функция**:

1. Функция извлекает путь к файлу из URL или имени файла с использованием функции `urlparse.path`.
2. Использует функцию `os.path.splitext` для получения расширения файла из пути.
3. Если расширение файла не было найдено, оно извлекается из самого имени файла. 
4. Если расширение файла все еще не было найдено, функция возвращает пустую строку.
5. Проверяется, является ли расширение файла допустимым. 
6. Если расширение файла не поддерживается, функция выдает исключение `ValueError`.
7. Возвращается расширение файла.


### `ensure_images_dir`

**Назначение**:  Создание папки `generated_images`, если она еще не существует.

**Параметры**: 

- `None`

**Возвращает**:

- `None`

**Вызывает исключения**:

- `None`

**Как работает функция**:

1. Функция использует функцию `os.makedirs` для создания папки `generated_images`.
2. Параметр `exist_ok=True` гарантирует, что функция не вызовет исключение, если папка уже существует.


### `get_source_url`

**Назначение**:  Извлечение исходного URL из параметра `image`, если он присутствует.

**Параметры**:

- `image` (str):  Строка, которая может содержать исходный URL. 
- `default` (str): Значение по умолчанию, которое возвращается, если исходный URL не найден. 

**Возвращает**:

- `str`: Исходный URL, если он был найден, или значение `default` в противном случае.

**Вызывает исключения**:

- `None`

**Как работает функция**:

1. Функция проверяет, содержит ли строка `image` подстроку `url=`.
2. Если да, то функция извлекает часть строки после `url=` и декодирует ее с помощью функции `unquote`.
3. Если декодированный URL начинается с `http://` или `https://`, функция возвращает его. 
4. В противном случае функция возвращает значение `default`.


### `is_valid_media_type`

**Назначение**: Проверка, является ли заданный тип контента допустимым типом медиафайла.

**Параметры**:

- `content_type` (str):  Тип контента. 

**Возвращает**:

- `bool`:  `True`, если тип контента является допустимым типом медиафайла, или `False` в противном случае.

**Вызывает исключения**:

- `None`

**Как работает функция**:

1. Проверяется, содержится ли тип контента в словаре `MEDIA_TYPE_MAP` или начинается ли он с `audio/` или `video/`.
2. Если да, то функция возвращает `True`.
3. В противном случае функция возвращает `False`.


### `save_response_media`

**Назначение**: Сохранение медиафайла из ответа  (StreamResponse)  в локальный файл и возвращение URL-адреса сохраненного файла.

**Параметры**:

- `response` (StreamResponse): Ответ, содержащий медиафайл. 
- `prompt` (str): Текст запроса. 
- `tags` (list[str]): Список тегов. 

**Возвращает**:

- `AsyncIterator`:  Генератор, который последовательно  возвращает  объекты  `ImageResponse`, `AudioResponse` или  `VideoResponse` с URL-адресом сохраненного файла.

**Вызывает исключения**:

- `ValueError`:  Если тип контента не поддерживается.

**Как работает функция**:

1. Извлекается тип контента из заголовков ответа.
2. Определяется расширение файла, соответствующее типу контента. 
3.  Генерируется уникальное имя файла, использующее временную метку, хэш-сумму запроса и теги.
4.  Создается локальный путь к файлу, используя папку `images_dir` и имя файла.
5.  Медиафайл сохраняется в локальный файл.
6.  Создается относительный URL-адрес сохраненного файла.
7.  В зависимости от типа контента (изображение, аудио или видео) создается соответствующий объект `ImageResponse`, `AudioResponse` или `VideoResponse` и возвращается через генератор.


### `get_filename`

**Назначение**: Генерация уникального имени файла для медиафайла.

**Параметры**:

- `tags` (list[str]):  Список тегов. 
- `alt` (str):  Альтернативный текст. 
- `extension` (str):  Расширение файла. 
- `image` (str):  URL или имя файла.

**Возвращает**:

- `str`:  Уникальное имя файла, использующее временную метку, хэш-сумму запроса, теги и расширение файла.

**Вызывает исключения**:

- `None`

**Как работает функция**:

1. Формируется  начальная часть  имени файла,  используя временную метку. 
2. Если список тегов не пуст,  к  имени  файла добавляется строка, созданная путем объединения тегов, очищенных с помощью функции `secure_filename`. 
3.  К имени файла добавляется альтернативный текст, очищенный с помощью функции `secure_filename`.
4.  К имени файла добавляется  16-значный хэш-суммы  URL-адреса  или имени файла.
5.  К имени файла добавляется расширение файла.
6.  Возвращается полное имя файла.


### `copy_media`

**Назначение**:  Загрузка и сохранение медиафайлов локально с использованием безопасных для Unicode имен файлов.

**Параметры**:

- `images` (list[str]): Список URL-адресов или имен файлов. 
- `cookies` (Optional[Cookies], optional): Словарь с cookie-файлами. По умолчанию `None`.
- `headers` (Optional[dict], optional): Словарь с заголовками запросов. По умолчанию `None`.
- `proxy` (Optional[str], optional): URL-адрес прокси-сервера. По умолчанию `None`.
- `alt` (str):  Альтернативный текст. 
- `tags` (list[str]): Список тегов.
- `add_url` (bool):  Флаг, указывающий на то, нужно ли добавить исходный URL к имени файла. По умолчанию `True`.
- `target` (str): Путь к целевой папке для сохранения файлов. По умолчанию `None`.
- `ssl` (bool):  Флаг, указывающий на то, нужно ли использовать SSL-соединение для запросов. По умолчанию `None`.

**Возвращает**:

- `list[str]`: Список относительных URL-адресов сохраненных файлов.

**Вызывает исключения**:

- `ClientError`:  Ошибка HTTP-запроса.
- `IOError`:  Ошибка ввода/вывода.
- `OSError`:  Системная ошибка.
- `ValueError`:  Неверный формат данных.

**Как работает функция**:

1. Если параметр `add_url` не был задан, он устанавливается в `True`, если не заданы cookie-файлы.
2. Вызывается функция `ensure_images_dir` для создания папки `images_dir`, если она еще не существует.
3.  Создается  `ClientSession`  с  помощью  `aiohttp`,   настроенный  с  указанными  cookie-файлами, заголовками и прокси-сервером. 
4.  Создается   асинхронная   функция  `copy_image`,  которая  обрабатывает   отдельные   медиафайлы. 
5.  Внутри  `copy_image`: 
   - Проверяется,  является  ли  URL  локальным  (начинается  с  `/`). 
   - Если  да,  то  возвращается   исходный  URL.
   - Если  URL  не  локальный,  то: 
     - Если  `target`  не  задан,  то  генерируется  уникальное  имя  файла.
     -  Если  `image`  начинается  с  `data:`,  то  медиафайл   извлекается  из  data  URI  и  сохраняется   в  локальный   файл.
     -  Если  `image`  не  начинается  с  `data:`,  то: 
       -  Определяется,  необходимо  ли  использовать  BackendApi.
       -  Выполняется   HTTP-запрос  к  `image`.
       -  Проверяется  тип  контента. 
       -  Медиафайл   сохраняется  в  локальный  файл. 
     -  Проверяется  формат  файла.  
     -  Создается  относительный  URL  сохраненного  файла.
6.  Функция  `copy_media`  использует   `asyncio.gather`  для  одновременной   обработки  всех  URL-адресов  в  списке  `images`.
7.  Возвращается  список  относительных   URL-адресов  сохраненных  файлов.

## Примеры 

```python
from src.endpoints.gpt4free.g4f.image.copy_images import copy_media

# Пример: загрузка одного изображения
image_url = "https://example.com/image.jpg"
result = asyncio.run(copy_media(images=[image_url]))
print(result) # ['/media/1697176523_image.jpg?url=https%3A%2F%2Fexample.com%2Fimage.jpg']

# Пример: загрузка нескольких изображений
image_urls = ["https://example.com/image1.jpg", "https://example.com/image2.png"]
result = asyncio.run(copy_media(images=image_urls))
print(result) # ['/media/1697176523_image1.jpg?url=https%3A%2F%2Fexample.com%2Fimage1.jpg', '/media/1697176523_image2.png?url=https%3A%2F%2Fexample.com%2Fimage2.png']

# Пример: загрузка с использованием cookie-файлов
cookies = {"session_id": "1234567890"}
result = asyncio.run(copy_media(images=[image_url], cookies=cookies))
print(result) # ['/media/1697176523_image.jpg?url=https%3A%2F%2Fexample.com%2Fimage.jpg']

# Пример: загрузка с использованием прокси-сервера
proxy = "http://proxy.example.com:8080"
result = asyncio.run(copy_media(images=[image_url], proxy=proxy))
print(result) # ['/media/1697176523_image.jpg?url=https%3A%2F%2Fexample.com%2Fimage.jpg']

# Пример: сохранение файлов в определенной папке
target_path = "./my_images"
result = asyncio.run(copy_media(images=[image_url], target=target_path))
print(result) # ['/media/1697176523_image.jpg?url=https%3A%2F%2Fexample.com%2Fimage.jpg']