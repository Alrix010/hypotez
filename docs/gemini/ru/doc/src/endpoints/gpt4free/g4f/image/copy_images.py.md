# Модуль для копирования изображений

## Обзор

Модуль `copy_images.py` предназначен для загрузки и локального хранения изображений, а также для формирования URL-адресов, безопасных для Unicode. Он включает в себя функции для обработки различных типов медиафайлов, проверки их формата и создания безопасных имен файлов.

## Подробнее

Этот модуль предоставляет функциональность для копирования изображений с удаленных серверов и сохранения их локально, обеспечивая при этом безопасное обращение с именами файлов, содержащими Unicode-символы. Он также обрабатывает изображения, представленные в формате Data URI. Модуль использует асинхронные операции для эффективной загрузки и обработки медиафайлов.

## Функции

### `get_media_extension`

```python
def get_media_extension(media: str) -> str:
    """Extract media file extension from URL or filename"""
```

**Назначение**: Извлекает расширение медиафайла из URL или имени файла.

**Параметры**:
- `media` (str): URL или имя файла.

**Возвращает**:
- `str`: Расширение файла (например, ".png", ".jpg"). Возвращает пустую строку, если расширение не найдено.

**Вызывает исключения**:
- `ValueError`: Если расширение файла не поддерживается.

**Принцип работы**:
Функция `get_media_extension` анализирует переданный URL или имя файла, чтобы извлечь расширение медиафайла. Сначала она пытается извлечь расширение из пути URL, затем из имени файла. Если расширение не найдено, возвращается пустая строка. Если расширение не поддерживается (отсутствует в `EXTENSIONS_MAP`), вызывается исключение `ValueError`.

**Примеры**:

```python
>>> get_media_extension("https://example.com/image.png")
'.png'
>>> get_media_extension("image.jpg")
'.jpg'
>>> get_media_extension("audio.mp3")
'.mp3'
```

### `ensure_images_dir`

```python
def ensure_images_dir():
    """Create images directory if it doesn't exist"""
```

**Назначение**: Создает директорию для изображений, если она не существует.

**Параметры**:
- Отсутствуют.

**Возвращает**:
- `None`

**Принцип работы**:
Функция `ensure_images_dir` проверяет, существует ли директория `images_dir`. Если директория не существует, она создается с помощью `os.makedirs(images_dir, exist_ok=True)`. Параметр `exist_ok=True` предотвращает возникновение ошибки, если директория уже существует.

**Примеры**:

```python
>>> ensure_images_dir()
```

### `get_source_url`

```python
def get_source_url(image: str, default: str = None) -> str:
    """Extract original URL from image parameter if present"""
```

**Назначение**: Извлекает исходный URL из параметра изображения, если он присутствует.

**Параметры**:
- `image` (str): Строка с URL изображения, которая может содержать параметр `url=`.
- `default` (str, optional): Значение по умолчанию, которое возвращается, если URL не найден. По умолчанию `None`.

**Возвращает**:
- `str`: Исходный URL изображения или значение по умолчанию, если URL не найден.

**Принцип работы**:
Функция `get_source_url` проверяет, содержит ли параметр `image` строку "url=". Если она присутствует, функция извлекает URL, декодирует его и проверяет, начинается ли он с "http://" или "https://". Если URL соответствует этим критериям, он возвращается. В противном случае возвращается значение по умолчанию.

**Примеры**:

```python
>>> get_source_url("image.png?url=https://example.com/image.png")
'https://example.com/image.png'
>>> get_source_url("image.png", "default_url")
'default_url'
```

### `is_valid_media_type`

```python
def is_valid_media_type(content_type: str) -> bool:
    """Проверяет, является ли тип контента допустимым медиа типом."""
```

**Назначение**: Проверяет, является ли тип контента допустимым медиа типом.

**Параметры**:
- `content_type` (str): Тип контента для проверки.

**Возвращает**:
- `bool`: `True`, если тип контента является допустимым медиа типом, иначе `False`.

**Принцип работы**:
Функция `is_valid_media_type` проверяет, содержится ли переданный `content_type` в словаре `MEDIA_TYPE_MAP` или начинается ли он с "audio/" или "video/". Если одно из этих условий выполняется, функция возвращает `True`, иначе возвращает `False`.

**Примеры**:

```python
>>> is_valid_media_type("image/png")
True
>>> is_valid_media_type("audio/mpeg")
True
>>> is_valid_media_type("video/mp4")
True
>>> is_valid_media_type("text/html")
False
```

### `save_response_media`

```python
async def save_response_media(response: StreamResponse, prompt: str, tags: list[str]) -> AsyncIterator:
    """Сохраняет медиа из ответа в локальный файл и возвращает URL"""
```

**Назначение**: Сохраняет медиафайл из ответа на запрос в локальный файл и возвращает URL этого файла.

**Параметры**:
- `response` (StreamResponse): Объект ответа, содержащий медиафайл.
- `prompt` (str): Описание изображения, используемое при формировании имени файла.
- `tags` (list[str]): Список тегов, используемых при формировании имени файла.

**Возвращает**:
- `AsyncIterator`: Асинхронный итератор, возвращающий объекты `ImageResponse`, `AudioResponse` или `VideoResponse` в зависимости от типа контента.

**Принцип работы**:
Функция `save_response_media` сначала проверяет, является ли тип контента допустимым медиа типом. Затем определяет расширение файла на основе типа контента. После этого формируется имя файла с использованием тегов, описания и текущего времени. Медиафайл сохраняется в локальный файл, и формируется URL для доступа к этому файлу. В зависимости от типа контента, функция возвращает объект `ImageResponse`, `AudioResponse` или `VideoResponse`.

Внутренние операции:
- Извлекается `content_type` из заголовков ответа.
- Проверяется, является ли `content_type` допустимым с помощью `is_valid_media_type`.
- Определяется расширение файла на основе `content_type`.
- Формируется имя файла с помощью `get_filename`.
- Создается полный путь к файлу.
- Медиа контент записывается в файл по частям (чанками).
- Формируется медиа URL.
- В зависимости от типа медиа, возвращается `AudioResponse`, `VideoResponse` или `ImageResponse`.

**Примеры**:

```python
# Пример использования функции с моковым объектом response
class MockResponse:
    def __init__(self, headers, content, method, url):
        self.headers = headers
        self.content = content
        self.method = method
        self.url = url
    async def iter_content(self):
        yield b"dummy data"  # Возвращаем фиктивные данные

async def main():
    response = MockResponse(
        headers={"content-type": "image/png"},
        content=b"dummy data",
        method="GET",
        url="https://example.com/image.png"
    )
    async for item in save_response_media(response, "example", ["test"]):
        print(item)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

### `get_filename`

```python
def get_filename(tags: list[str], alt: str, extension: str, image: str) -> str:
    """Возвращает имя файла, сгенерированное на основе тегов, alt-текста, расширения и хеша изображения."""
```

**Назначение**: Генерирует имя файла на основе предоставленных тегов, альтернативного текста, расширения и хеша изображения.

**Параметры**:
- `tags` (list[str]): Список тегов для включения в имя файла.
- `alt` (str): Альтернативный текст для включения в имя файла.
- `extension` (str): Расширение файла.
- `image` (str): Исходное изображение, используемое для генерации хеша.

**Возвращает**:
- `str`: Сгенерированное имя файла.

**Принцип работы**:
Функция `get_filename` создает имя файла, объединяя текущее время, теги (если есть), альтернативный текст, хеш изображения и расширение файла. Теги объединяются в строку, экранируются с помощью `secure_filename`, и включаются в имя файла, если они предоставлены. Альтернативный текст также экранируется. Хеш изображения генерируется с использованием SHA256 и обрезается до первых 16 символов.

**Примеры**:

```python
>>> get_filename(["tag1", "tag2"], "alt_text", ".png", "image_data")
'1698883200_tag1+tag2+alt_text_d14a028c2a5bcd47.png'
>>> get_filename([], "alt_text", ".jpg", "image_data")
'1698883200_alt_text_d14a028c2a5bcd47.jpg'
```

### `copy_media`

```python
async def copy_media(
    images: list[str],
    cookies: Optional[Cookies] = None,
    headers: Optional[dict] = None,
    proxy: Optional[str] = None,
    alt: str = None,
    tags: list[str] = None,
    add_url: bool = True,
    target: str = None,
    ssl: bool = None
) -> list[str]:
    """
    Скачивает и сохраняет изображения локально с Unicode-безопасными именами файлов.

    Возвращает список относительных URL-адресов изображений.
    """
```

**Назначение**: Загружает и сохраняет изображения локально, обеспечивая Unicode-безопасные имена файлов.

**Параметры**:
- `images` (list[str]): Список URL-адресов изображений для загрузки.
- `cookies` (Optional[Cookies], optional): Cookies для использования при загрузке изображений. По умолчанию `None`.
- `headers` (Optional[dict], optional): Заголовки для использования при загрузке изображений. По умолчанию `None`.
- `proxy` (Optional[str], optional): Прокси-сервер для использования при загрузке изображений. По умолчанию `None`.
- `alt` (str, optional): Альтернативный текст для использования при формировании имени файла. По умолчанию `None`.
- `tags` (list[str], optional): Список тегов для использования при формировании имени файла. По умолчанию `None`.
- `add_url` (bool, optional): Определяет, нужно ли добавлять исходный URL в конец локального URL. По умолчанию `True`.
- `target` (str, optional): Целевой путь для сохранения изображений. Если указан, изображения сохраняются по этому пути. По умолчанию `None`.
- `ssl` (bool, optional): Определяет, нужно ли использовать SSL при загрузке изображений. По умолчанию `None`.

**Возвращает**:
- `list[str]`: Список относительных URL-адресов загруженных изображений.

**Принцип работы**:
Функция `copy_media` принимает список URL-адресов изображений, загружает их и сохраняет локально. Имена файлов генерируются с использованием Unicode-безопасных символов. Функция использует асинхронный HTTP-клиент для параллельной загрузки изображений.

**Внутренние функции**:

### `copy_image`

```python
async def copy_image(image: str, target: str = None) -> str:
    """Обрабатывает отдельное изображение и возвращает его локальный URL."""
```

**Назначение**: Обрабатывает отдельное изображение, загружает его (если необходимо) и возвращает локальный URL.

**Параметры**:
- `image` (str): URL-адрес изображения.
- `target` (str, optional): Целевой путь для сохранения изображения. Если указан, изображение сохраняется по этому пути. По умолчанию `None`.

**Возвращает**:
- `str`: Локальный URL-адрес изображения.

**Принцип работы**:
Функция `copy_image` проверяет, является ли изображение локальным. Если изображение уже локальное, функция возвращает его. В противном случае функция загружает изображение, сохраняет его локально и возвращает локальный URL.

Внутренние операции:
- Проверяется, начинается ли URL с "/". Если да, возвращается URL.
- Если `target` не указан, формируется имя файла с использованием `get_filename` и создается `target_path`.
- Обрабатываются изображения в формате Data URI: извлекаются данные и записываются в файл.
- Если BackendApi включен, используются его заголовки и SSL.
- Загружается изображение с использованием `session.get`.
- Проверяется `media_type` и сохраняется содержимое в файл.
- Проверяется формат файла с использованием `is_accepted_format` и, при необходимости, переименовывается файл.
- Формируется URL с безопасным кодированием.
- Обрабатываются исключения при копировании изображений.

**Примеры**:

```python
# Пример использования функции
async def main():
    images = ["https://example.com/image.png", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w+G4kAwiQA3G8rKlTj3jTAAAAABJRU5ErkJggg=="]
    result = await copy_media(images, tags=["test"], alt="example")
    print(result)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())