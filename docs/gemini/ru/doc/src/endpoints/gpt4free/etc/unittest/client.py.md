# Модуль для тестирования клиентской части g4f

## Обзор

Модуль содержит набор тестов для проверки корректной работы клиентской части библиотеки `g4f`. Тесты охватывают как асинхронные, так и синхронные варианты работы с `Client`, `AsyncClient` и `ChatCompletion`.

## Подробнее

Модуль тестирует различные аспекты взаимодействия с API, включая обработку ответов, передачу моделей, ограничение количества токенов, потоковую передачу данных и остановку генерации. Кроме того, проверяется корректность обработки ситуаций, когда модель не найдена, а также логика выбора провайдера и модели.

## Классы

### `AsyncTestPassModel`

**Описание**: Класс содержит асинхронные тесты для проверки функциональности `AsyncClient`.

**Наследует**:

- `unittest.IsolatedAsyncioTestCase`: Класс для создания асинхронных тестов.

**Методы**:

- `test_response`: Проверяет корректность обработки ответа от асинхронного клиента.
- `test_pass_model`: Проверяет передачу модели асинхронному клиенту.
- `test_max_tokens`: Проверяет ограничение количества токенов при использовании асинхронного клиента.
- `test_max_stream`: Проверяет потоковую передачу данных с использованием асинхронного клиента.
- `test_stop`: Проверяет остановку генерации текста при использовании асинхронного клиента.

#### `test_response`

```python
async def test_response(self):
    """Проверяет корректность обработки ответа от асинхронного клиента.

    Args:
        self: Экземпляр класса `AsyncTestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `AsyncClient` с мок-провайдером `AsyncGeneratorProviderMock`.
    - Вызывается метод `client.chat.completions.create` с предопределенными сообщениями и пустой строкой.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "Mock".
    """
```

#### `test_pass_model`

```python
async def test_pass_model(self):
    """Проверяет передачу модели асинхронному клиенту.

    Args:
        self: Экземпляр класса `AsyncTestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `AsyncClient` с мок-провайдером `ModelProviderMock`.
    - Вызывается метод `client.chat.completions.create` с предопределенными сообщениями и строкой "Hello".
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "Hello".
    """
```

#### `test_max_tokens`

```python
async def test_max_tokens(self):
    """Проверяет ограничение количества токенов при использовании асинхронного клиента.

    Args:
        self: Экземпляр класса `AsyncTestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `AsyncClient` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с ограничением `max_tokens=1`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How ".
    - Вызывается метод `client.chat.completions.create` с ограничением `max_tokens=2`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How are ".
    """
```

#### `test_max_stream`

```python
async def test_max_stream(self):
    """Проверяет потоковую передачу данных с использованием асинхронного клиента.

    Args:
        self: Экземпляр класса `AsyncTestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если чанк ответа не является экземпляром `ChatCompletionChunk` или содержимое чанка не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `AsyncClient` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с `stream=True`.
    - Итерируется по асинхронному генератору ответов.
    - Проверяется, что каждый чанк является экземпляром `ChatCompletionChunk`.
    - Проверяется, что содержимое каждого чанка является строкой.
    - Формируется другой список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с `stream=True` и `max_tokens=2`.
    - Собирается список ответов.
    - Проверяется, что длина списка ответов равна 3.
    - Проверяется, что содержимое каждого чанка соответствует ожидаемому значению "You ".
    """
```

#### `test_stop`

```python
async def test_stop(self):
    """Проверяет остановку генерации текста при использовании асинхронного клиента.

    Args:
        self: Экземпляр класса `AsyncTestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `AsyncClient` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с параметром `stop=["and"]`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How are you?".
    """
```

### `TestPassModel`

**Описание**: Класс содержит синхронные тесты для проверки функциональности `Client`.

**Наследует**:

- `unittest.TestCase`: Класс для создания тестов.

**Методы**:

- `test_response`: Проверяет корректность обработки ответа от синхронного клиента.
- `test_pass_model`: Проверяет передачу модели синхронному клиенту.
- `test_max_tokens`: Проверяет ограничение количества токенов при использовании синхронного клиента.
- `test_max_stream`: Проверяет потоковую передачу данных с использованием синхронного клиента.
- `test_stop`: Проверяет остановку генерации текста при использовании синхронного клиента.
- `test_model_not_found`: Проверяет возникновение исключения `ModelNotFoundError` при попытке использовать несуществующую модель.
- `test_best_provider`: Проверяет выбор наилучшего провайдера для заданной модели.
- `test_default_model`: Проверяет выбор провайдера для модели по умолчанию.
- `test_provider_as_model`: Проверяет использование провайдера в качестве модели.
- `test_get_model`: Проверяет получение модели.

#### `test_response`

```python
def test_response(self):
    """Проверяет корректность обработки ответа от синхронного клиента.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `Client` с мок-провайдером `AsyncGeneratorProviderMock`.
    - Вызывается метод `client.chat.completions.create` с предопределенными сообщениями и пустой строкой.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "Mock".
    """
```

#### `test_pass_model`

```python
def test_pass_model(self):
    """Проверяет передачу модели синхронному клиенту.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `Client` с мок-провайдером `ModelProviderMock`.
    - Вызывается метод `client.chat.completions.create` с предопределенными сообщениями и строкой "Hello".
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "Hello".
    """
```

#### `test_max_tokens`

```python
def test_max_tokens(self):
    """Проверяет ограничение количества токенов при использовании синхронного клиента.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `Client` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с ограничением `max_tokens=1`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How ".
    - Вызывается метод `client.chat.completions.create` с ограничением `max_tokens=2`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How are ".
    """
```

#### `test_max_stream`

```python
def test_max_stream(self):
    """Проверяет потоковую передачу данных с использованием синхронного клиента.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если чанк ответа не является экземпляром `ChatCompletionChunk` или содержимое чанка не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `Client` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с `stream=True`.
    - Итерируется по генератору ответов.
    - Проверяется, что каждый чанк является экземпляром `ChatCompletionChunk`.
    - Проверяется, что содержимое каждого чанка является строкой.
    - Формируется другой список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с `stream=True` и `max_tokens=2`.
    - Преобразуется генератор ответов в список.
    - Проверяется, что длина списка ответов равна 3.
    - Проверяется, что содержимое каждого чанка соответствует ожидаемому значению "You ".
    """
```

#### `test_stop`

```python
def test_stop(self):
    """Проверяет остановку генерации текста при использовании синхронного клиента.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если ответ не является экземпляром `ChatCompletion` или содержимое ответа не соответствует ожидаемому.

    Как работает функция:
    - Создается экземпляр `Client` с мок-провайдером `YieldProviderMock`.
    - Формируется список сообщений из чанков текста.
    - Вызывается метод `client.chat.completions.create` с параметром `stop=["and"]`.
    - Проверяется, что полученный ответ является экземпляром `ChatCompletion`.
    - Проверяется, что содержимое ответа соответствует ожидаемому значению "How are you?".
    """
```

#### `test_model_not_found`

```python
def test_model_not_found(self):
    """Проверяет возникновение исключения `ModelNotFoundError` при попытке использовать несуществующую модель.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если исключение `ModelNotFoundError` не возникает.

    Как работает функция:
    - Определяется внутренняя функция `run_exception`, которая создает экземпляр `Client` и вызывает метод `client.chat.completions.create` с предопределенными сообщениями и строкой "Hello".
    - Проверяется, что при вызове `run_exception` возникает исключение `ModelNotFoundError`.
    """
    def run_exception():
        """
        Внутренняя функция для вызова исключения `ModelNotFoundError`.

        Args:
            None

        Returns:
            None

        Raises:
            ModelNotFoundError: Если модель не найдена.
        """
        client = Client()
        client.chat.completions.create(DEFAULT_MESSAGES, "Hello")
```

#### `test_best_provider`

```python
def test_best_provider(self):
    """Проверяет выбор наилучшего провайдера для заданной модели.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если у провайдера отсутствует атрибут `create_completion` или модель не соответствует ожидаемой.

    Как работает функция:
    - Задается название модели `not_default_model = "gpt-4o"`.
    - Вызывается функция `get_model_and_provider` с указанием модели и флагом `False`.
    - Проверяется, что у полученного провайдера есть атрибут `create_completion`.
    - Проверяется, что полученная модель соответствует заданной.
    """
```

#### `test_default_model`

```python
def test_default_model(self):
    """Проверяет выбор провайдера для модели по умолчанию.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если у провайдера отсутствует атрибут `create_completion` или модель не соответствует ожидаемой.

    Как работает функция:
    - Задается пустая строка в качестве названия модели `default_model = ""`.
    - Вызывается функция `get_model_and_provider` с указанием модели и флагом `False`.
    - Проверяется, что у полученного провайдера есть атрибут `create_completion`.
    - Проверяется, что полученная модель соответствует заданной.
    """
```

#### `test_provider_as_model`

```python
def test_provider_as_model(self):
    """Проверяет использование провайдера в качестве модели.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если у провайдера отсутствует атрибут `create_completion` или модель не является строкой или модель не соответствует ожидаемой.

    Как работает функция:
    - Задается имя класса `Copilot` в качестве названия модели `provider_as_model = Copilot.__name__`.
    - Вызывается функция `get_model_and_provider` с указанием модели и флагом `False`.
    - Проверяется, что у полученного провайдера есть атрибут `create_completion`.
    - Проверяется, что полученная модель является строкой.
    - Проверяется, что полученная модель соответствует значению `Copilot.default_model`.
    """
```

#### `test_get_model`

```python
def test_get_model(self):
    """Проверяет получение модели.

    Args:
        self: Экземпляр класса `TestPassModel`.

    Returns:
        None

    Raises:
        AssertionError: Если у провайдера отсутствует атрибут `create_completion` или модель не соответствует ожидаемой.

    Как работает функция:
    - Вызывается функция `get_model_and_provider` с указанием названия модели `gpt_4o.name` и флагом `False`.
    - Проверяется, что у полученного провайдера есть атрибут `create_completion`.
    - Проверяется, что полученная модель соответствует значению `gpt_4o.name`.
    """
```

## Функции

### `get_model_and_provider`

```python
from g4f.client import get_model_and_provider
```

**Назначение**: Функция определяет модель и провайдера на основе заданных параметров.
```
Args:
    model: str | None
    provider: ProviderProtocol | str | None
    automatic: bool

Returns:
    tuple[str, ProviderProtocol]:
```

## Параметры класса

- `DEFAULT_MESSAGES`: Список сообщений по умолчанию для использования в тестах.

## Запуск тестов

```python
if __name__ == '__main__':
    unittest.main()
```

При запуске модуля как основного исполняемого файла, запускаются все тесты, определенные в модуле, с использованием `unittest.main()`.