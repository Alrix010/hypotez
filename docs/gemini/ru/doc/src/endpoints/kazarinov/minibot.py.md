# Модуль `minibot`

## Обзор

Модуль `minibot` предназначен для обслуживания запросов на создание прайс-листа для Казаринова через Telegram-бота. Он включает в себя обработку текстовых команд, URL-адресов, голосовых сообщений и документов, а также взаимодействие с AI-моделью Google Gemini для генерации ответов.

## Подробней

Этот модуль является частью проекта `hypotez` и обеспечивает функциональность Telegram-бота, способного взаимодействовать с пользователями, обрабатывать их запросы и предоставлять информацию на основе заданных сценариев. Он использует библиотеку `telebot` для работы с Telegram API и включает в себя конфигурацию, обработчик команд и основную логику работы бота.

## Классы

### `Config`

**Описание**: Класс `Config` содержит настройки для работы бота, такие как токен бота, идентификатор канала, пути к файлам и сообщения.

**Атрибуты**:
- `ENDPOINT` (str): Имя endpoint.
- `MODE` (str): Режим работы бота (`PRODUCTION` или `DEV`). Определяет, какой токен бота использовать.
- `BOT_TOKEN` (str): Токен Telegram-бота.
- `CHANNEL_ID` (str): Идентификатор канала Telegram.
- `PHOTO_DIR` (Path): Путь к директории с фотографиями.
- `COMMAND_INFO` (str): Информация о боте, отображаемая по команде `/info`.
- `UNKNOWN_COMMAND_MESSAGE` (str): Сообщение об неизвестной команде.
- `START_MESSAGE` (str): Приветственное сообщение при старте бота.
- `HELP_MESSAGE` (str): Справочное сообщение с описанием доступных команд.

**Принцип работы**:
Класс `Config` определяет параметры конфигурации, необходимые для работы Telegram-бота. Он устанавливает токен бота в зависимости от режима работы (`PRODUCTION` или `DEV`), а также содержит другие настройки, такие как идентификатор канала, пути к директориям и текстовые сообщения.

### `BotHandler`

**Описание**: Класс `BotHandler` обрабатывает команды, полученные от пользователя через Telegram-бота.

**Атрибуты**:
- `base_dir` (Path): Базовая директория для хранения ресурсов бота.
- `questions_list` (List[str]): Список вопросов, используемых при обработке команды `--next`.
- `model` (GoogleGenerativeAI): Экземпляр AI-модели Google Gemini для генерации ответов на запросы пользователя.

**Методы**:
- `__init__(self)`: Инициализирует обработчик событий телеграм-бота.
- `handle_message(self, bot: telebot, message: 'message')`: Обрабатывает текстовые сообщения.
- `_send_user_flowchart(self, bot, chat_id)`: Отправляет схему user_flowchart.
- `_handle_url(self, bot, message: 'message')`: Обрабатывает URL, присланный пользователем.
- `_handle_next_command(self, bot, message)`: Обрабатывает команду '--next' и её аналоги.
- `help_command(self, bot, message)`: Обрабатывает команду /help.
- `send_pdf(self, bot, message, pdf_file)`: Обрабатывает команду /sendpdf для отправки PDF.
- `handle_voice(self, bot, message)`: Обрабатывает голосовые сообщения.
- `_transcribe_voice(self, file_path)`: Транскрибирует голосовое сообщение (заглушка).
- `handle_document(self, bot, message)`: Обрабатывает полученные документы.

## Методы класса

### `__init__`

```python
def __init__(self):
    """Инициализация обработчика событий телеграм-бота."""
```

**Назначение**: Инициализирует экземпляр класса `BotHandler`.

**Как работает функция**:
- Инициализирует список вопросов `questions_list`, используемых при обработке команды `--next`.
- Создает экземпляр AI-модели Google Gemini (`GoogleGenerativeAI`) для генерации ответов на запросы пользователя. API-ключ Gemini берется из переменной окружения `GEMINI_API` или из `gs.credentials.gemini.kazarinov`, если переменная окружения не задана.

### `handle_message`

```python
def handle_message(self, bot:telebot, message:'message'):
    """Обработка текстовых сообщений."""
```

**Назначение**: Обрабатывает текстовые сообщения, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Извлекает текст сообщения.
- Если текст равен `?`, вызывает метод `_send_user_flowchart` для отправки схемы user_flowchart.
- Если текст является URL-адресом, вызывает метод `_handle_url` для обработки URL.
- Если текст является командой `--next`, `-next`, `__next`, `-n` или `-q`, вызывает метод `_handle_next_command` для обработки команды.
- В противном случае пытается получить ответ от AI-модели Gemini и отправляет его пользователю.
- В случае ошибки при взаимодействии с моделью логирует ошибку и отправляет пользователю сообщение об ошибке.

### `_send_user_flowchart`

```python
def _send_user_flowchart(self, bot, chat_id):
    """Отправка схемы user_flowchart."""
```

**Назначение**: Отправляет пользователю схему `user_flowchart` в виде фотографии.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `chat_id` (int): Идентификатор чата, куда нужно отправить фотографию.

**Как работает функция**:
- Формирует путь к файлу `user_flowchart.png` в директории `assets`.
- Открывает файл и отправляет его пользователю в виде фотографии.
- Если файл не найден, логирует ошибку и отправляет пользователю сообщение об ошибке.

### `_handle_url`

```python
def _handle_url(self, bot, message:'message'):
    """Обработка URL, присланного пользователем."""
```

**Назначение**: Обрабатывает URL-адрес, присланный пользователем.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Извлекает URL из текста сообщения.
- Проверяет, начинается ли URL с `https://one-tab.com` или `https://www.one-tab.com`. Если нет, отправляет пользователю сообщение об ошибке и завершает работу.
- Пытается извлечь цену, название и список URL-адресов из OneTab, используя функцию `fetch_target_urls_onetab`.
- В случае успеха отправляет пользователю сообщение с названием и ценой.
- Если не удалось получить список URL-адресов, отправляет пользователю сообщение об ошибке.
- Создает экземпляр класса `Scenario` и запускает сценарий в асинхронном режиме.
- В случае ошибки при выполнении сценария логирует ошибку и отправляет пользователю сообщение об ошибке.

**Внутренние функции**:
Внутри этой функции вызывается `fetch_target_urls_onetab` из `src.endpoints.kazarinov.scenarios.scenario`, но она не рассматривается здесь, так как это функция из другого модуля.

### `_handle_next_command`

```python
def _handle_next_command(self, bot, message):
    """Обработка команды \'--next\' и её аналогов."""
```

**Назначение**: Обрабатывает команду `--next` и её аналоги, отправляя случайный вопрос из списка и ответ от AI-модели Gemini.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Выбирает случайный вопрос из списка `self.questions_list`.
- Получает ответ на вопрос от AI-модели Gemini, используя метод `ask`.
- Отправляет пользователю выбранный вопрос и полученный ответ.
- В случае ошибки при чтении вопросов логирует ошибку и отправляет пользователю сообщение об ошибке.

### `help_command`

```python
def help_command(self, bot, message):
    """Обработка команды /help."""
```

**Назначение**: Обрабатывает команду `/help`, отправляя пользователю список доступных команд.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Отправляет пользователю сообщение со списком доступных команд: `/start`, `/help`, `/sendpdf`.

### `send_pdf`

```python
def send_pdf(self, bot, message, pdf_file):
    """Обработка команды /sendpdf для отправки PDF."""
```

**Назначение**: Обрабатывает команду `/sendpdf`, отправляя пользователю PDF-файл.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.
- `pdf_file` (str): Путь к PDF-файлу, который нужно отправить.

**Как работает функция**:
- Открывает PDF-файл по указанному пути.
- Отправляет файл пользователю в виде документа.
- В случае ошибки при отправке файла логирует ошибку и отправляет пользователю сообщение об ошибке.

### `handle_voice`

```python
def handle_voice(self, bot, message):
    """Обработка голосовых сообщений."""
```

**Назначение**: Обрабатывает голосовые сообщения, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о голосовом сообщении, отправленном пользователем.

**Как работает функция**:
- Получает информацию о файле голосового сообщения.
- Скачивает файл.
- Формирует путь для сохранения временного файла с расширением `.ogg`.
- Сохраняет скачанный файл во временный файл.
- Пытается транскрибировать голосовое сообщение, используя метод `_transcribe_voice`.
- Отправляет пользователю распознанный текст.
- В случае ошибки при обработке голосового сообщения логирует ошибку и отправляет пользователю сообщение об ошибке.

### `_transcribe_voice`

```python
def _transcribe_voice(self, file_path):
    """Транскрибирование голосового сообщения (заглушка)."""
```

**Назначение**: Транскрибирует голосовое сообщение в текст (реализация отсутствует, возвращает заглушку).

**Параметры**:
- `file_path` (str): Путь к файлу голосового сообщения.

**Как работает функция**:
- Возвращает сообщение-заглушку `'Распознавание голоса ещё не реализовано.'`, так как функциональность транскрибирования не реализована.

### `handle_document`

```python
def handle_document(self, bot, message):
    """Обработка полученных документов."""
```

**Назначение**: Обрабатывает документы, полученные от пользователя.

**Параметры**:
- `bot` (telebot): Экземпляр Telegram-бота.
- `message` (message): Объект сообщения, содержащий информацию о документе, отправленном пользователем.

**Как работает функция**:
- Получает информацию о файле документа.
- Скачивает файл.
- Формирует путь для сохранения временного файла с именем файла, указанным в документе.
- Сохраняет скачанный файл во временный файл.
- Отправляет пользователю сообщение о том, что файл сохранен, и указывает путь к файлу.
- В случае ошибки при обработке документа логирует ошибку и отправляет пользователю сообщение об ошибке.

## Функции

### `command_start`

```python
@bot.message_handler(commands=['start'])
def command_start(message):
    logger.info(f"User {message.from_user.username} send /start command")
    bot.send_message(message.chat.id, config.START_MESSAGE)
```

**Назначение**: Обрабатывает команду `/start`, отправляя пользователю приветственное сообщение.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию об использовании команды `/start` пользователем.
- Отправляет пользователю приветственное сообщение, содержащееся в `config.START_MESSAGE`.

### `command_help`

```python
@bot.message_handler(commands=['help'])
def command_help(message):
    logger.info(f"User {message.from_user.username} send /help command")
    handler.help_command(bot, message)
```

**Назначение**: Обрабатывает команду `/help`, вызывая метод `help_command` класса `BotHandler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию об использовании команды `/help` пользователем.
- Вызывает метод `handler.help_command(bot, message)` для отправки пользователю списка доступных команд.

### `command_info`

```python
@bot.message_handler(commands=['info'])
def command_info(message):
    logger.info(f"User {message.from_user.username} send /info command")
    bot.send_message(message.chat.id, config.COMMAND_INFO)
```

**Назначение**: Обрабатывает команду `/info`, отправляя пользователю информацию о боте.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию об использовании команды `/info` пользователем.
- Отправляет пользователю информацию о боте, содержащуюся в `config.COMMAND_INFO`.

### `command_time`

```python
@bot.message_handler(commands=['time'])
def command_time(message):
    logger.info(f"User {message.from_user.username} send /time command")
    now = datetime.datetime.now()
    current_time = now.strftime("%H:%M:%S")
    bot.send_message(message.chat.id, f"Current time: {current_time}")
```

**Назначение**: Обрабатывает команду `/time`, отправляя пользователю текущее время.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию об использовании команды `/time` пользователем.
- Получает текущее время с помощью `datetime.datetime.now()`.
- Форматирует время в строку в формате "HH:MM:SS".
- Отправляет пользователю текущее время.

### `command_photo`

```python
@bot.message_handler(commands=['photo'])
def command_photo(message):
    logger.info(f"User {message.from_user.username} send /photo command")
    try:
        photo_files = os.listdir(config.PHOTO_DIR)
        if photo_files:
            random_photo = random.choice(photo_files)
            photo_path = os.path.join(config.PHOTO_DIR, random_photo)
            with open(photo_path, 'rb') as photo:
                bot.send_photo(message.chat.id, photo)
        else:
            bot.send_message(message.chat.id, "No photos in the folder.")
    except FileNotFoundError:
        bot.send_message(message.chat.id, "Photo directory not found.")
```

**Назначение**: Обрабатывает команду `/photo`, отправляя пользователю случайную фотографию из директории.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию об использовании команды `/photo` пользователем.
- Получает список файлов в директории `config.PHOTO_DIR`.
- Если в директории есть файлы, выбирает случайный файл.
- Открывает выбранный файл и отправляет его пользователю в виде фотографии.
- Если директория не найдена, отправляет пользователю сообщение об ошибке.
- Если в директории нет фотографий, отправляет пользователю сообщение об отсутствии фотографий.

### `handle_voice_message`

```python
@bot.message_handler(content_types=['voice'])
def handle_voice_message(message):
    logger.info(f"User {message.from_user.username} send voice message")
    handler.handle_voice(bot, message)
```

**Назначение**: Обрабатывает голосовые сообщения, перенаправляя их в метод `handle_voice` класса `BotHandler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о голосовом сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию о получении голосового сообщения от пользователя.
- Вызывает метод `handler.handle_voice(bot, message)` для обработки голосового сообщения.

### `handle_document_message`

```python
@bot.message_handler(content_types=['document'])
def handle_document_message(message):
    logger.info(f'User {message.from_user.username} send document message')
    handler.handle_document(bot, message)
```

**Назначение**: Обрабатывает сообщения, содержащие документы, перенаправляя их в метод `handle_document` класса `BotHandler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о документе, отправленном пользователем.

**Как работает функция**:
- Логирует информацию о получении документа от пользователя.
- Вызывает метод `handler.handle_document(bot, message)` для обработки документа.

### `handle_text_message`

```python
@bot.message_handler(func=lambda message: message.text and not message.text.startswith('/'))
def handle_text_message(message):
    logger.info(f'User {message.from_user.username} sent message: {message.text}')
    handler.handle_message(bot, message )
```

**Назначение**: Обрабатывает текстовые сообщения, не начинающиеся с символа `/`, перенаправляя их в метод `handle_message` класса `BotHandler`.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о текстовом сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию о полученном текстовом сообщении от пользователя.
- Вызывает метод `handler.handle_message(bot, message)` для обработки текстового сообщения.

### `handle_unknown_command`

```python
@bot.message_handler(func=lambda message: message.text and message.text.startswith('/'))
def handle_unknown_command(message):
    logger.info(f'User {message.from_user.username} send unknown command: {message.text}')
    bot.send_message(message.chat.id, config.UNKNOWN_COMMAND_MESSAGE)
```

**Назначение**: Обрабатывает неизвестные команды (текстовые сообщения, начинающиеся с символа `/`), отправляя пользователю сообщение об неизвестной команде.

**Параметры**:
- `message` (telebot.types.Message): Объект сообщения, содержащий информацию о сообщении, отправленном пользователем.

**Как работает функция**:
- Логирует информацию о получении неизвестной команды от пользователя.
- Отправляет пользователю сообщение об неизвестной команде, содержащееся в `config.UNKNOWN_COMMAND_MESSAGE`.

### `main`

```python
def main(restarts:int = 5):
    """Функция перезапуска бота."""
```

**Назначение**: Запускает и перезапускает Telegram-бота.

**Параметры**:
- `restarts` (int, optional): Количество попыток перезапуска бота в случае ошибки. По умолчанию равно 5.

**Как работает функция**:
- Устанавливает количество перезапусков равным 5 (фактически делает цикл бесконечным).
- Запускает бота в режиме `polling` с параметром `none_stop=True`, что позволяет боту работать непрерывно.
- В случае ошибки во время работы бота:
    - Логирует информацию об ошибке.
    - Останавливает бота.
    - Логирует информацию об остановке бота.
    - Запускает бота снова после 10-секундной задержки, уменьшая количество попыток перезапуска на 1.
- Если количество попыток перезапуска исчерпано, логирует информацию о превышении количества переподключений.