# Модуль utils для работы с Google Drive Mega

## Обзор

Модуль `utils.py` предоставляет набор вспомогательных функций для работы с шифрованием и дешифрованием данных, используемых в Google Drive Mega.

## Подробней

Модуль использует библиотеку `Crypto` для работы с алгоритмом шифрования AES в режиме CBC. Он также содержит функции для преобразования данных между различными форматами, такими как массивы 32-битных целых чисел (A32), строки и Base64-кодированные строки.

## Функции

### `a32_to_str`

**Назначение**: Преобразует массив 32-битных целых чисел (A32) в строку.

**Параметры**:
- `a` (list[int]): Массив 32-битных целых чисел.

**Возвращает**:
- str: Строка, представляющая массив A32.

**Как работает функция**:
- Функция использует функцию `struct.pack` для упаковки каждого элемента массива A32 в 4-байтовое целое число в формате big-endian.
- Затем функция объединяет все упакованные целые числа в одну строку.

**Примеры**:

```python
>>> a32_to_str([1, 2, 3])
b'\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'

>>> a32_to_str([0x12345678, 0x9ABCDEF0])
b'\x12\x34\x56\x78\x9A\xBC\xDE\xF0'
```

### `aes_cbc_encrypt`

**Назначение**: Шифрует данные с использованием алгоритма AES в режиме CBC.

**Параметры**:
- `data` (bytes): Данные для шифрования.
- `key` (bytes): Ключ шифрования.

**Возвращает**:
- bytes: Зашифрованные данные.

**Как работает функция**:
- Функция создает объект шифровальщика AES с использованием ключа шифрования и режима CBC.
- В качестве вектора инициализации (IV) используется строка из 16 нулевых байтов (`'\\0' * 16`).
- Функция шифрует данные с помощью объекта шифровальщика.

**Примеры**:

```python
>>> key = b'1234567890abcdef'
>>> data = b'Hello world'
>>> aes_cbc_encrypt(data, key)
b'\x0b\x9d\x98\xa8\x67\x31\x83\xa7\xb1\x03\x9c\x74\x79\x53\x82\x57'
```

### `aes_cbc_encrypt_a32`

**Назначение**: Шифрует массив A32 с использованием алгоритма AES в режиме CBC.

**Параметры**:
- `data` (list[int]): Массив A32 для шифрования.
- `key` (list[int]): Ключ шифрования в формате A32.

**Возвращает**:
- list[int]: Зашифрованный массив A32.

**Как работает функция**:
- Функция преобразует массив A32 в строку с помощью функции `a32_to_str`.
- Функция преобразует ключ шифрования в строку с помощью функции `a32_to_str`.
- Функция шифрует строку данных с помощью функции `aes_cbc_encrypt`.
- Функция преобразует зашифрованные данные в массив A32 с помощью функции `str_to_a32`.

**Примеры**:

```python
>>> key = [0x12345678, 0x9ABCDEF0]
>>> data = [0x11111111, 0x22222222]
>>> aes_cbc_encrypt_a32(data, key)
[1452464166, 3605572371, 2039607099, 3210519924]
```

### `str_to_a32`

**Назначение**: Преобразует строку в массив 32-битных целых чисел (A32).

**Параметры**:
- `b` (bytes): Строка для преобразования.

**Возвращает**:
- list[int]: Массив A32, представляющий строку.

**Как работает функция**:
- Функция проверяет, кратна ли длина строки 4. Если нет, то добавляет нулевые байты в конец строки.
- Функция использует функцию `struct.unpack` для распаковки строки в массив 32-битных целых чисел в формате big-endian.

**Примеры**:

```python
>>> str_to_a32(b'Hello world')
[1769072522, 1701134181, 1684302527, 1684275264, 32, 0]

>>> str_to_a32(b'\x12\x34\x56\x78\x9A\xBC\xDE\xF0')
[305419896, 2523898560]
```

### `mpi2int`

**Назначение**: Преобразует MPI-кодированное целое число в обычное целое число.

**Параметры**:
- `s` (bytes): MPI-кодированное целое число.

**Возвращает**:
- int: Обычное целое число, представленное MPI-кодированным значением.

**Как работает функция**:
- Функция извлекает байты из `s`, начиная со второго байта (исключая первый байт, который является кодом длины).
- Функция преобразует эти байты в шестнадцатеричную строку с помощью функции `binascii.hexlify`.
- Функция преобразует шестнадцатеричную строку в целое число с помощью функции `int`.

**Примеры**:

```python
>>> mpi2int(b'\x04\x00\x01')
1
>>> mpi2int(b'\x02\x01\x00')
256
```

### `aes_cbc_decrypt`

**Назначение**: Дешифрует данные, зашифрованные с использованием алгоритма AES в режиме CBC.

**Параметры**:
- `data` (bytes): Зашифрованные данные.
- `key` (bytes): Ключ шифрования.

**Возвращает**:
- bytes: Дешифрованные данные.

**Как работает функция**:
- Функция создает объект дешифровальщика AES с использованием ключа шифрования и режима CBC.
- В качестве вектора инициализации (IV) используется строка из 16 нулевых байтов (`'\\0' * 16`).
- Функция дешифрует данные с помощью объекта дешифровальщика.

**Примеры**:

```python
>>> key = b'1234567890abcdef'
>>> data = b'\x0b\x9d\x98\xa8\x67\x31\x83\xa7\xb1\x03\x9c\x74\x79\x53\x82\x57'
>>> aes_cbc_decrypt(data, key)
b'Hello world'
```

### `aes_cbc_decrypt_a32`

**Назначение**: Дешифрует массив A32, зашифрованный с использованием алгоритма AES в режиме CBC.

**Параметры**:
- `data` (list[int]): Зашифрованный массив A32.
- `key` (list[int]): Ключ шифрования в формате A32.

**Возвращает**:
- list[int]: Дешифрованный массив A32.

**Как работает функция**:
- Функция преобразует массив A32 в строку с помощью функции `a32_to_str`.
- Функция преобразует ключ шифрования в строку с помощью функции `a32_to_str`.
- Функция дешифрует строку данных с помощью функции `aes_cbc_decrypt`.
- Функция преобразует дешифрованные данные в массив A32 с помощью функции `str_to_a32`.

**Примеры**:

```python
>>> key = [0x12345678, 0x9ABCDEF0]
>>> data = [1452464166, 3605572371, 2039607099, 3210519924]
>>> aes_cbc_decrypt_a32(data, key)
[1769072522, 1701134181, 1684302527, 1684275264, 32, 0]
```

### `base64urldecode`

**Назначение**: Декодирует Base64-кодированную строку, использующую URL-безопасный алфавит.

**Параметры**:
- `data` (str): Base64-кодированная строка.

**Возвращает**:
- bytes: Декодированные данные.

**Как работает функция**:
- Функция добавляет `=` в конец строки, чтобы длина строки стала кратна 4.
- Функция заменяет символы `-` на `+`, `_` на `/` и `,` на `''`.
- Функция использует функцию `base64.b64decode` для декодирования строки.

**Примеры**:

```python
>>> base64urldecode('SGVsbG8gd29ybGQ')
b'Hello world'
```

### `base64_to_a32`

**Назначение**: Преобразует Base64-кодированную строку в массив A32.

**Параметры**:
- `s` (str): Base64-кодированная строка.

**Возвращает**:
- list[int]: Массив A32, представляющий Base64-кодированную строку.

**Как работает функция**:
- Функция декодирует Base64-кодированную строку с помощью функции `base64urldecode`.
- Функция преобразует декодированные данные в массив A32 с помощью функции `str_to_a32`.

**Примеры**:

```python
>>> base64_to_a32('SGVsbG8gd29ybGQ')
[1769072522, 1701134181, 1684302527, 1684275264, 32, 0]
```

### `base64urlencode`

**Назначение**: Кодирует данные в Base64-кодированную строку, используя URL-безопасный алфавит.

**Параметры**:
- `data` (bytes): Данные для кодирования.

**Возвращает**:
- str: Base64-кодированная строка.

**Как работает функция**:
- Функция кодирует данные в Base64 с помощью функции `base64.b64encode`.
- Функция преобразует закодированные данные в строку с помощью `decode('utf-8')`.
- Функция заменяет символы `+` на `-`, `/` на `_` и `=` на `''`.

**Примеры**:

```python
>>> base64urlencode(b'Hello world')
'SGVsbG8gd29ybGQ'
```

### `a32_to_base64`

**Назначение**: Преобразует массив A32 в Base64-кодированную строку, используя URL-безопасный алфавит.

**Параметры**:
- `a` (list[int]): Массив A32 для кодирования.

**Возвращает**:
- str: Base64-кодированная строка.

**Как работает функция**:
- Функция преобразует массив A32 в строку с помощью функции `a32_to_str`.
- Функция кодирует строку в Base64 с помощью функции `base64urlencode`.

**Примеры**:

```python
>>> a32_to_base64([1769072522, 1701134181, 1684302527, 1684275264, 32, 0])
'SGVsbG8gd29ybGQ'
```

### `get_chunks`

**Назначение**: Разбивает данные на чанки заданного размера.

**Параметры**:
- `size` (int): Размер данных.

**Возвращает**:
- dict: Словарь, где ключи - это начальные позиции чанков, а значения - это размеры чанков.

**Как работает функция**:
- Функция сначала создает словарь `chunks`.
- Функция устанавливает начальную позицию `p` и размер чанка `i * 0x20000` (81920 байт) для первых 8 чанков.
- Затем функция добавляет оставшиеся чанки размером 0x100000 (1048576 байт) до тех пор, пока не будет достигнут конец данных.
- Последний чанк может быть меньше, чем 0x100000 байт.

**Примеры**:

```python
>>> get_chunks(1000000)
{0: 81920, 81920: 81920, 163840: 81920, 245760: 81920, 327680: 81920, 409600: 81920, 491520: 81920, 573440: 1048576, 1621952: 837848}