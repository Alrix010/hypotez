## \file /src/fast_api/external_client_exmple.py
# -*- coding: utf-8 -*-
#! .pyenv/bin/python3

"""
Модуль клиентского примера для управления Fast API сервером через XML-RPC.
==========================================================================

Модуль предоставляет простой пример внешнего Python-клиента, который использует
XML-RPC для взаимодействия с запущенным сервером Fast API, позволяя выполнять
такие операции, как запуск/остановка серверов, добавление маршрутов и получение
статуса.

Предназначен для демонстрации и тестирования возможностей RPC-интерфейса
сервера Fast API проекта `hypotez`.

Зависимости:
    - xmlrpc.client (встроенный в Python)

.. module:: src.fast_api.external_client
"""

# pylint: skip-file
# flake8: noqa

import sys
from xmlrpc.client import ServerProxy
import time
from src.utils.printer import pprint as print # Использование кастомной функции print из проекта

# В данном файле не используются стандартные логи, ошибки выводятся с помощью print
# from src.logger import logger

## Оглавление

- [Обзор](#обзор)
- [Подробней](#подробней)
- [Функции](#функции)
    - [`main`](#main)

## Обзор

Данный модуль представляет собой минималистичный пример клиента, демонстрирующий
взаимодействие с RPC-интерфейсом сервера Fast API. Он показывает, как можно
удаленно управлять основными функциями сервера, такими как запуск и остановка
HTTP-серверов, а также динамическое добавление новых маршрутов.

## Подробней

Файл `external_client_exmple.py` находится в директории `/src/fast_api/`
проекта `hypotez`, что указывает на его принадлежность к компоненту, отвечающему
за Fast API сервер. Его основная цель - служить наглядным примером того,
как внешние приложения или скрипты могут программно взаимодействовать с
сервером Fast API, используя протокол XML-RPC.

Код устанавливает соединение с RPC-сервером, ожидаемым по адресу
`http://localhost:9000`, и последовательно выполняет ряд RPC-вызовов:
запуск сервера на определенном порту, добавление нового маршрута, запрос статуса,
остановка сервера и повторный запрос статуса. Между вызовами предусмотрены
небольшие паузы (`time.sleep(1)`) для удобства наблюдения за ходом выполнения
примера.

В случае возникновения ошибок при выполнении RPC-вызовов, информация об ошибке
выводится в консоль с использованием кастомной функции `print` (которая является
алиасом для `pprint` из `src.utils.printer`).

В конце выполнения, независимо от успешности операций, клиент отправляет
команду `shutdown` RPC-серверу, завершая его работу.

## Функции

### `main`

```python
def main():
    """Основная функция для управления сервером через RPC из внешнего кода."""
    # Функция устанавливает соединение с RPC-сервером и выполняет последовательность RPC-вызовов.
    # Вызовы включают запуск сервера, добавление маршрута, проверку статуса и остановку сервера.
    # В конце работы функция отправляет команду на завершение работы RPC-сервера.

    # Описание возвращаемого значения отсутствует, функция выполняет действия и завершается.
    # Исключения обрабатываются внутри функции и выводятся через print.

    # Пример:
    # >>> main()
    # Starting server on port 8001...
    # Adding new route /test_route...
    # Getting server status...
    # Stopping server on port 8001...
    # Getting server status...
    # Shutting down RPC server
    # (Вывод может немного отличаться в зависимости от состояния сервера)
    ...
```

**Назначение**: Основная точка входа для скрипта, демонстрирующая взаимодействие с RPC-интерфейсом сервера Fast API.

**Параметры**:
- Функция не принимает входных параметров.

**Возвращает**:
- Функция ничего не возвращает (`None`).

**Вызывает исключения**:
- `Exception`: Ловит и выводит в консоль любые исключения, возникающие в процессе RPC-вызовов.

**Как работает функция**:
1.  Переменная `rpc_client` инициализируется как экземпляр `xmlrpc.client.ServerProxy`, устанавливая соединение с RPC-сервером по адресу `http://localhost:9000`. Параметр `allow_none=True` разрешает передачу и прием значений `None`.
2.  Блок `try` содержит последовательность демонстрационных вызовов RPC-методов на сервере через объект `rpc_client`:
    *   `rpc_client.start_server(8001, "127.0.0.1")`: Отправляет команду серверу запустить HTTP-сервер на локальном адресе `127.0.0.1` и порту `8001`.
    *   `time.sleep(1)`: Делает паузу на 1 секунду.
    *   `rpc_client.add_new_route("/test_route", \'lambda: {"message": "Hello from test_route"}\', ["GET"])`: Отправляет команду добавить новый маршрут `/test_route`, который будет отвечать на GET-запросы и возвращать JSON-объект `{"message": "Hello from test_route"}`. Лямбда-функция передается в виде строки.
    *   `time.sleep(1)`: Делает паузу на 1 секунду.
    *   `rpc_client.status_servers()`: Отправляет команду запросить текущий статус всех запущенных HTTP-серверов.
    *   `time.sleep(1)`: Делает паузу на 1 секунду.
    *   `rpc_client.stop_server(8001)`: Отправляет команду остановить HTTP-сервер, запущенный на порту `8001`.
    *   `time.sleep(1)`: Делает паузу на 1 секунду.
    *   `rpc_client.status_servers()`: Повторно отправляет команду запросить статус серверов, чтобы увидеть изменения после остановки.
    *   `time.sleep(1)`: Делает паузу на 1 секунду.
3.  Блок `except Exception as ex:`: Если в процессе выполнения `try` блока возникает какое-либо исключение, оно перехватывается, и сообщение об ошибке выводится в консоль с использованием `print(f"An error occurred: {ex}")`.
4.  Блок `finally:`: Этот блок выполняется всегда, независимо от того, возникло исключение или нет. Он отправляет команду `rpc_client.shutdown()` RPC-серверу, сигнализируя о необходимости его завершения.
5.  Строка `if __name__ == "__main__":` проверяет, запущен ли скрипт напрямую. Если да, то вызывается функция `main()`.

**Примеры**:

```python
# Запуск скрипта напрямую из командной строки
# python external_client_exmple.py

# Ожидаемый вывод в консоль (при условии запущенного RPC-сервера на 9000):
# Starting server on port 8001...
# Adding new route /test_route...
# Getting server status...
# <Вывод статуса серверов>
# Stopping server on port 8001...
# Getting server status...
# <Вывод статуса серверов после остановки>
# Shutting down RPC server
```

---