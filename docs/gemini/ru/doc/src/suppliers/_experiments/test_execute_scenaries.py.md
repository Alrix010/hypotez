# Модуль тестирования сценариев выполнения

## Обзор

Модуль содержит набор тестов для проверки корректности выполнения сценариев, включая запуск списка файлов сценариев, запуск отдельного файла сценария, запуск сценария и захват страницы товара.
Модуль использует `unittest` для организации тестов и `MagicMock` для создания мок-объектов, имитирующих взаимодействие с другими компонентами системы.

## Подробнее

Этот модуль предназначен для проверки функциональности выполнения сценариев в системе. Он включает в себя тесты для различных аспектов выполнения сценариев, таких как:

- Запуск списка файлов сценариев с различными параметрами конфигурации.
- Запуск отдельного файла сценария с использованием `webdriver` или `api`.
- Запуск сценария с проверкой наличия URL и экспорта результатов.
- Захват страницы товара и обработка полученных данных.

Модуль использует мок-объекты для изоляции тестируемых компонентов и упрощения процесса тестирования.

## Классы

### `TestRunListOfScenarioFiles`

**Описание**: Класс содержит тесты для проверки функции `run_scenarios`, которая отвечает за запуск списка файлов сценариев.

**Наследует**: `unittest.TestCase`

**Методы**:

- `test_with_scenario_files_...ed()`: Тест проверяет запуск с файлами сценариев. Проверяет, что функция `run_scenarios` корректно обрабатывает список файлов сценариев, вызывает необходимые функции и обновляет настройки.
- `test_with_no_scenario_files_...ed()`: Тест проверяет запуск без файлов сценариев. Проверяет, что функция `run_scenarios` корректно обрабатывает случай, когда список файлов сценариев отсутствует, вызывает необходимые функции и обновляет настройки.

### `TestRunScenarioFile`

**Описание**: Класс содержит тесты для проверки функции `run_scenario_file`, которая отвечает за запуск отдельного файла сценария.

**Наследует**: `unittest.TestCase`

**Методы**:

- `setUp()`: Подготавливает мок-объект `Supplier` с необходимыми атрибутами для тестов.
- `test_run_scenario_file_webdriver()`: Тест проверяет запуск файла сценария с использованием `webdriver`. Проверяет, что функция `run_scenario_file` вызывает необходимые функции с правильными параметрами при использовании `webdriver`.
- `test_run_scenario_file_api()`: Тест проверяет запуск файла сценария с использованием `api`. Проверяет, что функция `run_scenario_file` вызывает необходимые функции с правильными параметрами при использовании `api`.
- `test_run_scenario_file_no_scenarios()`: Тест проверяет случай, когда в файле сценария отсутствуют сценарии. Проверяет, что функция `run_scenario_file` корректно обрабатывает случай, когда в файле сценария отсутствуют сценарии, и логирует ошибку.

### `TestGrabProductPage`

**Описание**: Класс содержит тесты для проверки функции `grab_product_page`, которая отвечает за захват страницы товара.

**Наследует**: `unittest.TestCase`

**Методы**:

- `setUp()`: Подготавливает объект `Supplier` для тестов.
- `test_grab_product_page_succesStringFormatterul()`: Тест проверяет успешный захват страницы товара. Проверяет, что функция `grab_product_page` корректно обрабатывает данные страницы товара при наличии всех необходимых данных.
- `test_grab_product_page_failure()`: Тест проверяет неудачный захват страницы товара. Проверяет, что функция `grab_product_page` корректно обрабатывает случай, когда отсутствуют необходимые данные на странице товара.

### `TestRunScenario`

**Описание**: Класс содержит тесты для проверки функции `run_scenario`, которая отвечает за запуск сценария.

**Наследует**: `unittest.TestCase`

**Методы**:

- `setUp()`: Подготавливает объект `Supplier` с необходимыми атрибутами для тестов.
- `tearDown()`: Выполняет очистку после каждого теста (в данном случае, ничего не делает).
- `test_run_scenario_no_url()`: Тест проверяет запуск сценария без URL. Проверяет, что функция `run_scenario` корректно обрабатывает случай, когда в сценарии отсутствует URL.
- `test_run_scenario_valid_url()`: Тест проверяет запуск сценария с валидным URL. Проверяет, что функция `run_scenario` корректно обрабатывает сценарий с валидным URL, вызывает необходимые функции и экспортирует результаты.
- `test_run_scenario_export_empty_list()`: Тест проверяет экспорт пустого списка. Проверяет, что функция `run_scenario` корректно обрабатывает случай, когда список товаров для экспорта пуст, и не вызывает функцию экспорта.

## Функции

### `run_scenarios`

```python
def run_scenarios(s, scenario_files) -> bool:
    """ Функция выполняет запуск сценариев, указанных в файлах сценариев, или всех сценариев, если файлы не указаны.

    Args:
        s: Объект, содержащий настройки и информацию о сценариях.
        scenario_files (list, optional): Список файлов сценариев для выполнения. Если не указан, выполняются все сценарии из settings.

    Returns:
        bool: True, если выполнение сценариев завершилось успешно, иначе False.
    """
```

**Назначение**: Функция выполняет запуск сценариев, указанных в файлах сценариев, или всех сценариев, если файлы не указаны.

**Параметры**:

- `s`: Объект, содержащий настройки и информацию о сценариях.
- `scenario_files` (list, optional): Список файлов сценариев для выполнения. Если не указан, выполняются все сценарии из settings.

**Возвращает**:

- `bool`: True, если выполнение сценариев завершилось успешно, иначе False.

**Как работает функция**:

1. Если передан список файлов сценариев (`scenario_files`):
   - Перебирает файлы в списке.
   - Для каждого файла устанавливает `current_scenario_filename` и запускает сценарий через `run_scenario_file`.
   - Обновляет `last_runned_scenario` в настройках.
2. Если список файлов сценариев не передан:
   - Проверяет настройку `'check categories on site'`.
   - Если она `True`, вызывает `build_shop_categories`.
   - Устанавливает `current_scenario_filename` на основе `settings['scenarios']`.
   - Запускает сценарий через `run_scenario`.
   - Обновляет `last_runned_scenario` в настройках.

**Примеры**:

```python
# Пример запуска с указанием файлов сценариев
s = MagicMock()
s.settings = {'check categories on site': False, 'scenarios': ["default1.json", "default2.json"]}
scenario_files = ["scenario1.json", "scenario2.json"]
result = run_scenarios(s, scenario_files)
print(result)  # Вывод: True

# Пример запуска без указания файлов сценариев
s = MagicMock()
s.settings = {'check categories on site': True, 'scenarios': ["default1.json", "default2.json"]}
result = run_scenarios(s)
print(result)  # Вывод: True
```

### `run_scenario_file`

```python
def run_scenario_file(s, scenario_file) -> bool:
    """ Функция выполняет сценарии, описанные в файле сценариев.

    Args:
        s: Объект, содержащий настройки и информацию о сценариях.
        scenario_file (str): Имя файла сценария для выполнения.

    Returns:
        bool: True, если выполнение сценариев завершилось успешно, иначе False.
    """
```

**Назначение**: Функция выполняет сценарии, описанные в файле сценариев.

**Параметры**:

- `s`: Объект, содержащий настройки и информацию о сценариях.
- `scenario_file` (str): Имя файла сценария для выполнения.

**Возвращает**:

- `bool`: True, если выполнение сценариев завершилось успешно, иначе False.

**Как работает функция**:

1. Формирует путь к файлу сценария.
2. Загружает сценарии из файла с помощью `j_loads`.
3. Если сценарии не найдены, логирует ошибку и возвращает `False`.
4. В зависимости от настройки `'parcing method [webdriver|api]'` выполняет сценарии:
   - Если `'webdriver'`, вызывает `run_scenario` для каждого сценария, у которого есть URL.
   - Если `'api'`, вызывает `related_modules.run_scenario_file_via_api`.

**Примеры**:

```python
# Пример запуска с методом webdriver
s = MagicMock()
s.settings = {"parcing method [webdriver|api]": "webdriver"}
s.scenarios = {"scenario1": {"url": "https://example.com"}}
with patch("your_module.j_loads", return_value={"scenarios": s.scenarios}):
    with patch("your_module.run_scenario", return_value=True):
        result = run_scenario_file(s, "test_scenario.json")
        print(result)  # Вывод: True

# Пример запуска с методом api
s = MagicMock()
s.settings = {"parcing method [webdriver|api]": "api"}
with patch("your_module.related_modules.run_scenario_file_via_api", return_value=True):
    result = run_scenario_file(s, "test_scenario.json")
    print(result)  # Вывод: True
```

### `run_scenario`

```python
def run_scenario(self, scenario: dict) -> bool:
        """ Функция выполняет сценарий.

        Args:
            scenario (dict): Словарь с параметрами сценария.

        Returns:
            bool: True, если выполнение сценария завершилось успешно, иначе False.
        """
```

**Назначение**: Функция выполняет сценарий.

**Параметры**:

- `scenario` (dict): Словарь с параметрами сценария.

**Возвращает**:

- `bool`: True, если выполнение сценария завершилось успешно, иначе False.

**Как работает функция**:

1.  **Проверка наличия URL**:
    - Проверяется, что в сценарии указан URL (`scenario['url']`). Если URL отсутствует, функция возвращает `False`, так как нечего обрабатывать.

2.  **Получение списка товаров в категории**:
    - Вызывается метод `get_list_products_in_category` для получения списка URL товаров в категории. Результат сохраняется в переменной `products`.

3.  **Обработка каждого URL товара**:
    - Перебирается список URL товаров, полученных на предыдущем шаге.
    - Для каждого URL товара вызывается метод `grab_product_page` для извлечения информации о товаре.
    - Если `grab_product_page` возвращает `True`, значит, информация о товаре успешно извлечена и добавляется в список товаров (`self.p`).
    - Если `grab_product_page` возвращает `False`, товар не добавляется в список.

4.  **Экспорт результатов**:
    - После обработки всех URL товаров проверяется, есть ли товары для экспорта (`len(self.p) > 0`).
    - Если список товаров не пуст, вызывается метод `export_files` для экспорта данных о товарах в указанный формат.
    - Формируется имя файла для экспорта, добавляя к базовому имени файла (`self.export_file_name`) порядковый номер.
    - В метод `export_files` передается список товаров (`self.p`), имя файла и формат экспорта (`['csv']`).

5.  **Возврат результата**:
    - Если список товаров для экспорта пуст, метод `export_files` не вызывается.
    - Функция возвращает `True`, если список товаров для экспорта не пуст. В противном случае возвращает `False`.

**Примеры**:

```python
# Пример scenario
scenario = {'name': 'scenario2', 'url': 'https://example.com/products'}
self.supplier.scenarios = {'scenario2': scenario}
self.supplier.get_list_products_in_category = MagicMock(return_value=['https://example.com/products/1', 'https://example.com/products/2'])
self.supplier.grab_product_page = MagicMock(return_value=True)
self.supplier.export_files = MagicMock()

result = self.supplier.run_scenario(scenario)

print(result) # True
print(len(self.supplier.p)) # 2
```

### `grab_product_page`

```python
def grab_product_page(s) -> bool:
    """ Функция захватывает страницу товара.

    Args:
        s: Объект, содержащий настройки и методы для захвата страницы товара.

    Returns:
        bool: True, если захват страницы товара завершился успешно и все необходимые данные присутствуют, иначе False.
    """
```

**Назначение**: Функция захватывает страницу товара.

**Параметры**:

- `s`: Объект, содержащий настройки и методы для захвата страницы товара.

**Возвращает**:

- `bool`: True, если захват страницы товара завершился успешно и все необходимые данные присутствуют, иначе False.

**Как работает функция**:

1.  Вызывается метод `grab_product_page` объекта `s` для получения данных о товаре.
2.  Проверяется наличие необходимых данных (`id`, `price`) в полученных данных.
3.  Если все необходимые данные присутствуют, данные добавляются в список `s.p` и возвращается `True`.
4.  Если какие-либо необходимые данные отсутствуют, возвращается `False`.

**Примеры**:

```python
# Пример успешного захвата страницы товара
s = MagicMock()
s.grab_product_page = lambda _: {'id': '123', 'price': 19.99, 'name': 'Product Name'}
result = grab_product_page(s)
print(result)  # Вывод: True

# Пример неудачного захвата страницы товара
s = MagicMock()
s.grab_product_page = lambda _: {'name': 'Product Name'}
result = grab_product_page(s)
print(result)  # Вывод: False