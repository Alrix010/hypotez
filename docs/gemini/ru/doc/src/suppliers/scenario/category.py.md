# Модуль для работы с категориями, в основном для PrestaShop
## Обзор

Модуль `category.py` предназначен для работы с категориями товаров, в основном для платформы PrestaShop. Он предоставляет функциональность для обхода категорий, построения иерархических структур данных и сохранения этих данных в формате JSON. Модуль включает асинхронные и синхронные методы обхода категорий, а также утилиты для проверки дубликатов URL и сравнения словарей.

## Подробнее

Этот модуль предоставляет классы для взаимодействия и обработки данных категорий продуктов, особенно актуальных для PrestaShop.
Он включает в себя:
- Асинхронный обход категорий.
- Синхронный обход категорий.
- Проверку на дубликаты URL-адресов.
- Сравнение словарей и вывод недостающих ключей.

## Классы

### `Category`

**Описание**: Класс `Category` предназначен для обработки категорий продуктов. Он наследует функциональность из класса `PrestaCategoryAsync` и предоставляет методы для обхода категорий и управления данными категорий.

**Наследует**:
- `PrestaCategoryAsync`: Асинхронный класс для работы с категориями PrestaShop.

**Атрибуты**:
- `credentials` (Dict): Учетные данные для доступа к API категорий. Изначально устанавливается в `None`, но предполагается, что они будут заполнены при создании экземпляра класса.

**Методы**:
- `__init__(self, api_credentials, *args, **kwargs)`: Инициализирует объект `Category`.
- `crawl_categories_async(self, url, depth, driver, locator, dump_file, default_category_id, category=None)`: Асинхронно обходит категории, строя иерархический словарь.
- `crawl_categories(self, url, depth, driver, locator, dump_file, default_category_id, category={})`: Обходит категории рекурсивно и строит иерархический словарь.
- `_is_duplicate_url(self, category, url)`: Проверяет, существует ли URL уже в словаре категорий.

### `__init__`

```python
def __init__(self, api_credentials, *args, **kwargs):
    """Инициализирует объект Category.

    Args:
        api_credentials: API-ключи для доступа к данным категорий.
        args: Список аргументов переменной длины (не используется).
        kwargs: Аргументы ключевого слова (не используется).
    """
    ...
```

**Назначение**:
Инициализирует объект `Category`, вызывая конструктор родительского класса `PrestaCategoryAsync`.

**Параметры**:
- `api_credentials` (любой тип, передается в `PrestaCategoryAsync.__init__`): API-ключи для доступа к данным категорий.
- `*args`: Произвольные позиционные аргументы, которые передаются в конструктор родительского класса.
- `**kwargs`: Произвольные именованные аргументы, которые передаются в конструктор родительского класса.

**Возвращает**:
- None

**Вызывает исключения**:
- Нет явных исключений, но конструктор родительского класса может вызывать исключения.

**Как работает функция**:
- Функция вызывает конструктор родительского класса `PrestaCategoryAsync` с переданными аргументами `api_credentials`, `*args` и `**kwargs`.

**Примеры**:

```python
api_credentials = {'api_key': 'your_api_key'}
category_instance = Category(api_credentials)
```

### `crawl_categories_async`

```python
async def crawl_categories_async(self, url, depth, driver, locator, dump_file, default_category_id, category=None):
    """Асинхронно обходит категории, строя иерархический словарь.

    Args:
        url: URL страницы категории.
        depth: Глубина рекурсии обхода.
        driver: Экземпляр Selenium WebDriver.
        locator: XPath-локатор для ссылок категорий.
        dump_file: Путь к JSON-файлу для сохранения результатов.
        default_category_id: ID категории по умолчанию.
        category: (Optional) Существующий словарь категорий (по умолчанию=None).
    Returns:
        Обновленный или новый словарь категорий.
    """
    ...
```

**Назначение**:
Асинхронно обходит категории, начиная с указанного URL, и строит иерархический словарь категорий.

**Параметры**:
- `url` (str): URL страницы, с которой начинается обход категорий.
- `depth` (int): Глубина рекурсии обхода категорий. Если `depth` меньше или равно 0, функция возвращает текущую категорию без дальнейшего обхода.
- `driver` (WebDriver): Экземпляр Selenium WebDriver для управления браузером.
- `locator` (str): XPath-локатор для поиска ссылок на категории на странице.
- `dump_file` (str): Путь к файлу, в который будут сохраняться результаты обхода категорий в формате JSON.
- `default_category_id` (int): ID категории по умолчанию, который будет присвоен новым категориям.
- `category` (Optional[dict], optional): Словарь, представляющий категорию. Если не указан, создается новый словарь для корневой категории. По умолчанию `None`.

**Возвращает**:
- `dict`: Обновленный или новый словарь категорий.

**Вызывает исключения**:
- `Exception`: В случае ошибки во время обхода категорий, например, при загрузке страницы или обработке данных.

**Как работает функция**:
1. **Инициализация**: Если `category` не указана, создается новый словарь для корневой категории с URL, именем, информацией о PrestaShop (`default_category_id` и пустой список `additional_categories`) и пустым словарем для дочерних категорий.
2. **Проверка глубины**: Если глубина рекурсии `depth` меньше или равна 0, функция возвращает текущую категорию без дальнейшего обхода.
3. **Обход категорий**:
   - Использует `driver.get(url)` для загрузки страницы.
   - Ожидает 1 секунду для загрузки страницы с помощью `await asyncio.sleep(1)`.
   - Использует `driver.execute_locator(locator)` для поиска ссылок на категории на странице.
   - Если ссылки не найдены, логирует ошибку и возвращает текущую категорию.
4. **Асинхронный обход дочерних категорий**:
   - Создает список асинхронных задач для обхода каждой найденной категории.
   - Использует `asyncio.gather(*tasks)` для параллельного выполнения всех задач.
5. **Обработка ошибок**:
   - Если во время обхода возникает исключение, оно логируется, и функция возвращает текущую категорию.

**Примеры**:

```python
from selenium import webdriver
from src.webdirver import Driver, Firefox, Chrome, Playwright, ...
from src.logger.logger import logger

# Создание инстанса драйвера (пример с Chrome)
driver = Driver(Chrome)
url = 'https://example.com/category'
locator = {'by': 'xpath', 'selector': '//a[@class="category-link"]'}
dump_file = 'categories.json'
default_category_id = 1

category = await self.crawl_categories_async(url, 2, driver, locator, dump_file, default_category_id)
print(category)
```

### `crawl_categories`

```python
def crawl_categories(self, url, depth, driver, locator, dump_file, default_category_id, category={}):
    """Обходит категории рекурсивно и строит иерархический словарь.

    Args:
        url: URL страницы для обхода.
        depth: Глубина рекурсии.
        driver: Экземпляр Selenium WebDriver.
        locator: XPath-локатор для поиска ссылок на категории.
        dump_file: Файл для сохранения иерархического словаря.
        id_category_default: ID категории по умолчанию.
        category: Словарь категорий (по умолчанию пустой).
    Returns:
        Иерархический словарь категорий и их URL-адресов.
    """
    ...
```

**Назначение**:
Рекурсивно обходит категории, начиная с указанного URL, и строит иерархический словарь категорий и их URL-адресов.

**Параметры**:
- `url` (str): URL страницы, с которой начинается обход категорий.
- `depth` (int): Глубина рекурсии обхода категорий. Если `depth` меньше или равно 0, функция возвращает текущую категорию без дальнейшего обхода.
- `driver` (WebDriver): Экземпляр Selenium WebDriver для управления браузером.
- `locator` (str): XPath-локатор для поиска ссылок на категории на странице.
- `dump_file` (str): Путь к файлу, в который будут сохраняться результаты обхода категорий в формате JSON.
- `default_category_id` (int): ID категории по умолчанию, который будет присвоен новым категориям.
- `category` (dict, optional): Словарь, представляющий категорию. Если не указан, используется пустой словарь. По умолчанию `{}`.

**Возвращает**:
- `dict`: Иерархический словарь категорий и их URL-адресов.

**Вызывает исключения**:
- `Exception`: В случае ошибки во время обхода категорий, например, при загрузке страницы или обработке данных.

**Как работает функция**:
1. **Проверка глубины**: Если глубина рекурсии `depth` меньше или равна 0, функция возвращает текущую категорию без дальнейшего обхода.
2. **Обход категорий**:
   - Использует `driver.get(url)` для загрузки страницы.
   - Ожидает 1 секунду для загрузки страницы с помощью `driver.wait(1)`.
   - Использует `driver.execute_locator(locator)` для поиска ссылок на категории на странице.
   - Если ссылки не найдены, логирует ошибку и возвращает текущую категорию.
3. **Обработка каждой категории**:
   - Для каждой найденной ссылки на категорию:
     - Проверяет, не является ли URL дубликатом, используя `self._is_duplicate_url(category, link_url)`. Если URL уже существует, переходит к следующей ссылке.
     - Создает новый словарь `new_category` с информацией о категории (URL, имя, `default_category_id`).
     - Добавляет новую категорию в словарь `category` под именем категории.
     - Рекурсивно вызывает `self.crawl_categories` для обхода дочерних категорий.
4. **Сохранение результатов**:
   - Загружает существующие данные из файла `dump_file` с помощью `j_loads(dump_file)`.
   - Объединяет загруженные данные и текущий словарь `category`.
   - Сохраняет обновленный словарь `category` в файл `dump_file` с помощью `j_dumps(category, dump_file)`.
   - Возвращает обновленный словарь `category`.
5. **Обработка ошибок**:
   - Если во время обхода возникает исключение, оно логируется, и функция возвращает текущую категорию.

**Примеры**:

```python
from selenium import webdriver
from src.webdirver import Driver, Firefox, Chrome, Playwright, ...
from src.logger.logger import logger

# Создание инстанса драйвера (пример с Chrome)
driver = Driver(Chrome)

url = 'https://example.com/category'
locator = {'by': 'xpath', 'selector': '//a[@class="category-link"]'}
dump_file = 'categories.json'
default_category_id = 1

category = self.crawl_categories(url, 2, driver, locator, dump_file, default_category_id)
print(category)
```

### `_is_duplicate_url`

```python
def _is_duplicate_url(self, category, url):
    """Проверяет, существует ли URL уже в словаре категорий.

    Args:
        category: Словарь категорий.
        url: URL для проверки.
    Returns:
        True, если URL является дубликатом, False в противном случае.
    """
    ...
```

**Назначение**:
Проверяет, существует ли указанный URL уже в словаре категорий.

**Параметры**:
- `category` (dict): Словарь категорий, в котором производится поиск дубликатов URL.
- `url` (str): URL, который нужно проверить на дублирование.

**Возвращает**:
- `bool`: `True`, если URL уже существует в словаре категорий, и `False` в противном случае.

**Как работает функция**:
Функция использует генератор списков для извлечения всех URL из значений словаря `category` (предполагается, что значениями являются словари с ключом `'url'`) и проверяет, содержится ли в них переданный `url`.

**Примеры**:

```python
category = {
    'Category1': {'url': 'https://example.com/category1'},
    'Category2': {'url': 'https://example.com/category2'}
}
url_to_check = 'https://example.com/category1'
is_duplicate = self._is_duplicate_url(category, url_to_check)
print(is_duplicate)  # Вывод: True

url_to_check = 'https://example.com/category3'
is_duplicate = self._is_duplicate_url(category, url_to_check)
print(is_duplicate)  # Вывод: False
```

## Функции

### `compare_and_print_missing_keys`

```python
def compare_and_print_missing_keys(current_dict, file_path):
    """Сравнивает текущий словарь с данными в файле и печатает отсутствующие ключи."""
    ...
```

**Назначение**:
Сравнивает ключи в текущем словаре с ключами, загруженными из файла, и выводит в консоль ключи, которые присутствуют в файле, но отсутствуют в текущем словаре.

**Параметры**:
- `current_dict` (dict): Текущий словарь, с которым производится сравнение.
- `file_path` (str): Путь к файлу, из которого загружаются данные для сравнения.

**Возвращает**:
- `None`

**Вызывает исключения**:
- `Exception`: Если возникает ошибка при загрузке данных из файла.

**Как работает функция**:
1. **Загрузка данных из файла**:
   - Пытается загрузить данные из файла, указанного в `file_path`, используя функцию `j_loads`.
   - Если при загрузке возникает исключение (например, файл не существует или имеет неверный формат), логирует ошибку с помощью `logger.error` и завершает работу.
2. **Сравнение ключей**:
   - Перебирает ключи в словаре `data_from_file`.
   - Для каждого ключа проверяет, присутствует ли он в словаре `current_dict`.
   - Если ключ отсутствует в `current_dict`, выводит его в консоль с помощью `print(key)`.

**Примеры**:

Предположим, у нас есть файл `data.json` со следующим содержанием:

```json
{
    "key1": "value1",
    "key2": "value2",
    "key3": "value3"
}
```

И следующий вызов функции:

```python
current_dict = {
    "key1": "value1",
    "key2": "value2"
}
file_path = "data.json"
compare_and_print_missing_keys(current_dict, file_path)
```

В результате выполнения функции в консоль будет выведено:

```
key3
```

Потому что ключ `"key3"` присутствует в файле `data.json`, но отсутствует в словаре `current_dict`.