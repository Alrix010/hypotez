# Модуль src.endpoints.emil.emil_design
=========================================

Модуль содержит функциональность для автоматизации процессов, связанных с интернет-магазином emil-design.com, включая обработку изображений с помощью AI, продвижение в Facebook и загрузку информации о **товарах** в PrestaShop.

## Обзор

Этот модуль является конечной точкой (`endpoint`) в проекте `hypotez`, специфичной для работы с магазином `emil-design.com`. Он объединяет различные задачи автоматизации, такие как:

*   Описание изображений с использованием моделей Google Gemini и OpenAI.
*   Создание постов в Facebook для продвижения **товаров**.
*   Загрузка описаний и характеристик **товаров** в систему управления контентом PrestaShop.

Модуль использует конфигурационные файлы и данные из хранилища проекта (`gs`) для выполнения своих задач.

## Подробней

Модуль `emil_design.py` разработан для автоматизации рутинных операций, связанных с контентом и продвижением **товаров** для интернет-магазина `emil-design.com`. Он использует внешние сервисы, такие как Google Gemini и OpenAI, для генерации текстовых описаний изображений **товаров**, а также взаимодействует с Facebook API (через вебдрайвер) для создания постов и с PrestaShop API для управления **товарами**.

Файл расположен по пути `hypotez/src/endpoints/emil/emil_design.py`, что указывает на его роль как специализированного модуля-конечной точки для конкретного клиента/сайта (`emil`).

Взаимосвязь с другими частями проекта:
-   `src.gs`: Используется для доступа к общим настройкам, путям хранения данных, учетным данным API (при отключенном `USE_ENV`).
-   `src.webdriver`: Предоставляет классы для управления веб-браузером (Chrome) для автоматизации действий на сайтах, например, в Facebook.
-   `src.llm`: Содержит классы для взаимодействия с моделями машинного обучения (Gemini, OpenAI) для генерации текста.
-   `src.endpoints.prestashop`: Содержит классы для работы с PrestaShop API (управление **товарами**, языками, полями **товаров**).
-   `src.utils`: Предоставляет вспомогательные функции для работы с файлами (чтение/запись текста, получение списка файлов), JSON (загрузка/сохранение).
-   `src.logger`: Используется для централизованного логирования событий и ошибок.

Модуль включает два основных класса: `Config` для управления конфигурацией точки доступа и `EmilDesign` для выполнения основных бизнес-логик по обработке изображений, продвижению и загрузке **товаров**.

## Классы

### `Config`

**Описание**: Класс для управления конфигурационными параметрами точки доступа `emil-design.com`.

**Наследует**: Не наследует явно.

**Атрибуты**:

*   `ENDPOINT` (str): Название конечной точки ('emil').
*   `MODE` (str): Режим работы ('dev', 'dev8', 'prod'). Определяет, к какому окружению PrestaShop подключаться.
*   `POST_FORMAT` (str): Формат данных для POST-запросов ('XML').
*   `API_DOMAIN` (str): Домен PrestaShop API.
*   `API_KEY` (str): Ключ PrestaShop API.

**Параметры**: Отсутствуют, это статический класс конфигурации.

**Принцип работы**:
Класс `Config` определяет константы, специфичные для конечной точки `emil`. Наиболее важная часть его логики заключается в определении `API_DOMAIN` и `API_KEY`. Эти значения могут загружаться либо из переменных окружения (если `USE_ENV` установлено в `True`), либо из структуры учетных данных, предоставляемой модулем `gs` (если `USE_ENV` установлено в `False`). Выбор конкретных учетных данных из `gs` зависит от значения атрибута `MODE` ('dev', 'dev8', 'prod'). Если `MODE` не указан или имеет невалидное значение, по умолчанию используется режим 'dev'. Этот механизм позволяет легко переключаться между различными окружениями PrestaShop (разработка, staging, продакшн).

### `EmilDesign`

**Описание**: Dataclass для агрегирования функциональности, связанной с обработкой изображений, созданием описаний с использованием AI, продвижением в Facebook и загрузкой **товаров** в PrestaShop для магазина `emil-design.com`.

**Наследует**: Не наследует явно, но использует декоратор `@dataclass`.

**Атрибуты**:

*   `gemini` (Optional[GoogleGenerativeAi]): Экземпляр клиента Google Gemini API. Инициализируется в методе `describe_images`, если `use_gemini` установлен в `True`.
*   `openai` (Optional[OpenAIModel]): Экземпляр клиента OpenAI API. Инициализируется в методе `describe_images`, если `use_openai` установлен в `True`.
*   `base_path` (Path): Базовый путь к файлам конфигурации и инструкций для данной конечной точки (`emil`). Определяется на основе `gs.path.endpoints` и `Config.ENDPOINT`.
*   `config` (SimpleNamespace): Конфигурация конечной точки, загруженная из JSON файла `emil.json`, расположенного в `base_path`.
*   `data_path` (Path): Путь для хранения рабочих данных (изображений, описаний в JSON, списка обработанных изображений) для данной конечной точки. Путь определяется из конфигурации (`config.storage`) или по умолчанию используется `external_storage` внутри структуры `gs.path`.
*   `gemini_api` (str): Ключ Google Gemini API. Загружается из переменных окружения или из `gs.credentials`.
*   `presta_api` (str): Ключ PrestaShop API. Загружается из переменных окружения или из `gs.credentials`.
*   `presta_domain` (str): Домен PrestaShop API. Загружается из переменных окружения или из `gs.credentials`.

**Параметры**: Отсутствуют, поскольку это dataclass, параметры определяются атрибутами.

**Принцип работы**:
Класс `EmilDesign` служит контейнером для методов, выполняющих основные задачи. При создании экземпляра класса инициализируются пути к рабочим директориям и загружается конфигурация из файла `emil.json`. Также определяются API ключи и домены для Gemini и PrestaShop, используя либо переменные окружения, либо данные из `gs.credentials`. Методы класса (`describe_images`, `promote_to_facebook`, `upload_described_products_to_prestashop`) используют эти атрибуты и взаимодействуют с внешними библиотеками (webdriver, LLM, PrestaShop API) для выполнения своих функций.

**Методы**:
*   `describe_images()`: Описывает изображения с использованием AI моделей.
*   `promote_to_facebook()`: Продвигает **товары** (изображения с описаниями) в Facebook.
*   `upload_described_products_to_prestashop()`: Загружает описания **товаров** в PrestaShop.

## Методы класса

### `describe_images`

```python
def describe_images(
    self,
    lang: str,
    models: dict = {
        'gemini': {'model_name': 'gemini-1.5-flash'},
        'openai': {'model_name': 'gpt-4o-mini', 'assistant_id': 'asst_uDr5aVY3qRByRwt5qFiMDk43'},
    },
) -> None:
    """ Описывает изображения на основе предоставленных инструкций и примеров, используя выбранные AI модели.

    Args:
        lang (str): Язык для генерации описания ('he' для иврита, 'en' для английского, 'ru' для русского). Определяет, какие файлы инструкций (`system_instruction.{lang}.md`, `hand_made_furniture.{lang}.md`) будут загружены.
        models (dict, optional): Словарь с конфигурацией AI моделей. По умолчанию используются модели Gemini и OpenAI с указанными именами и assistant_id для OpenAI. Словарь должен содержать ключи 'gemini' и/или 'openai' с соответствующими параметрами.

    Returns:
        None: Функция не возвращает явного значения. Результат работы (описания изображений в формате JSON и список обработанных файлов) сохраняется на диск.

    Raises:
        FileNotFoundError: Возникает, если не найдены файлы инструкций (system_instruction.{lang}.md, hand_made_furniture.{lang}.md) или файл с категориями мебели (main_categories_furniture.json).
        Exception: Возникает при любой другой ошибке в процессе обработки изображений (например, ошибка при чтении файла изображения, ошибка при запросе к AI API, ошибка при сохранении файла).

    Example:
        >>> emil = EmilDesign()
        >>> # Описать изображения на иврите, используя модель Gemini (по умолчанию)
        >>> emil.describe_images('he')
        >>> # Описать изображения на английском, используя только модель OpenAI
        >>> emil.describe_images('en', models={'openai': {'model_name': 'gpt-4o-mini', 'assistant_id': 'asst_xyz'}}), use_gemini=False, use_openai=True) # Предполагая, что use_gemini и use_openai можно передать
    """
    ...
```

**Как работает функция**:
1.  **Загрузка инструкций и промптов**: Функция считывает содержимое файлов `system_instruction.{lang}.md`, `hand_made_furniture.{lang}.md` и `main_categories_furniture.json` из директории `instructions` и `categories` внутри `base_path`. Эти файлы содержат системные инструкции для AI, основной промпт для описания мебели и список категорий мебели. Содержимое всех файлов объединяется в одну строку `system_instruction`.
2.  **Подготовка списка изображений**: Определяется путь к файлу `described_images.txt`, который содержит список уже обработанных изображений. Содержимое этого файла считывается. Определяется путь к директории с изображениями (`images/furniture_images` внутри `data_path`). Получается список всех файлов изображений в этой директории. Затем формируется список `images_to_process`, исключая те изображения, пути к которым уже содержатся в списке `described_images`.
3.  **Инициализация AI моделей**: Проверяются флаги `use_openai` и `use_gemini` (хотя в предоставленном коде `use_openai` всегда `False`, а `use_gemini` всегда `True`). В зависимости от установленных флагов и конфигурации в словаре `models`, создаются экземпляры классов `OpenAIModel` и/или `GoogleGenerativeAi`. API ключи и системные инструкции передаются при инициализации.
4.  **Обработка изображений**: Функция итерируется по списку `images_to_process`. Для каждого файла изображения:
    *   Логируется начало обработки файла.
    *   Считываются "сырые" данные изображения в байтах с помощью `get_raw_image_data`.
    *   Вызывается метод `describe_image` соответствующего экземпляра AI модели (`self.gemini` в данном случае), передавая данные изображения, MIME тип и промпт. Ожидается ответ от AI.
    *   Если ответ получен, он парсится как JSON (с учетом возможности возврата списка или одного объекта).
    *   В полученный словарь добавляется ключ `local_image_path` с полным путем к обработанному файлу изображения.
    *   Результат (словарь с описанием и путем к файлу) сохраняется в новый JSON файл в директории `data_path` с именем, соответствующим имени файла изображения (например, `image.jpg.json`).
    *   Путь к обработанному изображению добавляется в список `described_images`.
    *   Обновленный список `described_images` сохраняется обратно в файл `described_images.txt`.
    *   Делается пауза в 15 секунд перед обработкой следующего изображения для соблюдения лимитов API или уменьшения нагрузки.
5.  **Обработка исключений**: Функция включает блоки `try...except` для перехвата ошибок `FileNotFoundError` (для отсутствующих файлов инструкций/категорий/обработанных изображений) и общих `Exception` для любых других ошибок в процессе. Ошибки логируются с подробной информацией.

### `promote_to_facebook`

```python
async def promote_to_facebook(self) -> None:
    """ Продвигает изображения и их описания путем создания постов в группе Facebook.

    Args:
        None: Метод не принимает аргументов. Данные для постов загружаются из предопределенного файла.

    Returns:
        None: Метод не возвращает явного значения. Результатом является создание постов в Facebook.

    Raises:
        Exception: Возникает при любой ошибке в процессе продвижения в Facebook (например, ошибка инициализации драйвера, ошибка при навигации по сайту, ошибка при выполнении локаторов для создания поста).
    """
    ...
```

**Как работает функция**:
1.  **Инициализация вебдрайвера**: Создается экземпляр вебдрайвера (`Driver`) с использованием браузера Chrome.
2.  **Навигация**: Вебдрайвер открывает URL указанной группы Facebook (`https://www.facebook.com/groups/1080630957030546`).
3.  **Загрузка данных для постов**: Данные с описаниями изображений загружаются из JSON файла `images_descritions_he.json`, расположенного в `base_path`, и преобразуются в список объектов `SimpleNamespace`.
4.  **Создание постов**: Функция итерируется по списку загруженных сообщений (`messages`). Для каждого сообщения:
    *   Создается объект `SimpleNamespace` (`message`), который структурирует данные в формате, ожидаемом функцией `post_message`. Заголовок поста формируется из `parent` и `category`, описание берется из `description`, а путь к локальному файлу изображения (`local_image_path`) помещается в список под атрибутом `products.local_image_path`.
    *   Вызывается внешняя функция `post_message`, которая использует предоставленный вебдрайвер (`d`) и объект `message` для автоматизации создания поста в Facebook. Флаг `without_captions=True` указывает, что подписи под изображениями в посте создавать не нужно. (Внутри `post_message` используются методы вебдрайвера, включая `execute_locator`, для взаимодействия с элементами страницы Facebook).
5.  **Обработка исключений**: Функция включает блок `try...except` для перехвата общих `Exception` и логирования ошибок, произошедших в процессе работы с вебдрайвером и создания постов.

### `upload_described_products_to_prestashop`

```python
def upload_described_products_to_prestashop(
    self, products_list: Optional[List[SimpleNamespace]] = None, id_lang: Optional[int | str] = 2, *args, **kwards
) -> bool:
    """ Загружает информацию о товарах, полученную из описаний изображений, в PrestaShop.

    Args:
        products_list (Optional[List[SimpleNamespace]], optional): Список объектов SimpleNamespace, каждый из которых содержит данные одного товара. Если не предоставлен (None), функция самостоятельно загружает данные из JSON файлов в data_path. По умолчанию None.
        id_lang (Optional[int | str], optional): Идентификатор языка для PrestaShop. Может быть строкой ('en', 'he', 'ru') или целочисленным ID. Определяет, на каком языке будут загружены названия и описания товаров. Обычно 1 - en, 2 - he, 3 - ru, но необходимо проверить в целевой базе данных (см. пример получения схемы языков). По умолчанию 2 (иврит).
            Пример получения словаря языков из целевой базы данных:
            ```python
            import language
            lang_class = PrestaLanguage()
            print(lang_class.get_languages_schema())
            ```
        *args, **kwards: Дополнительные позиционные и именованные аргументы (используются для совместимости, но не обрабатываются явно в теле функции).

    Returns:
        bool: Возвращает `True`, если процесс загрузки завершился успешно для всех товаров, и `False` в случае возникновения любой ошибки.

    Raises:
        FileNotFoundError: Возникает, если не найден файл `locales.json` с маппингом языков.
        Exception: Возникает при любой другой ошибке в процессе загрузки товаров в PrestaShop (например, ошибка при чтении JSON файлов, ошибка при работе с PrestaShop API через экземпляр PrestaProduct).
    """
    ...
```

**Как работает функция**:
1.  **Загрузка данных о товарах**: Проверяется, был ли передан список `products_list`. Если нет (равен `None`), функция получает список всех JSON файлов в директории `data_path` с помощью `get_filenames_from_directory` и загружает содержимое каждого файла как `SimpleNamespace` с помощью `j_loads_ns`. Полученный список объектов `SimpleNamespace` сохраняется в переменную `products_list`.
2.  **Инициализация клиента PrestaShop API**: Создается экземпляр класса `PrestaProduct`, который является клиентом для взаимодействия с PrestaShop API. При инициализации передаются домен (`Config.API_DOMAIN`) и ключ API (`Config.API_KEY`), определенные в классе `Config`.
3.  **Определение идентификатора языка**: Загружается маппинг языков из файла `locales.json`, расположенного в директории `shop_locales` относительно корня проекта. Проверяется тип параметра `id_lang`. Если это строка ('en', 'he', 'ru'), функция пытается найти соответствующий целочисленный ID в загруженном маппинге языков (`lang_ns`). Если `id_lang` уже является числом, оно используется напрямую. Если формат `id_lang` некорректен и не может быть преобразован в число, логируется ошибка.
4.  **Загрузка товаров**: Функция итерируется по каждому объекту `SimpleNamespace` (`product_ns`) в списке `products_list`. Для каждого **товара**:
    *   Создается экземпляр класса `ProductFields`, который представляет структуру данных **товара** для PrestaShop API. При инициализации передается определенный на предыдущем шаге `id_lang`.
    *   Поля экземпляра `ProductFields` (`f`) заполняются данными из `product_ns` (имя, описание, путь к локальному изображению). Устанавливаются фиксированные значения для цены (`price`, `wholesale_price`) и поставщика (`id_supplier`).
    *   Устанавливаются идентификаторы категорий: `id_category_default` из `product_ns.id_category_default` и добавляется дополнительная категория `id_category_parent` с помощью метода `additional_category_append`.
    *   Вызывается метод `p.add_new_product(f)` экземпляра клиента PrestaShop API (`p`) для добавления нового **товара** в PrestaShop с использованием подготовленных данных из `ProductFields`.
5.  **Возврат результата**: Если весь цикл загрузки товаров завершается без исключений, функция возвращает `True`.
6.  **Обработка исключений**: Функция включает блоки `try...except` для перехвата `FileNotFoundError` (для файла `locales.json`) и общих `Exception`. В случае возникновения любой ошибки, она логируется с подробной информацией, и функция возвращает `False`.

## Параметры класса EmilDesign

*   `gemini` (Optional[GoogleGenerativeAi]): Экземпляр класса, представляющего клиента для взаимодействия с Google Gemini API. Используется для отправки запросов на описание изображений. Является опциональным и может быть `None`, если использование Gemini отключено. Инициализируется внутри метода `describe_images`.
*   `openai` (Optional[OpenAIModel]): Экземпляр класса, представляющего клиента для взаимодействия с OpenAI API. Аналогично `gemini`, используется для описания изображений, опционален (`None`) и инициализируется в `describe_images`.
*   `base_path` (Path): Объект `Path` из модуля `pathlib`, указывающий на базовую директорию для данной конечной точки (`emil`) в структуре проекта `hypotez`. Используется для доступа к файлам конфигурации, инструкций и категорий. Формируется как `gs.path.endpoints / Config.ENDPOINT`.
*   `config` (SimpleNamespace): Объект `SimpleNamespace`, полученный путем загрузки и парсинга JSON файла `emil.json` с помощью `j_loads_ns`. Этот файл содержит специфические настройки для конечной точки `emil`, такие как имя хранилища данных (`storage`).
*   `data_path` (Path): Объект `Path`, указывающий на директорию, где хранятся рабочие данные для конечной точки `emil`. Это включает исходные изображения, сгенерированные описания в формате JSON, и файл со списком уже обработанных изображений. Путь определяется на основе значения атрибута `storage` из загруженного конфига (`config.storage`) в структуре `gs.path`, с добавлением `Config.ENDPOINT`. Если `config.storage` не указан, используется `gs.path.external_storage`.
*   `gemini_api` (str): Строка, содержащая API ключ для доступа к Google Gemini API. Значение загружается либо из переменной окружения `GEMINI_API` (если `USE_ENV` = `True`), либо из структуры учетных данных `gs.credentials.gemini.emil` (если `USE_ENV` = `False`).
*   `presta_api` (str): Строка, содержащая API ключ для доступа к PrestaShop API. Значение загружается либо из переменной окружения `PRESTA_API` (если `USE_ENV` = `True`), либо из структуры учетных данных `gs.credentials.presta.client.emil_design.api_key` (если `USE_ENV` = `False`).
*   `presta_domain` (str): Строка, содержащая доменное имя магазина PrestaShop, к которому осуществляется подключение через API. Значение загружается либо из переменной окружения `PRESTA_URL` (если `USE_ENV` = `True`), либо из структуры учетных данных `gs.credentials.presta.client.emil_design.api_domain` (если `USE_ENV` = `False`).

## Примеры использования

Пример использования класса и его методов:

```python
# Импорт класса
from src.endpoints.emil.emil_design import EmilDesign
import asyncio

# Создание экземпляра класса EmilDesign
# При создании экземпляра происходит загрузка конфигурации и определение путей и API ключей
emil = EmilDesign()

# Пример вызова метода describe_images для описания изображений на иврите ('he')
# Метод обрабатывает изображения из data_path/images/furniture_images,
# генерирует описания с помощью Gemini (по умолчанию) и сохраняет их в data_path/*.json
# emil.describe_images('he')

# Пример вызова метода promote_to_facebook для создания постов в Facebook группе
# Метод использует вебдрайвер для автоматизации действий в браузере.
# Он загружает данные из data_path/images_descritions_he.json и создает посты.
# asyncio.run(emil.promote_to_facebook()) # promote_to_facebook является асинхронным методом

# Пример вызова метода upload_described_products_to_prestashop
# Метод загружает данные из JSON файлов в data_path в PrestaShop.
# id_lang = 2 соответствует ивриту в настройках магазина emil-design.com
success = emil.upload_described_products_to_prestashop(id_lang=2)
if success:
    print('Загрузка товаров в PrestaShop завершена успешно.')
else:
    print('Произошла ошибка при загрузке товаров в PrestaShop.')

# Пример использования __main__ блока (как показано в коде)
# if __name__ == '__main__':
#     emil = EmilDesign()
#     emil.upload_described_products_to_prestashop(id_lang = 2)
    # asyncio.run(emil.upload_described_products_to_prestashop_async(lang='he')) # Закомментировано в исходном коде
    # emil.describe_images('he') # Закомментировано в исходном коде
```
-------------------------------------------------------------------------------------